# 12.다중 연결 프로그램

### 개요

APRE는 내장 SQL문을 이용한 한 프로그램 내에서 하나 이상의 연결을 허용한다. 여기에서는 다중 연결 프로그램이란 무엇이고, 어떤 경우에 다중 연결 프로그램을 사용하는 지에 대해 설명한다.

#### 정의

다중 연결 프로그램이란 한 프로그램 안에서 하나 이상의 연결을 사용하는 프로그램을 말한다.

#### 필요성

다중 연결 프로그램은 어떤 경우에 사용하는지 알아보자.

- 한 프로그램 안에서 하나 이상의 데이터베이스 서버에 접근해야 하는 경우
- 한 프로그램 안에서 여러 사용자로 데이터베이스 서버에 접근해야 하는 경우
- 멀티쓰레드 프로그램인 경우. 멀티쓰레드 프로그램에 대한 자세한 설명은 13장을 참조하기 바란다.

#### 연결 이름

다중 연결 프로그램에서는 각 connection을 구분하기 위해 연결 이름을 사용한다. 연결 이름은 한 프로그램 내에서 유일해야 한다. 연결 이름을 사용하지 않는 connection은 한 프로그램 내에서 하나만 허용하며 이 connection을 “default connection”이라 한다.

연결 이름은 데이터베이스 서버와 연결 시 지정하고, 이후 수행하는 내장 SQL문에 이 connection을 사용하기 위해서는 이 연결 이름을 지정하여야 한다. 이미 connection된 연결 이름을 사용하여 다시 connection을 수행한다면 “The connection already exists.” 오류가 발생한다.

연결 이름(connection name)은 알파벳(a\~z, A\~Z), 밑줄("_"), 또는 달러 기호("\$")로 시작하여야 하며, 그 길이는 50 bytes로 제한된다.

##### 구문

내장 SQL문을 수행할 때 연결 이름을 지정하려면 다음과 같이 AT 절을 사용한다.

```
EXEC SQL [ AT <conn_name | :conn_name> ] …
```

##### 인자

연결 이름으로 스트링과 변수, 모두 사용 가능하며 변수를 사용한 경우 이 변수는 호스트 변수 선언부에서 선언하지 않은 변수도 사용할 수 있다.

- \<*conn_name*\>: 문자열 리터럴 형태의 연결 이름
- \<:*conn_name*\>: conn_name호스트 변수에 저장된 연결 이름

#### 프로그램 작성 순서

다중 연결 프로그램 작성 순서는 앞서 설명한 일반 프로그램과 크게 다르지 않다. 다중 연결 프로그램의 작성 순서는 아래와 같다.

1. 데이터베이스 서버에 연결한다. 이 때 연결 이름을 지정해 준다.
2. connection된 연결 이름을 이용하여 내장 SQL문을 수행한다.
3. 모든 connection된 연결 이름을 이용하여 연결 해제한다.

### 다중 연결 프로그램에서 내장 SQL문 사용 방법

다중 연결 프로그램에서의 내장 SQL문 사용 방법은 일반 내장 SQL문 사용 방법과 크게 다르지 않다. 기본적인 구문은 동일하고 AT절을 사용하여 연결 이름을 지정해주면 된다. 여기에서는 다중 연결 프로그램에서의 내장 SQL문 사용 방법에 대해 설명한다.

#### CONNECT

지정한 연결 이름으로 데이터베이스 서버에 연결한다.

##### 구문

```
EXEC SQL [ AT <conn_name | :conn_name> ] 
CONNECT <:user> IDENTIFIED BY <:passwd> 
[ USING <:conn_opt1> [ , <:conn_opt2> ] ];
```

##### 인자

- \<*conn_name*\>: 문자열 리터럴 형태의 연결 이름
- \<:*conn_name*\>: conn_name호스트 변수에 저장된 연결 이름
- \<:*user*\>: 데이터베이스 서버에 연결할 사용자 이름
- \<:*passwd*\>: 데이터베이스 서버에 연결할 사용자 암호
- \<:*conn_opt1*\> : 6장 참조
- \<:*conn_opt2*\> : 6장 참조

##### 설명

한 프로그램 내에서 하나 이상의 연결을 할 때 반드시 연결 이름을 주어야하며 이 연결 이름은 프로그램 내에서 유일한 이름이어야 한다. 이후 내장 SQL문에서도 AT절을 이용하여 사용할 연결 이름을 명시하여야 한다.

> ##### 주의 사항
>
> - 다중 연결 프로그램에서 연결 이름을 가지지 않는 연결은 하나만 허용하며, 이후 AT절을 사용하지 않은 내장 SQL문은 이 연결을 이용하여 처리된다.
> - CONNECT 후 같은 연결 이름으로 다시 CONNECT를 수행한다면 “The connection already exists.” 오류가 발생한다. 따라서 CONNECT 후 같은 연결 이름으로 다시 CONNECT를 수행하려면 먼저 FREE 또는 DISCONNECT를 수행하여야 한다. 이 때, 데이터베이스 서버가 running 상태라면 DISCONNECT를, running 상태가 아니라면 FREE를 수행하여야 한다.
> 

##### 예제

연결 이름을 사용하여 데이터베이스 서버에 연결하는 다양한 예를 보여준다.

[예제 1] 다음은 문자열 리터럴을 이용한 연결 이름으로 데이터베이스 서버에 연결하는 예를 보여준다. 여기에서는 “CONN1”이 연결 이름이 된다.

\< 예제 프로그램 : mc1.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
char usr[10];
char pwd[10];
EXEC SQL END DECLARE SECTION;

/* set username */
strcpy(usr, "SYS");
/* set password */
strcpy(pwd, "MANAGER");

/* connect to altibase server with CONN1 */
EXEC SQL AT CONN1 CONNECT :usr IDENTIFIED BY :pwd;  
```

[예제 2] 다음은 호스트 변수를 이용한 연결 이름으로 데이터베이스 서버에 연결하는 예를 보여준다. 여기에서는 “CONN2”’가 연결 이름이 된다.

\< 예제 프로그램 : mc2.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
char usr[10];
char pwd[10];
char conn_name2[10];
EXEC SQL END DECLARE SECTION;

/* set username */
strcpy(usr, "ALTITEST");
/* set password */
strcpy(pwd, "ALTITEST");
/* set connname */
strcpy(conn_name2, "CONN2");

/* connect to altibase server with :conn_name2 */
EXEC SQL AT :conn_name2 CONNECT :usr IDENTIFIED BY :pwd;  
```

#### DISCONNECT

지정한 연결 이름으로 데이터베이스 서버와의 연결을 해제한다.

##### 구문

```
EXEC SQL [ AT <conn_name | :conn_name> ]
DISCONNECT;
```

##### 인자

- \<*conn_name*\>: 문자열 리터럴 형태의 연결 이름
- \<:*conn_name*\>: conn_name호스트 변수에 저장된 연결 이름

> ##### 주의 사항
>
> 연결 이름은 유효한 즉, 이미 연결된 이름이어야 한다.
>
> 다중 연결 프로그램에서는 연결된 모든 connection에 대해서 각각 연결 이름을 이용하여 연결 해제를 해주어야 한다.

##### 예제

연결 이름을 사용하여 연결 해제를 수행하는 다양한 예를 보여준다.

[예제 1] 다음은 문자열 리터럴을 이용한 연결 이름으로 데이터베이스 서버와의 연결을 해제하는 예를 보여준다. 여기에서는 “CONN1” 연결을 해제한다.

\< 예제 프로그램 : mc1.sc \>

```
EXEC SQL AT CONN1 DISCONNECT;
```

[예제 2] 다음은 호스트 변수를 이용한 연결 이름으로 데이터베이스 서버와의 연결을 해제하는 예를 보여준다. 여기에서는 “CONN2” 연결을 해제한다.

\< 예제 프로그램 : mc2.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
char conn_name2[10];
EXEC SQL END DECLARE SECTION;

strcpy(conn_name2, "CONN2");
EXEC SQL AT :conn_name2 DISCONNECT;
```

#### 기본 내장 SQL문

SELECT, UPDATE 등의 DML문과 CREATE, DROP 등의 DDL문을 수행할 수 있다.

##### 구문

```
EXEC SQL [ AT <conn_name | :conn_name> ] 
[ SELECT | UPDATE | INSERT | DELETE | CREATE ] … 
```

##### 인자

- \<*conn_name*\>: 문자열 리터럴 형태의 연결 이름
- \<:*conn_name*\>: conn_name호스트 변수에 저장된 연결 이름

> ##### 주의 사항
>
> 연결 이름은 유효한 즉, 이미 연결된 이름이어야 한다.
>

#### 커서 처리 SQL문

커서 관련 내장 SQL문을 수행할 수 있다.

##### 구문

```
EXEC SQL [ AT <conn_name | :conn_name> ] 
[ DELCARE | OPEN | FETCH | CLOSE ]  <cursor_name> … 
```

##### 인자

- \<*conn_name*\>: 문자열 리터럴 형태의 연결 이름
- \<:*conn_name*\>: conn_name호스트 변수에 저장된 연결 이름
- \<cursor_name\>: 커서 이름

> ##### 주의 사항
>
> 연결 이름은 유효한 즉, 이미 연결된 이름이어야 한다.
>

#### 동적SQL문

동적 SQL문을 수행할 수 있다.

##### 구문

###### 메소드 1

```
EXEC SQL [ AT <conn_name | :conn_name> ] 
EXECUTE IMMEDIATE … 
```

###### 메소드 2

```
EXEC SQL [ AT <conn_name | :conn_name> ] PREPARE … 
EXEC SQL [ AT <conn_name | :conn_name> ] EXECUTE … 
```

###### 메소드 3

```
EXEC SQL [ AT <conn_name | :conn_name> ] PREPARE … 
EXEC SQL [ AT <conn_name | :conn_name> ] DECLARE …
EXEC SQL [ AT <conn_name | :conn_name> ] OPEN …
EXEC SQL [ AT <conn_name | :conn_name> ] FETCH …
EXEC SQL [ AT <conn_name | :conn_name> ] CLOSE …
```

##### 인자

- \<*conn_name*\>: 문자열 리터럴 형태의 연결 이름
- \<:*conn_name*\>: conn_name호스트 변수에 저장된 연결 이름

> ##### 주의 사항
>
> 연결 이름은 유효한 즉, 이미 연결된 이름이어야 한다.
>

#### 기타 내장 SQL문

기타 내장 SQL문을 수행할 수 있다.

##### 구문

```
EXEC SQL [ AT <conn_name | :conn_name> ] 
AUTOCOMMIT { ON | OFF };
EXEC SQL [ AT <conn_name | :conn_name> ]  
COMMIT;
EXEC SQL [ AT <conn_name | :conn_name> ]  
SAVEPOINT <savepoint_name>;
EXEC SQL [ AT <conn_name | :conn_name> ] 
ROLLBACK [ TO SAVEPOINT <savepoint_name> ];
EXEC SQL [ AT <conn_name | :conn_name> ] 
FREE;
EXEC SQL [ AT <conn_name | :conn_name> ] 
BATCH;
```

##### 인자

- \<*conn_name*\>: 문자열 리터럴 형태의 연결 이름
- \<:*conn_name*\>: conn_name호스트 변수에 저장된 연결 이름
- \<savepoint_name\>: 저장점 이름

> ##### 주의 사항
>
> 연결 이름은 유효한 즉, 이미 연결된 이름이어야 한다.
>

#### 예외 사항

다중 연결 프로그램에서 예외적으로 AT절을 사용하지 않는 내장 SQL문이 있는데, 다음과 같다.

##### 구문

```
EXEC SQL INCLUDE …
EXEC SQL OPTION …
EXEX SQL WHENEVER …
```

### 다중 연결 프로그램에서의 저장 프로시저 처리 SQL문

다중 연결 프로그램 안에서 저장 프로시저 처리 SQL문을 사용할 수 있다. 이 경우 AT절이 추가된 것 외에는 앞서 12장에서 설명한 구문과 동일하다.

#### CREATE

다중 연결 프로그램 안에서 저장 프로시저 또는 저장 함수를 생성한다.

##### 구문

```
EXEC SQL [ AT <conn_name | :conn_name> ] 
CREATE [ OR REPLACE ] <PROCEDURE | FUNCTION>
…
END 
[ <procedure_name | function_name> ] ; 
END-EXEC;
```

##### 인자

- \<*conn_name*\>: 문자열 리터럴 형태의 연결 이름
- \<:*conn_name*\>: conn_name호스트 변수에 저장된 연결 이름

- \<*procedure_name*\>: 저장 프로시저의 이름

- \<*function_name*\>: 저장 함수의 이름


> ##### 주의 사항
>
> 연결 이름은 유효한 즉, 이미 연결된 이름이어야 한다.
>

#### ALTER

다중 연결 프로그램 안에서 저장 프로시저 또는 저장 함수를 재컴파일한다.

##### 구문 

```
EXEC SQL [ AT <conn_name | :conn_name> ] 
ALTER PROCEDURE 
<procedure_name | function_name> COMPILE; 
```

##### 인자

- \<*conn_name*\>: 문자열 리터럴 형태의 연결 이름
- \<:*conn_name*\>: conn_name호스트 변수에 저장된 연결 이름
- \<*procedure_name*\>: 저장 프로시저의 이름
- \<*function_name*\>: 저장 함수의 이름

> ##### 주의 사항
>
> 연결 이름은 유효한 즉, 이미 연결된 이름이어야 한다.
>

#### DROP

다중 연결 프로그램 안에서 저장 프로시저 또는 저장 함수를 삭제한다.

##### 구문

```
EXEC SQL [ AT <conn_name | :conn_name> ] 
DROP PROCEDURE <procedure_name | function_name>; 
```

##### 인자

- \<*conn_name*\>: 문자열 리터럴 형태의 연결 이름
- \<:*conn_name*\>: conn_name호스트 변수에 저장된 연결 이름
- \<*procedure_name*\>: 저장 프로시저의 이름
- \<*function_name*\>: 저장 함수의 이름

> ##### 주의 사항
>
> 연결 이름은 유효한 즉, 이미 연결된 이름이어야 한다.
>

#### EXECUTE

다중 연결 프로그램 안에서 저장 프로시저 또는 저장 함수를 실행한다.

##### 구문

```
EXEC SQL [ AT <conn_name | :conn_name> ] 
EXECUTE BEGIN 
/* Stored procedure block here */
END;
END-EXEC;
```

##### 인자

- \<*conn_name*\>: 문자열 리터럴 형태의 연결 이름
- \<:*conn_name*\>: conn_name호스트 변수에 저장된 연결 이름
- \<*procedure_name*\>: 저장 프로시저의 이름
- \<*function_name*\>: 저장 함수의 이름
- /\* Stored procedure block here \*/: *Stored Procedures Manual* 참조

> ##### 주의 사항
>
> 연결 이름은 유효한 것으로, 이미 연결된 이름이어야 한다.
>

### 예제 프로그램

##### mc1.sc 

$ALTIBASE_HOME/sample/APRE/mc1.sc 참고

##### 실행결과 

```
$ is –f schema/schema.sql
$ make mc1
$ ./mc1
<MULTI CONNECTION 1>
-----------------------------------------------------------
[Declare Cursor With CONN1                                       ]
-----------------------------------------------------------
Success declare cursor with CONN1

-----------------------------------------------------------
[Open Cursor With CONN1]
-----------------------------------------------------------
Success open cursor with CONN1

-----------------------------------------------------------
[Fetch Cursor With CONN1 -> Insert With CONN2]                    
-----------------------------------------------------------
30 rows inserted

-----------------------------------------------------------
[Close Cursor With CONN1]                                         
-----------------------------------------------------------
Success close cursor with CONN1
```

##### mc2.sc 

$ALTIBASE_HOME/sample/APRE/mc2.sc 참고

##### 실행결과

```
$ is –f schema/schema.sql
$ make mc2
$ ./mc2
<MULTI CONNECTION 2>
-----------------------------------------------------------
[Dynamic SQL Method 1 With :conn_name2]                           
-----------------------------------------------------------
Success dynamic sql method 1 with :conn_name2

-----------------------------------------------------------
[Dynamic SQL Method 2 (PREPARE) With :conn_name2]                 
-----------------------------------------------------------
Success dynamic sql method 2 (prepare) with :conn_name2

-----------------------------------------------------------
[Dynamic SQL Method 3 (PREPARE) With :conn_name1]                 
-----------------------------------------------------------
Success dynamic sql method 3 (prepare) with :conn_name1

-----------------------------------------------------------
[Dynamic SQL Method 3 (DECLARE CURSOR) With :conn_name1]          
-----------------------------------------------------------
Success dynamic sql method 3 (declare cursor) with :conn_name1

-----------------------------------------------------------
[Dynamic SQL Method 3 (OPEN CURSOR) With :conn_name1]             
-----------------------------------------------------------
Success dynamic sql method 3 (open cursor) with :conn_name1

-----------------------------------------------------------
[Dynamic SQL Method 3 (FETCH CURSOR) With :conn_name1             
 -> Dynamic SQL Method 2 (EXECUTE-INSERT) With :conn_name2]       
-----------------------------------------------------------
20 rows inserted

-----------------------------------------------------------
[Dynamic SQL Method 3 (CLOSE CURSOR) With :conn_name1]            
-----------------------------------------------------------
Success dynamic sql method 3 (close cursor) with :conn_name1
```

##### mc3.sc 

$ALTIBASE_HOME/sample/APRE/mc3.sc 참고

##### 실행결과 

```
$ is –f schema/schema.sql
$ make mc3
$ ./mc3
<MULTI CONNECTION 3>
-----------------------------------------------------------
[Autocommit Off With CONN1]                                       
-----------------------------------------------------------
Autocommit mode of CONN1 session modified false

-----------------------------------------------------------
[Autocommit Off With CONN2]                                       
-----------------------------------------------------------
Autocommit mode of CONN2 session modified false

-----------------------------------------------------------
[Create Procedure With CONN1]                                     
-----------------------------------------------------------
Success create procedure

-----------------------------------------------------------
[Create Procedure With CONN2]                                     
-----------------------------------------------------------
Success create procedure

-----------------------------------------------------------
[Execute Procedure With CONN1]                                    
-----------------------------------------------------------
Success execute procedure

-----------------------------------------------------------
[Execute Procedure With CONN2]                                    
-----------------------------------------------------------
Success execute procedure

-----------------------------------------------------------
[Commit With CONN1]                                               
-----------------------------------------------------------
Success commit

-----------------------------------------------------------
[Commit With CONN2]                                               
-----------------------------------------------------------
Success commit

-----------------------------------------------------------
[Drop Procedure With CONN1]                                       
-----------------------------------------------------------
Success drop procedure

----------------------------------------------------------- 
[Drop Procedure With CONN2]                                       
-----------------------------------------------------------
Success drop procedure 
```

