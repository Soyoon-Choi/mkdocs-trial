# 2.호스트 변수와 지시자 변수

### 호스트 변수 

#### 개요

호스트 변수(host variables)는 호스트 언어로 작성된 애플리케이션과 데이터베이스 서버와의 데이터 교환 역할을 한다. 즉, 테이블의 칼럼값을 호스트 변수에 저장하거나 호스트 변수값을 데이터베이스 테이블의 칼럼에 삽입하는 등의 역할을 한다.

#### 선언 방법

호스트 변수 선언 방법은 다음과 같다.

-   호스트 변수 선언부 또는 함수 인자 선언부에서 선언한다. 만약 호스트 변수 선언부 또는 함수 인자 선언부에서 선언하지 않은 변수를 내장 SQL문에서 사용할 경우 전처리 시 “The host variable [variable_name] is unknown.” 오류가 발생한다. 
    호스트 변수 선언부 또는 함수 인자 선언부에 대한 자세한 설명은 3장을 참조하기 바란다.
    
-   호스트 변수 선언 구문은 다음과 같다.  
    datatype variable_name;  
    즉, C 또는 C++ 프로그램에서의 변수 선언 방법과 동일하다.  
    호스트 변수의 데이터 타입에 대한 자세한 설명은 5장을 참조하기 바란다.

-   배열 호스트 변수 선언은 char 타입과 varchar 타입에 대해 2차원 배열 선언이 가능하고 그 외 타입들은 1차원 배열 선언이 가능하다. 배열 처리 SQL문에 대한 자세한 설명은 9장을 참고하기 바란다.
    
-   Altibase가 지원하는 내셔널 캐릭터 타입을 Precompiler에서 처리하기 위해서는 호스트 변수로 char 타입과 varchar 타입만 사용이 가능하고, 다음과 같은 예약어를 사용해야 한다.  
    character set [is] nchar_cs  
    그러나 컴파일할 때 명령행에 옵션 nchar_var를 설정하면, 예약어를 사용하지 않고도 사용할 수 있다.
    
-   호스트 변수명은 알파벳(a\~z, A\~Z), 밑줄("_"), 또는 달러 기호("\$")로 시작하여야 하며, 그 길이는 50 bytes로 제한된다.

#### 사용 방법

호스트 변수는 내장 SQL문에서 스칼라 표현식이 허용되는 위치에 사용할 수 있다.

호스트 변수는 내장 SQL문에서 다른 SQL 구성 요소와 구분되어야 하므로 “**:**” 을 접두어로 가진다.

#### 예제

다음 예제는 s_dno, s_dname, s_dep_location 을 호스트 변수로 선언하고 사용하는 예를 보여준다.

\< 예제 프로그램 : select.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
short      s_dno;
char       s_dname[30+1];
char       s_dep_location[9+1];
EXEC SQL END DECLARE SECTION;

EXEC SQL SELECT DNAME, DEP_LOCATION
INTO :s_dname, :s_dep_location
FROM DEPARTMENTS
WHERE DNO = :s_dno;
```

### 호스트 변수 분류

호스트 변수는 데이터베이스 서버에 데이터 입력용으로 사용되는지, 데이터베이스로부터 데이터 출력용으로 사용되는지에 따라 입력 호스트 변수 또는 출력 호스트 변수로 구분된다.

#### 출력 호스트 변수

출력 호스트 변수는 SELECT문과 FETCH문의 INTO절에 사용되는 호스트 변수로 이 호스트 변수에는 질의 결과가 저장된다. ODBC의 SQLBindCol() 함수에 사용하는 변수와 같은 역할을 한다.

##### 예제

다음 예제는 출력 호스트 변수의 사용 예를 보여준다.

여기에서는 s_dname, s_dep_location이 출력 호스트 변수로 사용되었다. 조건에 맞는 레코드의 DNAME, DEP_LOCATION 칼럼값이 각각 호스트 변수 s_dname, s_dep_location에 저장된다.

\< 예제 프로그램 : select.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
short      s_dno;
char       s_dname[30+1];
char       s_dep_location[9+1];
EXEC SQL END DECLARE SECTION;

s_dno = 1001;
EXEC SQL SELECT DNAME, DEP_LOCATION
INTO :s_dname, :s_dep_location
FROM DEPARTMENTS
WHERE DNO = :s_dno;
```

#### 입력 호스트 변수

입력 호스트 변수는 출력 호스트 변수의 경우를 제외한 모든 경우의 호스트 변수로, 주로 SQL문의 입력값을 지정하기 위한 용도로 사용된다. 예를 들어, SELECT문의 WHERE절에 조건값을 지정하거나, INSERT문의 VALUES절에 레코드의 칼럼값을 지정하는 역할을 한다.

입력 호스트 변수는 내장 SQL문에서 스칼라 표현식이 허용되는 위치에 사용된다. 그러나 호스트 변수를 SELECT문의 TARGET절이나 GROUP BY절, ORDER BY절에 사용하기 위해서는 CAST 연산자를 이용하여 그 타입을 명시해야 한다. 단 GROUP BY절에 CAST 연산자를 사용해서 호스트 변수의 타입을 명시한 표현식이 존재하는 경우 해당 표현식을 target 절에서 사용할 수 없다.

Where절에서 호스트 변수의 사용은 가능하다. 그러나 Where절의 join predicate에 호스트 변수가 사용되는 경우, 데이터 타입을 알 수 없어 항상 NL join method를 사용하는 execution plan이 만들어진다. 이런 상황을 피하려면, 호스트 변수를 사용할 때 CAST 연산자를 사용하여 타입이 결정되도록 하면 더 좋은 join method를 선택할 수 있다.

##### 예제

입력 호스트 변수의 다양한 사용 예를 보여준다.

[예제 1] 다음은 INSERT문에서의 입력 호스트 변수의 사용 예이다. 여기에서는 s_gno, s_gname, s_goods_location, s_stock, s_price가 입력 호스트 변수로 사용되었다. 입력 호스트 변수값이 칼럼값으로 삽입된다.

\< 예제 프로그램 : insert.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
char    s_gno[10+1];
char    s_gname[20+1];
char    s_goods_location[9+1];
int     s_stock;
double  s_price;
EXEC SQL END DECLARE SECTION;

strcpy(s_gno, "F111100002");
strcpy(s_gname, "XX-101");
strcpy(s_goods_location, "FD0003");
s_stock = 5000;
s_price = 9980.21;

EXEC SQL INSERT INTO GOODS 
VALUES (:s_gno, :s_gname, :s_goods_location, 
:s_stock, :s_price);
```

[예제 2] 다음은 UPDATE문에서의 입력 호스트 변수의 사용 예이다. 여기에서는 s_dno, s_emp_job, s_eno가 입력 호스트 변수로 사용되었다. 조건에 맞는 레코드의 DNO, EMP_JOB 칼럼값을 각각 s_dno, s_emp_job 값으로 변경한다.

\< 예제 프로그램 : update.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
int      s_eno;
short    s_dno;
varchar  s_emp_job[15+1];
EXEC SQL END DECLARE SECTION;

s_eno = 2;
s_dno = 1001;
strcpy(s_emp_job.arr, "ENGINEER");
s_emp_job.len = strlen(s_emp_job.arr);

EXEC SQL UPDATE EMPLOYEES 
SET DNO = :s_dno,
                          EMP_JOB = :s_emp_job
            WHERE ENO = :s_eno;
```

[예제 3] 다음은 DELETE문에서의 입력 호스트 변수의 사용 예이다. 여기에서는 s_eno, s_dno가 입력 호스트 변수로 사용되었다. 호스트 변수값을 이용하여 조건에 맞는 레코드를 삭제한다.

\< 예제 프로그램 : delete.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
int      s_eno;
short    s_dno;
EXEC SQL END DECLARE SECTION;

s_eno = 5;
s_dno = 1000;

EXEC SQL DELETE FROM EMPLOYEES 
WHERE ENO > :s_eno AND 
DNO > :s_dno AND 
EMP_JOB LIKE 'P%';
```

[예제 4] 다음은 SELECT문에서의 입력 호스트 변수의 사용 예이다. 여기에서는 s_dno가 입력 호스트 변수로 사용되었다. 입력 호스트 변수 값을 이용하여 조건에 맞는 레코드를 검색한다.

\< 예제 프로그램 : select.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
short      s_dno;
char       s_dname[30+1];
char       s_dep_location[9+1];
EXEC SQL END DECLARE SECTION;

s_dno = 1001;
EXEC SQL SELECT DNAME, DEP_LOCATION
INTO :s_dname, :s_dep_location
FROM DEPARTMENTS
WHERE DNO = :s_dno;
```

[예제 5] 다음은 SELECT문의 target절에서 입력 호스트 변수를 사용하는 예이다. 여기에서는 s_call이 입력 호스트 변수로 사용되었다.

\<예제 프로그램 : host_target.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
double s_call;
EXEC SQL END DECLARE SECTION;

s_call = 0.045;

EXEC SQL SELECT 원금 * ( 1 – CAST( :s_call AS DOUBLE ) ) FROM 계좌;
```

[예제 6] 다음은 SELECT문의 group by절에서 입력 호스트 변수를 사용하는 예이다. 여기에서는 s_period가 입력 호스트 변수로 사용되었다.

\<예제 프로그램 : host_group.sc \>

```
int s_period;
EXEC SQL END DECLARE SECTION;

s_period = 1;    /* 1(월별), 3(분기별), 6(반기별) */

EXEC SQL SELECT SUM(매출) FROM sales 
                 GROUP BY FLOOR( 월 / CAST( :s_period AS INTEGER ) );
```

[예제 7] 다음은 where절의 join predicate에서 입력 호스트 변수를 사용하는 예이다. 여기에서는 s_diff가 입력 호스트 변수로 사용되었다.

\<예제 프로그램 : host_join.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
int s_diff;
EXEC SQL END DECLARE SECTION;

s_diff = 1;

EXEC SQL SELECT * FROM t1, t2
                 WHERE t1.i1 = t2.i1 + CAST( :s_diff AS INTEGER );
```

### 지시자 변수 

#### 개요

테이블의 칼럼값이 NULL인 경우 호스트 언어에서는 이와 같은 NULL을 표현할 수 없으므로 별도의 처리 방법이 필요하다.

C/C++ 전처리에서는 NULL값 처리를 위해 지시자 변수(Indicator Variables)를 지원한다.

지시자 변수란 NULL값 처리를 위해 내장 SQL문에서 호스트 변수와 함께 사용하는 변수이다.

#### 역할

-   지시자 변수는 대응되는 칼럼값이 널(NULL)인지 아닌지 판단하는 근거를 프로그래머에게 제공한다. 입력 지시자 변수값을 –1(SQL_NULL_DATA)로 지정하면 대응되는 호스트 변수값을 NULL로 처리한다.  
    출력 지시자 변수값이 –1(SQL_NULL_DATA)인 경우 대응되는 칼럼값이 NULL이 반환되었음을 의미한다.  
    예를 들어, INSERT문의 특정 호스트 변수값을 NULL로 지정한다든지, SELECT한 칼럼값이 NULL인지 아닌지 판단하기 위해 지시자 변수를 사용한다.
    
-   입력값의 길이를 지정하거나 반환된 칼럼값의 길이가 저장된다.  
    호스트 변수의 데이터 타입이 타입이거나 이진 타입일 경우에만 해당된다.  
    입력 지시자 변수에는 입력값의 길이를 지정해준다.  
    출력 지시자 변수에는 반환되는 칼럼값의 길이가 저장된다.  
    호스트 변수가 타입이고 널문자(‘\\0’)로 끝나는 경우, 입력값 또는 반환되는 칼럼값이 NULL이 아니라면 지시자 변수는 지정하지 않아도 무방하다.  
    호스트 변수가 이진 타입일 경우, 반드시 지시자 변수를 지정하여야 한다.(입력값 또는 반환되는 칼럼값이 NULL이 아닌 경우에도) 이유는 이진 타입의 경우 널문자로 끝나지 않을 수 있기 때문에 데이터베이스 서버에서 입력값의 길이를 알 수 있는 방법이 필요하고, 사용자는 반환되는 칼럼의 길이를 알 수 있는 방법이 필요하다. 따라서 이 경우 반드시 지시자 변수를 지정하여야 한다. 이진 타입에 대한 자세한 설명은 5장을 참조하기 바란다.

#### 선언

지시자 변수의 선언 방법은 다음과 같다.

-   호스트 변수 선언부 또는 함수 인자 선언부에서 선언한다. 만약 호스트 변수 선언부 또는 함수 인자 선언부에서 선언하지 않은 변수를 지시자 변수로 사용할 경우 전처리 시 “The host variable [variable_name] is unknown.” 오류가 발생한다. 호스트 변수 선언부 또는 함수 인자 선언부에 대한 자세한 설명은 3장을 참조하기 바란다.
-   변수 선언 구문은 다음과 같다.  
    datatype indicator_variable_name;  
    datatype은 int 또는 SQLLEN 타입이어야 한다. 또는 int 및 SQLLEN 타입들로만 구성된 구조체 타입도 가능하다.
    
-   지시자 변수명은 알파벳(a\~z, A\~Z), 밑줄("_") 또는 달러 기호("\$")로 시작하여야 하며, 그 길이는 50 bytes로 제한된다.

#### 사용

내장 SQL문에서 지시자 변수 사용 구문은 다음과 같다.

```
<:host_variable> [INDICATOR] <:indicator_variable>
```

여기에서 “INDICATOR” 키워드는 생략 가능하다.

호스트 변수가 구조체가 아니면 지시자 변수도 구조체가 아니어야 하고 호스트 변수가 구조체이면 지시자 변수도 구조체이어야 한다.

#### 지시자 변수를 반드시 지정해야 하는 경우

다음 경우는 반드시 지시자 변수를 지정하여야 한다.

-   입력값을 NULL로 지정할 경우.  
    지시자 변수에 –1(SQL_NULL_DATA)을 지정한다.

-   출력 호스트 변수에 대응되는 칼럼이 NOT NULL 칼럼이 아닌 경우.  
    지시자 변수를 지정하지 않았는데 SELECT 또는 FETCH 한 칼럼값이 NULL인 경우, 내장 SQL문의 수행 결과(sqlca.sqlcode)는 SQL_SUCCESS_WITH_INFO가 된다.
    
-   APRE_BINARY, APRE_BINARY2, APRE_BLOB, APRE_BYTES 타입을 입출력 호스트 변수로
    사용하는 경우.  
    이진 타입의 경우 데이터가 널문자로 끝나지 않을 수 있기 때문에 데이터베이스 서버에 입력값의 길이를 알려줄 방법이 필요하다. 따라서 지시자 변수에 입력값의 길이를 지정해준다. 마찬가지로 출력 호스트 변수로 사용할 경우 데이터베이스 서버는 반환되는 칼럼값의 길이를 지시자 변수에 저장한다. APRE_BINARY 타입과 APRE_BINARY2, APRE_BLOB , APRE_BYTES, APRE_VARBYTES 타입에 대한 자세한 설명은 5장을 참조하기 바란다.
    
-   APRE_NIBBLE 타입을 출력 호스트 변수로 사용하는 경우.  
    NIBBLE 타입 컬럽에 NULL값을 입력하거나, NIBBLE 타입 칼럼으로부터 NULL값을 받아 올 경우 지시자 변수가 필요하다. APRE_NIBBLE 타입에 대한 자세한 설명은 5장을 참조하기 바란다.

#### 제한 사항

-   호스트 변수가 구조체이면 지시자 변수도 구조체이어야 한다. 이 때, 두 구조체의 구성 요소 개수도 같아야 한다.

```
예) EXEC SQL BEGIN DECLARE SECTION;
struct tag1 { int i1; int i2; } var1;
struct tag2 { int i1_ind; int i2_ind; } var1_ind1;
struct tag3 { int i1_ind; int i2_ind; 
int i3_ind; } var1_ind2; 
EXEC SQL END DECLARE SECTION;

EXEC SQL INSERT INTO T1(I1, I2) 
VALUES (:var1 :var1_ind1);	(O)
EXEC SQL INSERT INTO T1(I1, I2) 
VALUES (:var1 :var1_ind2);	(X)
```

-   호스트 변수가 구조체의 배열인 경우 지시자 변수는 지정할 수 없다.

```
예) EXEC SQL BEGIN DECLARE SECTION;
struct tag1 { int i1; int i2; char i3[11]; } var1[10];
struct tag2 { int i1_ind; int i2_ind; int i3_ind; } var1_ind1[10];
EXEC SQL END DECLARE SECTION;

EXEC SQL INSERT INTO T1(I1, I2, I3) 
VALUES (:var1 :var1_ind1);	(X)
```

-   호스트 변수가 varchar 타입인 경우, 지시자 변수를 지정하면 지정한 변수를 지시자 변수로 사용하고, 지정하지 않으면 varchar 타입의 구성 요소인 len 변수가 자동으로 지시자 변수가 된다. 따라서 이 경우, len 변수를 지시자 변수처럼 사용하면 된다.

```
예) EXEC SQL BEGIN DECLARE SECTION;
varchar var1;
int var1_ind;
EXEC SQL END DECLARE SECTION;

/* T1테이블의 I1칼럼에 ‘TEST’ 삽입, 
var1.len이 지시자 변수로 사용된 경우 */
strcpy(var1.arr, “TEST”);
var1.len = strlen(var1.arr);
EXEC SQL INSERT INTO T1(I1) 
VALUES (:var1);

/* T1테이블의 I1칼럼에 NULL 삽입,
var1.len이 지시자 변수로 사용된 경우 */
var1.len = -1;
EXEC SQL INSERT INTO T1(I1) 
VALUES (:var1);

/* T1테이블의 I1칼럼에 ‘TEST’ 삽입,
var1_ind를 지시자 변수로 사용한 경우 */
strcpy(var1.arr, “TEST”);
var1_ind = strlen(var1.arr);
EXEC SQL INSERT INTO T1(I1) 
VALUES (:var1 :var1_ind);	
```

#### 예제

다음은 s_goods_location의 지시자 변수로 s_goods_location_ind를, s_price의 지시자 변수로 s_price_ind를 사용하는 예를 보여준다. 두 지시자 변수값 모두 SQL_NULL_DATA를 지정하였으므로 대응되는 칼럼 값에는 NULL이 삽입된다.

\< 예제 프로그램 : indicator.sc \>

```
/* declare host variables */
EXEC SQL BEGIN DECLARE SECTION;
char    s_gno[10+1];
char    s_gname[20+1];
char    s_goods_location[9+1];
int     s_stock;
double  s_price;

/* declare indicator variables */
int      s_goods_location_ind;
int      s_price_ind;
EXEC SQL END DECLARE SECTION;

/* set host variables */
strcpy(s_gno, "X111100002");
strcpy(s_gname, "XX-101");
strcpy(s_goods_location, "FD0003");
s_stock = 5000;
s_price = 9980.21;

/* set indicator variables */
s_goods_location_ind = SQL_NULL_DATA;
s_price_ind          = SQL_NULL_DATA;

EXEC SQL INSERT INTO GOODS 
VALUES (:s_gno, 
:s_gname,
:s_goods_location :s_goods_location_ind,
:s_stock,
:s_price :s_price_ind);
```

### 지시자 변수 분류

지시자 변수는 출력 호스트 변수와 함께 사용되는지, 입력 호스트 변수와 함께 사용되는지에 따라 출력 지시자 변수 또는 입력 지시자 변수로 구분된다.

#### 출력 지시자 변수 

출력 호스트 변수에 대응되는 칼럼이 NOT NULL 칼럼이 아니라면 반드시 지시자 변수와 함께 사용하여야 한다. 이유는 SELECT 또는 FETCH 한 칼럼값이 NULL인 경우 지시자 변수를 지정하지 않으면 내장 SQL문의 수행 결과(sqlca.sqlcode)는 SQL_SUCCESS가 아니라 SQL_SUCCESS_WITH_INFO가 되기 때문이다.

지시자 변수값이 –1 (SQL_NULL_DATA)이라면 대응되는 칼럼값이 NULL이 반환됨을 의미한다. 따라서 이 때 출력 호스트 변수값은 무의미(garbage value)하다. 지시자 변수값이 –1 (SQL_NULL_DATA)이 아니라면 대응되는 칼럼값은 NULL이 아니며 출력 호스트 변수에는 대응되는 칼럼값이 저장된다. 이 경우의 지시자 변수값에 대해서는 다음 절의 “지시자 변수값의 의미” 에서 자세히 다루도록 하겠다.

##### 예제

다음은 출력 지시자 변수의 사용 예를 보여준다.

여기에서는 s_goods의 지시자 변수로 s_good_ind를 사용하였다. s_goods가 구조체이므로 s_good_ind도 구조체로 선언되었으며 두 구조체의 구성 요소 개수는 같다. SELECT문 수행 후 s_good_ind의 구성 요소 각각을 –1 인지 검사한다.

\< 예제 프로그램 : hostvar.h \>

```
EXEC SQL BEGIN DECLARE SECTION;
typedef struct goods
{
    char   gno[10+1];
    char   gname[20+1];
    char   goods_location[9+1];
    int    stock;
    double price;
} goods;

typedef struct good_ind
{
    int gno;
    int gname;
    int goods_location;
    int stock;
    int price;
} good_ind;
EXEC SQL END DECLARE SECTION;
```

\< 예제 프로그램 : indicator.sc \>

```
/* specify path of header file */
EXEC SQL OPTION (INCLUDE=./include);
/* include header file for precompile */
EXEC SQL INCLUDE hostvar.h;

EXEC SQL BEGIN DECLARE SECTION;
goods     s_goods;
good_ind s_good_ind;
EXEC SQL END DECLARE SECTION;

EXEC SQL SELECT * 
INTO :s_goods :s_good_ind 
FROM GOODS 
WHERE GNO = :s_gno;

/* GNO, GNAME은 NOT NULL 칼럼이므로 지시자 변수값 검사 생략 */ 
if (sqlca.sqlcode == SQL_SUCCESS) 
{
        if (s_good_ind.goods_location == SQL_NULL_DATA)
        {
            strcpy(s_goods.goods_location, "NULL");
        }
        if (s_good_ind.stock == SQL_NULL_DATA)
        {
            s_goods.stock = -1;
        }
        if (s_good_ind.price == SQL_NULL_DATA)
        {
            s_goods.price = -1;
        }
}
```

#### 입력 지시자 변수 

입력값으로 NULL을 지정하기 위해서 입력 지시자 변수를 사용한다. 이 때 대응되는 지시자 변수값을 –1 (SQL_NULL_DATA)로 지정한다.

입력값이 NULL이 아닌 경우 지시자 변수는 지정하지 않아도 무방하나 지정할 경우 주의해서 사용하여야 한다. 입력 호스트 변수 타입에 따라 지시자 변수값의 의미가 달라지는데 자세한 내용은 다음 절 “지시자 변수값의 의미” 를 참조하기 바란다.

##### 예제

다음은 입력 지시자 변수의 사용 예를 보여준다.

여기에서는 s_goods_location의 지시자 변수로 s_goods_location_ind, s_price의 지시자 변수로 s_price_ind를 사용하였다. s_goods_location_ind와 s_price_ind에 SQL_NULL_DATA(-1)를 지정함으로써 GOODS_LOCATION, PRICE 칼럼에 각각 NULL을 삽입한다.

\< 예제 프로그램 : indicator.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
/* declare host variables */
char    s_gno[10+1];
char    s_gname[20+1];
char    s_goods_location[9+1];
int     s_stock;
double  s_price;

/* declare indicator variables */
int      s_goods_location_ind;
int      s_price_ind;
EXEC SQL END DECLARE SECTION;

/* set host variables */
strcpy(s_gno, "X111100002");
strcpy(s_gname, "XX-101");
strcpy(s_goods_location, "FD0003");
s_stock = 5000;
s_price = 9980.21;

/* set indicator variables */
s_goods_location_ind = SQL_NULL_DATA;
s_price_ind            = SQL_NULL_DATA;

EXEC SQL INSERT INTO GOODS 
VALUES (:s_gno, 
                   :s_gname, 
                   :s_goods_location :s_goods_location_ind, 
                   :s_stock, 
:s_price :s_price_ind);
```

### 지시자 변수값의 의미

다음 표는 지시자 변수 종류, 지시자 변수값, 호스트 변수 타입에 따른 지시자 변수값의 의미를 설명한다.

지시자 변수값이 –1이면 조건에 상관없이 항상 NULL을 의미하지만 –1이 아닐 경우 지시자 변수 종류, 호스트 변수 타입 등의 조건에 따라 지시자 변수값의 의미가 달라지므로 다음 표를 잘 이해하여 지시자 변수 사용에 참고하도록 한다.

특히, 입력 지시자 변수의 경우 프로그램 작성자가 값을 지정하고 지정한 값을 전처리기 또는 데이터베이스 서버가 내부적으로 사용하므로 정확한 값 지정을 하여야 한다.

<table>
    <tr>
    	<th>지시자
변수 종류
</th>
		<th colspan="2">입력 지시자 변수</th>
		<th colspan="2">출력 지시자 변수</th>	
    </tr>
    <tr>
    	<td><img src="media/Precompiler/diagonal.png" width="150px" height="100px"/></td>
    	<td>-1</td>
    	<td>-1 이외의 값</td>
    	<td>-1</td>
    	<td>-1 이외의 값</td>
    </tr>
    <tr>
    	<td>숫자형 타입</td>
    	<td rowspan="8">입력값이 NULL임을 의미함.</td>
    	<td>내부적으로 참조하지 않음. 의미 없음</td>
    	<td rowspan="8">반환된 값이 NULL임을 의미함.
실제 호스트 변수값은 의미가 없음.
(garbage value)
</td>
		<td>호스트 변수의 크기(sizeof)가 저장되어 있음.</td>
    </tr>
    <tr>
    	<td>문자형 타입</td>
    	<td>입력값의 길이(strlen)를 지정해야 함.</td>
    	<td>반환된 값의 길이(strlen)가 저장되어 있음.</td>   	
    </tr>
    <tr>
    	<td>날짜형 타입</td>
    	<td>내부적으로 참조하지 않음. 의미 없음.</td>
    	<td>호스트 변수의 크기(sizeof)가 저장되어 있음.</td>
    </tr>
    <tr>
    	<td>APRE_BINARY</td>
    	<td>입력값의 길이(bytes)를 지정해야 함.</td>
    	<td>반환된 값의 길이(bytes)가 저장되어 있음.</td>
    </tr>
    <tr>
    	<td>APRE_BINARY2</td>
    	<td>입력값의 길이(bytes)를 지정해야 함.</td>
    	<td>반환된 값의 길이(bytes)가 저장되어 있음.</td>
    </tr>
    <tr>
    	<td>APRE_BLOB</td>
    	<td>입력값의 길이(bytes)를 지정해야 함</td>
    	<td>반환된 값의 길이(bytes)가 저장되어 있음.</td>
    </tr>
    <tr>
    	<td>APRE_CLOB</td>
    	<td>입력값의 길이(bytes)를 지정해야 함</td>
    	<td>반환된 값의 길이(bytes)가 저장되어 있음.</td>
    </tr>
    <tr>
    	<td>APRE_BYTES</td>
    	<td>입력값의 길이(bytes)를 지정해야 함.</td>
    	<td>반환된 값의 길이(bytes)가 저장되어 있음.</td>
    </tr>
    <tr>
    	<td>APRE_NIBBLE</td>
    	<td>내부적으로 참조하지 않음. 의미 없음.</td>
    	<td>반환된 값의 길이(bytes)가 저장되어 있음.</td>
    </tr>
<table>

일반적으로 지시자 변수는 NULL 처리를 위해 사용하지만, 위 표에서 보는 바와 같이 입력 지시자 변수에서 그 값이 –1이 아니어도 내부적으로 참조해서 사용하는 경우가 있다. 따라서 입력 지시자 변수를 사용할 경우 NULL이 아닌 경우도 그 값을 정확히 지정해야 한다.

입력 지시자 변수값이 –1이 아닌 경우, 호스트 변수 타입이 이나 이진 타입이면 데이터베이스 서버에서는 지시자 변수값을 입력값의 길이로 인식하고 그 길이만큼 입력값으로 처리한다.

### 예제 프로그램

##### indicator.sc 

$ALTIBASE_HOME/sample/APRE/indicator.sc 참고

##### 실행결과

```
$ is –f schema/schema.sql
$ make indicator
$ ./indicator
<INDICATOR VARIABLES>
-----------------------------------------------------------
[Scalar Indicator Variables]                                      
-----------------------------------------------------------
Success insert

-----------------------------------------------------------
[Structure Indicator Variables]                                   
-----------------------------------------------------------
GNO        GNAME                GOODS_LOCATION  STOCK  PRICE      
-----------------------------------------------------------
X111100002 XX-101               NULL            5000   -1.00

-----------------------------------------------------------
 [Scalar Array Indicator Variables]                                
-----------------------------------------------------------
3 rows updated
3 times update success

-----------------------------------------------------------
 [Arrays In Structure]                                             
-----------------------------------------------------------
3 rows inserted
3 times inserte success

-----------------------------------------------------------
 [Indicator Variable(.len) of VARCHAR With Output Host Variables]  
-----------------------------------------------------------
v_address.arr = [Pusan University]
v_address.len = 16

-----------------------------------------------------------
 [Indicator Variable(.len) of VARCHAR With Input Host Variables]   
-----------------------------------------------------------
Success update

-----------------------------------------------------------
 [Indicator Variable of DATE Type With Input Host Variables]       
-----------------------------------------------------------
Success update

-----------------------------------------------------------
 [Indicator Variable of DATE Type With Output Host Variables]      
-----------------------------------------------------------
d_arrival_date2 = NULL
```

