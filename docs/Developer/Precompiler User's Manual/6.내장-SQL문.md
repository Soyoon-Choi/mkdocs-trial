# 6.내장 SQL문

### 개요

내장 SQL문은 응용 프로그램 내에 포함되어 있는 SQL문을 말한다.

#### 구문

```
EXEC SQL … ;
```

내장 SQL문은 “EXEC SQL”문장으로 시작해서 “;”으로 끝난다.

“EXEC SQL”과 “;”사이에 SELECT, UPDATE 등의 DML문, CREATE, DROP 등의 DDL문 등 다양한 SQL문을 사용할 수 있다.

##### 제한 사항

SQL문 길이는 최대 32Kbytes까지 허용한다.

##### 예제

다음은 내장 SQL문의 사용 예를 보여준다.

< SELECT문 : select.sc >

```
EXEC SQL BEGIN DECLARE SECTION;
short      s_dno;
char       s_dname[30+1];
char       s_dep_location[9+1];
EXEC SQL END DECLARE SECTION;

EXEC SQL SELECT DNAME, DEP_LOCATION 
INTO :s_dname, :s_dep_location
           FROM DEPARTMENTS 
WHERE DNO = :s_dno;
```

< INSERT문 : insert.sc >

```
EXEC SQL BEGIN DECLARE SECTION;
char    s_gno[10+1];
char    s_gname[20+1];
char    s_goods_location[9+1];
int     s_stock;
double  s_price;
EXEC SQL END DECLARE SECTION;

EXEC SQL INSERT INTO GOODS 
VALUES (:s_gno, :s_gname, 
:s_goods_location, 
:s_stock, :s_price);
```

각 내장 SQL문에 대한 구문은 뒤에서 더 자세히 다루도록 한다.

#### 내장 SQL문 분류

내장 SQL문은 크게 두 가지로 분류된다. 수행할 SQL문이 프로그램 작성 시 결정되느냐, 실행 시간에 결정되느냐에 따라 정적 SQL문과 동적 SQL문으로 나눌 수 있다. 본 장에서는 정적 SQL문에 대해서만 언급하기로 한다. 동적 SQL문에 대한 자세한 설명은 10장을 참조하기 바란다.

내장 SQL문은 데이터 처리 방식과 역할에 따라 다음과 같이 분류할 수 있다.

##### 호스트 변수 선언부 

내장 SQL문에서 사용할 호스트 변수를 선언한다. 자세한 내용은 3장을 참조하기 바란다.

##### 함수 인자 선언부 

호스트 변수로 사용할 함수 인자를 선언한다. 자세한 내용은 3장을 참조하기 바란다.

##### 연결 관련 SQL문

데이터베이스에 연결, 연결 해제와 관련된 SQL문을 말한다.

##### 기본 내장 SQL문

SELECT, UPDATE, INSERT, DELETE 등의 DML문과 CREATE, DROP, ALTER 등의 DDL문이 포함된다.

##### 커서 처리 SQL문

커서를 이용한 데이터 처리 SQL문을 말한다. 커서 정의, 커서 열기, 커서 이용하여 데이터 가져오기, 커서 닫기 등의 SQL문이 여기에 포함된다. 자세한 내용은 8장을 참조하기 바란다.

##### SQL/PSM 처리 SQL문

저장 프로시저와 저장 함수 관련 SQL문을 말한다. 저장 프로시저/함수의 생성, 재컴파일, 실행, 삭제 등의 SQL문이 여기에 포함된다. 자세한 내용은 11장을 참조하기 바란다.

##### 기타 내장 SQL문

위의 경우를 제외한 모든 Altibase SQL문을 말한다. 작업 제어문, 시스템 제어문, 트랜잭션 처리문 등이 여기에 포함된다.

##### OPTION문

C/C++전처리기가 제공하는 다양한 옵션 설정에 관련된 내장 SQL문을 말한다.

### 연결 관련 SQL문

연결 관련 SQL문은 데이터베이스 서버와의 연결에 관련된 SQL문을 말한다. CONNECT문과 DISCONNECT문이 여기에 속한다.

#### CONNECT

데이터베이스 서버에 연결한다.

##### 구문

```
EXEC SQL CONNECT <:user> IDENTIFIED BY <:passwd>
[ USING <:conn_opt1> [ , <:conn_opt2> ] ];
```

##### 인자

-   \<:*user*\>: 데이터베이스 서버에 연결할 사용자 이름

-   \<:*passwd*\>: 데이터베이스 서버에 연결할 사용자 암호

-   \<:*conn_opt1*\>: 데이터베이스 서버와의 연결 방식을 지정

    -   DSN: 연결할 데이터베이스 서버의 IP주소

    -   Server: DSN과 같은 의미로, DSN 대신 Server를 사용할 수 있다. 

    -   CONNTYPE: 데이터베이스 서버와의 통신 방법

        -   1: TCP/IP

        -   2: UNIX DOMAIN

        -   3: IPC

    -   PORT_NO: 데이터베이스 서버에 연결할 연결 포트 번호

    -   NLS_USE: 사용 언어 지정

        -   KO16KSC5601: 한국어

        -   US7ASCII: 영어

        -   MS949

        -   BIG5

        -   GB231280

        -   MS936

        -   UTF8

        -   SHIFTJIS

        -   MS932

        -   EUCJP

    -   BATCH: 연결할 세션의 Batch Processing Mode 지정

        -   ON: Batch Processing Mode

        -   OFF: Non Batch Processing Mode

-   \<:*conn_opt2*\>: 연결 방식을 지정하는 방법은 *conn_opt1*과 동일하다. *conn_opt1*을 이용한 데이터베이스 서버와의 연결 실패 시 자동으로 *conn_opt2*를 이용하여 데이터베이스 서버와의 연결을 시도한다.

##### 설명

내장 SQL문 한 프로그램 내에서 하나 이상의 연결을 허용한다. 한 프로그램 내에서 여러 개의 연결을 할 경우, 연결 이름을 가지지 않는 연결은 하나만 허용하는데, 여기에서는 이 연결(연결 이름을 가지지 않는 경우)에 관해서만 다루기로 한다.

한 애플리케이션 내에서 두 개 이상의 연결을 이용하는 다중 연결 프로그램이나 멀티쓰레드 프로그램 방법에 대한 자세한 설명은 12장과 13장을 참조하기 바란다.

> \* 주의: 만일 연결 스트링에 PORT_NO와 NLS_USE 값을 명시하지 않은 경우 프로퍼티 파일에 설정된 값과 동일한 값으로 다음 환경변수를 이용하여 반드시 설정해야 한다.

```
export ALTIBASE_PORT_NO=20300
export ALTIBASE_NLS_USE=US7ASCII 
```

##### 연결 옵션 2개 지정하는 경우 수행 결과

**SQL_SUCCESS**: 처음 옵션으로 연결 성공한 경우.

**SQL_SUCCESS_WITH_INFO**: 처음 옵션으로 연결 실패하고, 두 번째 옵션으로 연결 성공하는 경우. 처음 연결 실패 에러 메시지는 sqlca.sqlerrm.sqlerrmc에 저장된다.

**SQL_ERROR**: 처음 옵션으로 연결 실패하고, 두 번째 옵션으로도 연결 실패하는 경우. 두 번의 연결 실패에 대한 에러 메시지는 sqlca.sqlerrm.sqlerrmc에 연속하여 저장된다.

> ##### 주의 사항
>
> CONNECT 후 다시 CONNECT를 수행한다면 “Already connected” 오류가 발생한다. 따라서 CONNECT 후 다시 CONNECT를 수행하려면 먼저 FREE 또는 DISCONNECT를 수행하여야 한다. 이 때, 데이터베이스 서버가 running 상태라면 DISCONNECT를, running 상태가 아니라면 FREE를 수행하여야 한다.
> 
> USING절을 이용하여 연결 방식을 지정할 경우, CONNTYPE을 2 또는 3으로 지정한다면 DSN 또는 PORT_NO를 함께 지정하더라도 DSN, PORT_NO 옵션은 무시되고 로컬 데이터베이스 서버로 연결을 시도한다.

##### 예제

데이터베이스 서버에 연결하는 다양한 예를 보여준다.

[예제 1] 다음은 사용자 이름과 사용자 암호를 이용하여 데이터베이스 서버에 연결하는 예를 보여준다. 이 경우, 다른 필요한 연결 정보는 환경 변수로부터 읽을 것이다.

\< 예제 프로그램: connect1.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
char usr[10];
char pwd[10];
EXEC SQL END DECLARE SECTION;

strcpy(usr, "SYS");
strcpy(pwd, "MANAGER"); 

EXEC SQL CONNECT :usr IDENTIFIED BY :pwd; 
```

[예제 2] 다음은 USING절에 연결 방식을 지정하여 데이터베이스 서버에 연결하는 예를 보여준다. usr과 pwd에 저장된 사용자 이름과 사용자 암호, conn_opt3에 저장된 연결 정보를 이용하여 데이터베이스 서버에 연결한다. 이 때 conn_opt3에 지정하지 않은 연결 정보는 환경 변수로부터 읽을 것이다.

\< 예제 프로그램: connect1.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
char usr[10];
char pwd[10];
char conn_opt3[100];
EXEC SQL END DECLARE SECTION;

strcpy(usr, "SYS");
strcpy(pwd, "MANAGER"); 
strcpy(conn_opt3, "DSN=192.168.11.12;CONNTYPE=1;PORT_NO=53000"); 

EXEC SQL CONNECT :usr IDENTIFIED BY :pwd USING :conn_opt3;  
```

[예제 3] 다음은 USING절에 연결 방식을 2개 지정하여 데이터베이스 서버에 연결하는 예를 보여준다. 먼저 usr과 pwd에 저장된 사용자 이름과 사용자 암호, conn_opt1에 저장된 연결 정보를 이용하여 데이터베이스 서버에 연결을 시도하고, 실패할 경우 같은 사용자 이름과 사용자 암호, conn_opt2에 저장된 연결 정보를 이용하여 데이터베이스 서버에 연결한다.

\< 예제 프로그램: connect2.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
char usr[10];
char pwd[10];
char conn_opt1[100];
char conn_opt2[100];
EXEC SQL END DECLARE SECTION;

strcpy(usr, "SYS");
strcpy(pwd, "MANAGER"); 
strcpy(conn_opt1, "DSN=192.168.11.12;CONNTYPE=1;PORT_NO=53000"); 
strcpy(conn_opt2, "DSN=192.168.11.22;CONNTYPE=1;PORT_NO=53000");

EXEC SQL CONNECT :usr IDENTIFIED BY :pwd USING :conn_opt1, :conn_opt2;  
if (sqlca.sqlcode == SQL_SUCCESS) /* check sqlca.sqlcode */
{
    printf("Success connection to altibase server with first option\n\n");
}
else if (sqlca.sqlcode == SQL_SUCCESS_WITH_INFO)
{
    /* fail connection with first option and then success connection with second option */
    printf("Success connection to altibase server with second option\n");
    printf("First connection error : [%d] %s\n\n", SQLCODE, sqlca.sqlerrm.sqlerrmc);
}
else
{
    printf("Fail connection to altibase server both first option and second option\n");
    printf("Error : [%d]\n", SQLCODE);
    printf("%s\n\n", sqlca.sqlerrm.sqlerrmc);
    exit(1);
}
```

#### DISCONNECT

데이터베이스 서버와의 연결을 해제한다.

##### 구문

```
EXEC SQL DISCONNECT;
```

##### 인자

없음

##### 설명

데이터베이스 서버와의 연결을 해제하고, 연결에 할당된 자원을 모두 해제한다.

##### 예제

다음 예제는 DISCONNECT문의 사용 예를 보여준다.

\< 예제 프로그램: connect1.sc \>

```
EXEC SQL DISCONNECT;
```

#### 예제 프로그램

##### connect1.sc 

$ALTIBASE_HOME/sample/APRE/connect1.sc 참고

##### 실행결과

```
$ is –f schema/schema.sql
$ make connect1
$ connect1
<CONNECT 1>
------------------------------------------------------
[Connect]
------------------------------------------------------
Success connection to altibase server

------------------------------------------------------
[Disconnect]
------------------------------------------------------
Success disconnection from altibase server
```

##### connect2.sc 

$ALTIBASE_HOME/sample/APRE/connect2.sc 참고

##### 실행결과

```
$ is –f schema/schema.sql
$ make connect2
$ connect2
<CONNECT 2>
------------------------------------------------------
[Connect With Two ConnOpt]
------------------------------------------------------
Fail connection to altibase server both first option and second option
Error : [-327730]
Failed first connection : Client unable to establish connection
Failed second connection : Client unable to establish connection
```

### 기본 내장 SQL문

기본 내장 SQL문에는 SELECT, UPDATE, INSERT, DELETE 등의 DML문과 CREATE, DROP, ALTER 등의 DDL문이 있다.

#### SELECT

데이터베이스에서 조건에 맞는 레코드를 검색하여 호스트 변수에 저장한다. 기본적인 구문은 Altibase SQL의 SELECT문과 동일하나, 호스트 변수를 사용하기 위해 추가적으로 INTO절이 필요하다.

##### 구문

```
EXEC SQL SELECT [ ALL | DISTINCT ] <target_list>
INTO <host_var_list> 
FROM <table_expression> [ WHERE … ]; 
```

##### 인자

-   \<target_list\> : *SQL Reference*참조

-   \<*host_var_list*\> : 출력 호스트 변수와 출력 지시자 변수 리스트

-   \<table_expression\> : *SQL Reference*참조

##### 설명

호스트 변수가 배열이 아니라면 반환되는 레코드는 한 건이어야 한다. 한 건 이상이 반환될 경우 “Too many rows returned.” 오류가 발생한다. 이 경우 CURSOR문을 이용해야 한다.

호스트 변수가 배열이라면 반환되는 레코드 개수는 배열 크기보다 작거나 같아야 한다. 배열 크기보다 많은 건수가 반환될 경우 “Too many rows returned.” 오류가 발생한다. 이 경우 배열 크기를 크게 하던지 CURSOR문을 이용하여야 한다.

##### 수행 결과

<table>
	<tr>
		<th colspan="2">호스트 변수가 배열이 아닌 경우</th>
		<th colspan="2">호스트 변수가 배열인 경우</th>	
	</tr>
	<tr>
		<td>반환된 레코드 개수</td>
		<td>수행 결과</td>
		<td>반환된 레코드 개수</td>
		<td>수행 결과</td>
	</tr>
	<tr>
		<td>0</td>
		<td>SQL_NO_DATA</td>
		<td>0</td>
		<td>SQL_NO_DATA</td>
	</tr>
	<tr>
		<td rowspan="2">1</td>
		<td rowspan="2">SQL_SUCCESS</td>
		<td>배열 크기보다 작은 경우</td>
		<td>SQL_SUCCESS</td>
	</tr>
	<tr>
		<td>배열 크기와 같은 경우</td>
		<td>SQL_SUCCESS</td>
	</tr>
	<tr>
		<td>1보다 큰 경우</td>
		<td>SQL_ERROR</td>
		<td>배열 크기보다 큰 경우</td>
		<td>SQL_ERROR</td>
	</tr>
</table>

수행 결과가 SQL_NO_DATA의 경우 반환된 레코드 개수는 0개이므로 이 때의 호스트 변수 값은 무의미(garbage value)하다.

##### 제한 사항

-   입력 호스트 변수는 배열일 수 없다.

```
예) EXEC SQL BEGIN DECLARE SECTION;
int var1;
int var2[10];
int var3[10];
EXEC SQL END DECLARE SECTION;

EXEC SQL SELECT * INTO :var1 
FROM T1 WHERE i1 = :var3;	(X)
          또는
EXEC SQL SELECT * INTO :var2 
FROM T1 WHERE i1 = :var3;	(X)
```

-   GROUP BY 절에 CAST 연산자를 사용해서 호스트 변수의 타입을 명시한 표현식이 존재하는 경우 해당 표현식을 TARGET 절에서 사용할 수 없다.

```
예) 
prepare select trunc(QTY - cast(:jstm as integer)) / cast(:unit as integer) from orders;		(O)

prepare SELECT trunc(QTY - cast(:jstm as integer)) from orders GROUP BY trunc(QTY - cast(:jstm as integer));	(X)
```

-   INTO절의 호스트 변수가 구조체의 배열이라면 출력 호스트 변수는 하나만 사용할 수 있다. 자세한 설명은 5장 “호스트 변수 데이터 타입”을 참조한다.
    
-   INTO절의 호스트 변수가 varchar 타입의 배열일 때, 다른 출력 호스트 변수와 함께 사용할 수 없다. 자세한 설명은 5장 “호스트 변수 데이터 타입”을 참조한다.
    
-   SELECT 문의 LIMIT 절에는 입력 호스트 변수만 사용 가능하고, 입력 지시자 변수는 사용할 수 없다. 또한, 입력 호스트 변수의 데이터 타입은 int만 지원한다.

##### 예제

다양한 SELECT 문의 사용 예를 보여준다.

[예제 1] 다음은 DNO가 s_dno의 값을 가지는 레코드를 검색하여 DNAME, DEP_LOCATION 칼럼 값을 각각 s_dname, s_dep_location 호스트 변수에 저장하는 예를 보여준다.

\< 예제 프로그램 : select.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
short s_dno;
char  s_dname[30+1];
char  s_dep_location[9+1];
EXEC SQL END DECLARE SECTION;

s_dno = 1001;
EXEC SQL SELECT DNAME, DEP_LOCATION 
INTO :s_dname, :s_dep_location
FROM DEPARTMENTS 
WHERE DNO = :s_dno;
```

[예제 2] 다음은 구조체 타입의 호스트 변수를 사용하는 경우로, DNO가 s_dno의 값을 가지는 레코드를 검색하여 모든 칼럼값을 각각 대응되는 s_department의 구성 요소에 저장하는 예를 보여준다.

\< 예제 프로그램 : hostvar.h \>

```
EXEC SQL BEGIN DECLARE SECTION;
typedef struct department
{
    short dno; 
    char  dname[30+1];
    char  dep_location[9+1];
    int   mgr_no;
} department;
EXEC SQL END DECLARE SECTION;
```

< 예제 프로그램 : select.sc >

```
/* specify path of header file */
EXEC SQL OPTION (INCLUDE=./include);
/* include header file for precompile */
EXEC SQL INCLUDE hostvar.h;

EXEC SQL BEGIN DECLARE SECTION;
short s_dno;
department s_department;
EXEC SQL END DECLARE SECTION;

s_dno = 1002;
EXEC SQL SELECT * 
INTO :s_department
FROM DEPARTMENTS 
WHERE DNO = :s_dno;
```

[예제 3] 다음은 T_LOB 테이블을 검색하여, INTEGER 칼럼을 sI1 호스트 변수에, CLOB 칼럼을 APRE_FILE_CREATE 옵션으로 생성한 sI2FName의 파일에 저장하는 예를 보여준다.

\<예제 프로그램 : clobSample.sc\>

```
EXEC SQL BEGIN DECLARE SECTION;
int          sI1;
char         sI2FName[33];
unsigned int sI2FOpt;
SQLLEN       sI2Ind;
EXEC SQL END DECLARE SECTION;

strcpy(sI2FName, aOutFileName);
sI2FOpt = APRE_FILE_CREATE;
 
EXEC SQL SELECT * INTO :sI1, CLOB_FILE :sI2FName OPTION :sI2FOpt INDICATOR :sI2Ind FROM T_LOB;
```

> \* BLOB, CLOB 타입의 칼럼의 데이터를 조회하여 파일로 저장하는 예제는 부록 A를 참조하기 바란다.

#### INSERT

테이블에 새로운 레코드를 삽입한다.

##### 구문

```
SQL Reference 참조
```

##### 인자

없음

##### 설명

VALUES절에 호스트 변수와 지시자 변수를 사용할 수 있다.

##### 예제

다양한 INSERT문의 사용 예를 보여준다.

[예제 1] 다음은 GOODS 테이블에 새로운 레코드를 삽입하는 예를 보여준다.

\< 예제 프로그램 : insert.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
char    s_gno[10+1];
char    s_gname[20+1];
char    s_goods_location[9+1];
int     s_stock;
double  s_price;
EXEC SQL END DECLARE SECTION;

strcpy(s_gno, "F111100002");
strcpy(s_gname, "XX-101");
strcpy(s_goods_location, "FD0003");
s_stock = 5000;
s_price = 9980.21;

EXEC SQL INSERT INTO GOODS 
VALUES (:s_gno, :s_gname, :s_goods_location, 
:s_stock, :s_price);
```

[예제 2] 다음은 구조체 타입의 호스트 변수를 사용하여 GOODS 테이블에 새로운 레코드를 삽입하는 예를 보여준다.

\< 예제 프로그램 : hostvar.h \>

```
EXEC SQL BEGIN DECLARE SECTION;
typedef struct goods
{
    char   gno[10+1];
    char   gname[20+1];
    char   goods_location[9+1];
    int    stock;
    double price;
} goods;
EXEC SQL END DECLARE SECTION;
```

\< 예제 프로그램 : insert.sc \>

```
/* specify path of header file */
EXEC SQL OPTION (INCLUDE=./include);
/* include header file for precompile */
EXEC SQL INCLUDE hostvar.h;

EXEC SQL BEGIN DECLARE SECTION;
goods   s_goods;
EXEC SQL END DECLARE SECTION;

strcpy(s_goods.gno, "F111100003");
strcpy(s_goods.gname, "XX-102");
strcpy(s_goods.goods_location, "AD0003");
s_goods.stock = 6000;
s_goods.price = 10200.96;

EXEC SQL INSERT INTO GOODS VALUES (:s_goods);
```

> \* 파일의 데이터를 읽어서 BLOB, CLOB 타입의 칼럼에 입력하는 예제는 부록 A를 참조하기 바란다.

#### UPDATE

조건을 만족하는 레코드를 찾아 명시한 칼럼들의 값을 변경한다.

##### 구문

```
SQL Reference 참조
```

##### 인자

없음

##### 설명

SET절과 WHERE절에 호스트 변수와 지시자 변수를 사용할 수 있다.

##### 제한 사항

-   배열 타입과 배열이 아닌 타입을 함께 사용할 수 없다. 예를 들어, SET절의
    호스트 변수가 배열 타입이라면 WHERE절의 호스트 변수도 배열 타입이어야 한다.

```
예) EXEC SQL BEGIN DECLARE SECTION;
int var1[10]; 
int var2[10];
int var3;
EXEC SQL END DECLARE SECTION;

EXEC SQL UPDATE T1 
SET I1 = :var1, I2 = :var2 
WHERE I1 = :var3;       	    (X)
```

##### 예제

다양한 UPDATE문의 사용 예를 보여준다.

[예제 1] 다음은 ENO 칼럼값이 s_eno와 같은 DNO, EMP_JOB 칼럼값을 각각 s_dno, s_emp_job.arr 값으로 변경하는 예를 보여준다.

\< 예제 프로그램 : update.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
int      s_eno;
short    s_dno;
varchar  s_emp_job[15+1];
EXEC SQL END DECLARE SECTION;

s_eno = 2;
s_dno = 1001;
strcpy(s_emp_job.arr, "ENGINEER");
s_emp_job.len = strlen(s_emp_job.arr);

EXEC SQL UPDATE EMPLOYEES 
SET DNO      = :s_dno,
     EMP_JOB = :s_emp_job
WHERE ENO = :s_eno;
```

[예제 2] 다음은 구조체 타입의 호스트 변수를 사용하는 경우로, ENO 칼럼값이 s_eno와 같은 DNO, EMP_JOB, JOIN_DATE 칼럼값을 각각 s_employees.s_dno, s_employees.s_emp_job.arr값과 SYSDATE로 변경하는 예를 보여준다.

\< 예제 프로그램 : hostvar.h \>

```
EXEC SQL BEGIN DECLARE SECTION;
typedef struct employee
{
      int        eno;
      char      ename[20+1];
      varchar   emp_job[15+1];
      char      emp_tel[15+1];
      short     dno;
      double    salary;
      char      sex;
      char      birth[4+1];
      char      join_date[19+1];
      char      status[1+1];
} employee;
EXEC SQL END DECLARE SECTION;
```

\< 예제 프로그램 : update.sc \>

```
/* specify path of header file */
EXEC SQL OPTION (INCLUDE=./include);
/* include header file for precompile */
EXEC SQL INCLUDE hostvar.h;

EXEC SQL BEGIN DECLARE SECTION;
employee s_employee;
EXEC SQL END DECLARE SECTION;

s_eno = 20;
s_employee.dno = 2001;
strcpy(s_employee.emp_job.arr, "TESTER");
s_employee.emp_job.len = strlen(s_employee.emp_job.arr);

EXEC SQL UPDATE EMPLOYEES 
SET DNO        = :s_employee.dno,
     EMP_JOB   = :s_employee.emp_job,
               JOIN_DATE = SYSDATE
           WHERE ENO = :s_eno;
```

#### DELETE

조건을 만족하는 레코드를 해당 테이블에서 삭제한다.

##### 구문

```
SQL Reference 참조
```

##### 인자

없음

##### 설명

WHERE절에 호스트 변수와 지시자 변수를 사용할 수 있다.

##### 예제

다음은 조건에 맞는 레코드를 EMPLOYEES 테이블에서 삭제하는 예를 보여준다.

\< 예제 프로그램 : delete.sc \>

```
EXEC SQL BEGIN DECLARE SECTION;
int      s_eno;
short    s_dno;
EXEC SQL END DECLARE SECTION;

s_eno = 5;
s_dno = 1000;

EXEC SQL DELETE FROM EMPLOYEES 
           WHERE ENO > :s_eno AND 
DNO > :s_dno AND 
EMP_JOB LIKE 'P%';
```

#### 예제 프로그램

##### select.sc

$ALTIBASE_HOME/sample/APRE/select.sc 참고

##### 실행결과

```
$ is –f schema/schema.sql
$ make select
$ ./select
<SELECT>
------------------------------------------------------
[Scalar Host Variables]                                           
------------------------------------------------------
DNO      DNAME                          DEP_LOCATION              
------------------------------------------------------
1001     RESEARCH DEVELOPMENT DEPT 1    New York 

------------------------------------------------------
[Structure Host Variables]                                        
------------------------------------------------------------------
DNO      DNAME                          DEP_LOCATION       MGR_NO 
------------------------------------------------------------------
1002     RESEARCH DEVELOPMENT DEPT 2    Sydney             13

------------------------------------------------------
[Error Case : Scalar Host Variables]                              
------------------------------------------------------
Error : [-594092] Returns too many rows
```

##### insert.sc 

$ALTIBASE_HOME/sample/APRE/insert.sc 참고

##### 실행결과

```
$ is –f schema/schema.sql
$ make insert
$ ./insert
<INSERT>
------------------------------------------------------
[Scalar Host Variables]                                           
------------------------------------------------------
1 rows inserted

------------------------------------------------------
[Structure Host Variables]                                        
------------------------------------------------------
1 rows inserted
```

##### update.sc 

$ALTIBASE_HOME/sample/APRE/update.sc 참고

##### 실행결과

```
$ is –f schema/schema.sql
$ make update
$ ./update
<UPDATE>
------------------------------------------------------
[Scalar Host Variables]                                           
------------------------------------------------------
1 rows updated

------------------------------------------------------
[Structure Host Variables]                                        
------------------------------------------------------
1 rows updated
```

##### delete.sc 

$ALTIBASE_HOME/sample/APRE/delete.sc 참고

##### 실행결과

```
$ is –f schema/schema.sql
$ make delete
$ ./delete
<DELETE>
------------------------------------------------------
[Scalar Host Variables]                                           
------------------------------------------------------
7 rows deleted
```

### 기타 내장 SQL문

작업 제어문, 시스템 제어문, 트랜잭션 처리문 등과 INCLUDE 문, THREADS OPTION문 등이 여기에 속한다.

#### AUTOCOMMIT

##### 구문

```
EXEC SQL AUTOCOMMIT { ON | OFF };
```

##### 인자

없음

##### 설명

현재 세션의 AUTOCOMMIT 모드를 변경한다.

##### 예제

다음은 AUTOCOMMIT 모드를 변경하는 예를 보여준다.

```
EXEC SQL AUTOCOMMIT ON; -- AUTOCOMMIT 모드로 변경
EXEC SQL AUTOCOMMIT OFF; -- NON-AUTOCOMMIT 모드로 변경
```

#### COMMIT

##### 구문

```
EXEC SQL COMMIT;
```

##### 인자

없음

##### 설명

현재의 트랜잭션을 성공적으로 종료한다. 트랜잭션에서 수행된 변경 연산의 결과는 데이터베이스에 영구히 저장된다.

> ##### 주의 사항
>
> 현재 세션이 AUTOCOMMIT 모드이더라도 오류는 발생하지 않는다.
>

##### 예제

다음 예제는 COMMIT문의 사용 예를 보여준다.

```
EXEC SQL COMMIT;
```

#### SAVEPOINT 

##### 구문

```
EXEC SQL SAVEPOINT <savepoint_name>;
```

##### 인자

- \<savepoint_name\>: 저장점 이름


##### 설명

저장점은 지금까지의 트랜잭션을 임시 저장하는 것이다. 이 내장 SQL문은 트랜잭션 내에서 롤백 할 지점을 명시적으로 지정하기 위한 저장점을 지정한다.

> ##### 주의 사항
>
> 현재 세션이 AUTOCOMMIT 모드이더라도 오류는 발생하지 않는다.
>

##### 예제

다음 예제는 SAVEPOINT문의 사용 예를 보여준다.

```
EXEC SQL SAVEPOINT sp;
```

#### ROLLBACK

##### 구문

```
EXEC SQL ROLLBACK [ TO SAVEPOINT <savepoint_name> ];
```

##### 인자

- \<savepoint_name\> : 저장점 이름


##### 설명

가장 최근의 DDL문이나 COMMIT문 이전 상태로 트랜잭션을 철회시켜, 트랜잭션에서 수행된 변경 연산의 결과는 취소된다.

저장점 이름을 지정하면, 현재부터 그 지점까지의 트랜잭션만 철회된다.

> ##### 주의 사항
>
> 현재 세션이 AUTOCOMMIT 모드이더라도 오류는 발생하지 않는다.
>

##### 예제

다음 예제는 ROLLBACK문의 사용 예를 보여준다.

```
EXEC SQL ROLLBACK;
또는
EXEC SQL ROLLBACK TO SAVEPOINT sp;
```

#### BATCH

연결 속성을 변경하여 Batch Processing을 작동시키거나 정지 시킬 수 있다.

##### 구문

```
EXEC SQL BATCH { ON | OFF };
```

##### 인자

없음

##### 설명

배치 처리 모드를 활성화하면 SELECT문이나 COMMIT이 수행되기 전까지 내장 SQL문의 수행(서버로의 전송)을 지연한다. 이것은 COMMIT되지 않은 INSERT, UPDATE, DELETE문은 같은 트랜잭션에서만 읽을 수 있다는 점을 이용한 것이다.

INSERT, UPDATE, DELETE문이 자주 발생하는 경우 배치 처리 모드를 활성화하면 성능 향상을 기대할 수 있다.

##### 예제

다음 예제는 BATCH문의 사용 예를 보여준다.

```
EXEC SQL BATCH ON;	- 배치 처리 모드로 동작
EXEC SQL BATCH OFF; 	- 배치 처리 모드를 사용하지 않음
```

#### FREE

데이터베이스 서버와의 연결 및 내장 SQL문 수행 시 할당 받았던 자원을 모두 해제한다.

##### 구문

```
EXEC SQL FREE;
```

##### 인자

없음

##### 설명

CONNECT 후 내장 SQL문을 수행하다가 서버와의 연결이 끊어져서 다시 CONNECT를 수행하려면 먼저 FREE문을 수행하여야 한다. 이 때, 데이터베이스 서버는 running 상태가 아니어야 한다. 만약 데이터베이스 서버가 running 상태라면 FREE문 대신 DISCONNECT문을 수행하여야 한다.

##### 예제

다음 예제는 FREE문의 사용 예를 보여준다.

\< 예제 프로그램 : free.sc \>

```
EXEC SQL FREE;
```

#### INCLUDE

전처리 시 포함할 헤더파일을 지정한다.

##### 구문

```
EXEC SQL INCLUDE <filename>;
```

##### 인자

-   \<*filename*\> : 전처리 시 사용할 헤더 파일의 이름

##### 설명

호스트 변수와 호스트 변수의 데이터 타입으로 사용할 타입 정의는 전처리를 하기 위해 APRE가 알아야 할 중요한 정보이다. 따라서, 호스트 변수가 선언되어 있거나 호스트 변수 타입으로 사용할 타입 정의가 되어 있는 헤더 파일은 반드시 INCLUDE문을 이용하여 include하여야 한다(-parse 전처리 명령행 옵션을 “full”로 설정하지 않는다면).

이 구문은 전처리 할 파일(.sc)과 EXEC SQL INCLUDE로 포함한 헤더파일(.h) 내에서 사용할 수 있으며 \#include로 포함한 헤더파일 내에서는 사용할 수 없다.

##### 제한 사항

헤더 파일은 상호 참조할 수 없다. 즉, myheader1.h가 myheader2.h를 참조하고 myheader2.h가 myheader1.h를 참조해서 사용할 수 없다.

예) <myheader1.h>

```
EXEC SQL INCLUDE myheader2.h;
…

<myheader2.h>
EXEC SQL INCLUDE myheader1.h;	(X)
…
```

##### 예제

다음은 전처리 시 사용할 헤더파일을 INCLUDE 구문을 이용하여 지정하는 예를 보여준다.

\< 예제 프로그램 : insert.sc \>

```
EXEC SQL INCLUDE hostvar.h;
```

#### 예제 프로그램

##### free.sc 

$ALTIBASE_HOME/sample/APRE/free.sc 참고

##### 실행 결과

```
$ is –f schema/schema.sql
$ make free
$ ./free
<FREE>
------------------------------------------------------
[Connect]
------------------------------------------------------
Success connection to altibase server

------------------------------------------------------
[Free]
------------------------------------------------------
Error : [-331796] Function sequence error

------------------------------------------------------
[Reconnect]
------------------------------------------------------
Error : [-589826] Already connected
```

### OPTION문

C/C++ 전처리기에서 제공하는 다양한 옵션들을 OPTION문을 이용하여 지정할 수 있다.

#### INCLUDE

전처리 시 사용하는 헤더 파일의 위치를 지정하기 위해서 내장 SQL문은 다양한 방법을 제공한다. 그 중 하나가 바로 INCLUDE OPTION문이다.

##### 구문

```
EXEC SQL OPTION (INCLUDE = <pathname>);
```

##### 인자

-   \<*pathname*\> : 전처리 시 사용할 헤더 파일의 위치

##### 설명

전처리 시 사용할 헤더 파일의 위치를 지정한다.

여러 개의 위치를 지정하기 위해서는 콤마(,)로 구분한다.

이 OPTION문은 반드시 INCLUDE문 이전에 선언하여야 한다.

##### 예제

다음은 hostvar.h의 위치인 ./include 디렉토리를 INCLUDE OPTION문을 이용하여 지정하고 hostvar.h를 include하는 예를 보여준다.

\< 예제 프로그램 : insert.sc \>

```
EXEC SQL OPTION (INCLUDE=./include);
EXEC SQL INCLUDE hostvar.h;
```

#### THREADS

내장 SQL문은 멀티쓰레드 프로그램을 지원한다. 이 OPTION문은 전처리 할 파일이 멀티쓰레드 프로그램인지 아닌지 판단하는 근거를 전처리기에게 제공한다.

##### 구문

```
EXEC SQL OPTION (THREADS = { TRUE | FALSE });
```

##### 인자

없음

##### 설명

-   TRUE : 전처리 할 파일이 멀티쓰레드 프로그램인 경우

-   FALSE : 전처리 할 파일이 멀티쓰레드 프로그램이 아닌 경우

기본적으로 THREADS OPTION값은 FALSE이다. 전처리 할 파일이 멀티쓰레드 프로그램이라면 THREADS OPTION값을 TRUE로 지정하여야 한다. 멀티쓰레드 프로그램 전처리 시 command line에서 -mt 옵션을 지정한다면 이 OPTION문은 생략 가능하다.

##### 예제

다음은 전처리 할 파일이 멀티쓰레드 프로그램일 경우 OPTION문을 이용하여 THREADS OPTION값을 TRUE로 지정하는 예를 보여준다.

\< 예제 프로그램 : mt1.sc \>

```
EXEC SQL OPTION (THREADS=TRUE); 
```

