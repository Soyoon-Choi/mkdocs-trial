# 3.호스트 변수 선언부

### 호스트 변수 선언부

호스트 변수의 이름, 타입, 길이 등의 정보는 전처리 과정에서 중요한 정보이다. 따라서, 사용될 호스트 변수는 C/C++ 전처리기가 인식할 수 있는 구문으로 표기되어야 하며, 이것은 호스트 변수 선언부에서 이루어진다.

호스트 변수 선언부에서는 프로그램에서 사용할 호스트 변수를 선언한다.

#### 구문

호스트 변수 선언부는 다음의 구문으로 지원한다.

```
EXEC SQL BEGIN DECLARE SECTION;
/* variable_declarations */
EXEC SQL END DECLARE SECTION;
```

이 구문의 호스트 변수 선언부는 “EXEC SQL BEGIN DECLARE SECTION;” 문장으로 시작되며, “EXEC SQL END DECLARE SECTION;” 문장으로 끝난다. 프로그램에서 사용할 호스트 변수는 이 두 문장 사이에 선언되어야 한다.

호스트 변수 선언부는 전처리할 파일(.sc)과 전처리에서 사용하는 헤더파일(.h) 내에 위치할 수 있다.

하지만, \#include로 포함된 헤더파일(.h) 내에는 호스트 변수 선언부가 올 수 없으므로, 호스트 변수 선언부 없이 호스트 변수를 선언하고 -parse 명령행 옵션을 full로 설정하여 precompile하면 된다. EXEC SQL INCLUDE로 포함된 헤더파일(.h)의 경우에는 호스트 변수 선언부를 헤더 파일 내에 사용할 수 있다.

그 이유는 \#include로 포함된 헤더파일(.h)은 전처리할 파일(.sc)에서만 참조하는 것이 아니라 내장 SQL이 포함되지 않은 C(.c) 또는 C++(.cpp) 소스 파일에서도 참조할 수가 있는데, 이 때 컴파일 오류가 발생하기 때문이다. 자세한 내용은 4장의 "\#include 제약"을 참고하기 바란다.

#### 변수 선언 범위(Scope)

호스트 변수 선언부는 전역 또는 지역에 위치할 수 있다. 변수 선언 범위는 C/C++과 유사하며, 같은 이름의 변수가 다른 범위에서 중첩되어 선언되면, 가장 가까운 범위에서 선언된 변수가 상위 범위의 변수 선언에 우선한다(overriding).

이러한 중첩은 최대 50단계까지 허용된다.

##### 예제

다음은 다른 범위에서 같은 이름의 변수를 선언하여 사용하는 예를 보여준다. myfunc() 함수 안에서는 지역으로 선언된 name(\#2)이 전역 변수인 name(\#1)보다 우선 순위가 높으므로 이후의 name(\#3)은 지역 변수를 참조한다.

```
EXEC SQL BEGIN DECLARE SECTION;	
char name[20];			<- #1
EXEC SQL END DECLARE SECTION;	

int myfunc(void)
{
EXEC SQL BEGIN DECLARE SECTION;	
char name[20];			<- #2
EXEC SQL END DECLARE SECTION;	

EXEC SQL INSERT INTO T1 VALUES (:name);		<- #3
}
```

#### 예제

다음은 다양한 호스트 변수 선언 예를 보여준다.

```
EXEC SQL BEGIN DECLARE SECTION;	<- #1
int x, y, z;	<- #2
char c1[50], c2[100]; 		<- #3
varchar v1[50]; 		<- #4
struct tag1 
{	
int  x;
char  y[50];
varchar  z[50];
} st1;            		<- #5
struct tag1 st2; 		<- #6
EXEC SQL END DECLARE SECTION; 	<- #7
```

\#1 : 호스트 변수 선언부의 시작을 표시한다.

\#2 : int 타입의 변수 x, y, z를 호스트 변수로 선언한다.

\#3 : char 타입의 변수 c1, c2를 각각 50, 100 바이트 크기로 선언한다.

\#4 : varchar 타입의 변수 v1를 50 바이트 크기로 선언한다.

\#5 : tag1구조체 타입의 변수 st1을 선언하고, 태그이름을 tag1으로 정의한다.

\#6 : tag1 구조체 타입의 변수 st2를 선언한다.

\#7 : 호스트 변수 선언부의 끝을 표시한다.

### 자료형 정의 

내장 SQL문에는 내장 SQL문이 지원하는 자료형 외에 사용자가 typedef문을 이용하여 정의한 자료형을 호스트 변수의 자료형으로 사용할 수 있다.

#### 설명

호스트 변수의 자료형으로 사용될 자료형 정의(typedef)는 전처리기가 인식할 수 있는 구문으로 표기되어야 하며, 자료형 정의(typedef)의 위치는 호스트 변수 선언부로 제한된다. 자료형 정의(typedef)된 새로운 자료형은 다른 자료형과 함께 호스트 변수의 자료형으로 사용할 수 있다.

#### 예제

자료형 정의의 다양한 예를 보여준다.

[예제 1] 다음은 자료형 정의(typedef)의 사용 예를 보여준다.

```
EXEC SQL BEGIN DECLARE SECTION;	
typdef unsigned int UINT;
typdef unsigned char UCHAR;
EXEC SQL END DECLARE SECTION; 
```

[예제 2] 다음은 구조체 자료형 정의의 다양한 예를 보여준다.

(1) 구조체 정의 후 자료형 정의

```
EXEC SQL BEGIN DECLARE SECTION;	
struct department
{
    short dno;
    char  dname[30+1];
    char  dep_location[9+1];
    int   mgr_no;
};
typedef struct department department;
EXEC SQL END DECLARE SECTION; 
```

(2) 구조체 정의와 자료형 정의를 동시에

```
EXEC SQL BEGIN DECLARE SECTION;	
typedef struct department
{
    short dno;
    char  dname[30+1];
    char  dep_location[9+1];
    int   mgr_no;
} department;
EXEC SQL END DECLARE SECTION; 	
```

(3) 자료형 정의 후 구조체 정의

```
EXEC SQL BEGIN DECLARE SECTION;	
typedef struct department department;
struct department
{
    short dno;
    char  dname[30+1];
    char  dep_location[9+1];
    int   mgr_no;
};
EXEC SQL END DECLARE SECTION; 	
```

### 함수 인자 선언부

함수의 인자를 호스트 변수로 사용할 경우 C/C++ 전처리기에게 함수 인자에 대한 정보를 제공해 줄 방법이 필요하다. 함수 인자 선언부가 함수 인자에 대한 정보를 C/C++ 전처리기에게 알려주는 역할을 한다.

#### 구문

함수 인자 선언부의 구문은 다음과 같다.

```
EXEC SQL BEGIN ARGUMENT SECTION;
/* 호스트 변수로 사용할 함수 인자를 선언 */
EXEC SQL END ARGUMENT SECTION;
```

함수 인자 선언부는 “EXEC SQL BEGIN ARGUMENT SECTION;” 문장으로 시작되며, “EXEC SQL END ARGUMENT SECTION;” 문장으로 끝난다. 호스트 변수로 사용할 함수 인자들은 이 두 문장 사이에 선언하어야 한다.

함수 인자 선언 시 함수 정의 시와 똑같이(같은 이름, 같은 타입) 선언해 주어야 한다.

#### 설명

함수 인자 선언부는 전처리 할 소스 파일(.sc)내에 있는 함수 안에만 위치할 수 있다.

호스트 변수 선언부의 제한 사항이 함수 인자 선언부에도 그대로 적용된다.

#### 예제 프로그램

##### argument.sc

$ALTIBASE_HOME/sample/APRE/argument.sc  참고

##### 실행결과

```
$ is –f schema/schema.sql
$ make argument
$ ./argument
         <ARGUMENT> 
```

