# 12.Altibase 저장 프로시저와 내장 함수

Altibase는 다양한 종류의 내장된 저장 프로시저와 함수를 제공한다. 저장 프로시저
내에서의 파일 제어 함수와 TCP 접속 제어 관련 저장 프로시저가 그것이다. 이 장은
이들 저장 프로시저와 함수를 소개하고 그 사용법에 대해 설명한다.

이 장은 아래의 토픽을 포함한다.

-   파일 제어

-   TCP 접속 제어

-   DBMS Stats

### 파일 제어

프로시저의 파일 제어 기능은 운영 체제의 텍스트 파일에 대한 읽기와 쓰기를
가능하게 한다. 이 기능을 이용하여 사용자는 저장 프로시저 실행에 대한 별도의
메시지 등을 파일에 남길 수도 있으며, 파일로 결과를 출력하거나 파일로부터
데이터를 읽어와 테이블에 삽입하는 등 다양한 작업을 수행할 수 있다.

이 절은 이러한 파일 제어 기능에 대해서 설명한다.

#### 디렉토리 관리

저장 프로시저에서 파일들을 생성하고 제어하기 위해서는 이들 파일들이 저장될
디렉토리가 필요한데, 이는 데이터베이스 객체로서 DML문을 사용해서 생성하고 관리할
수 있다.

##### 디렉토리 생성

저장 프로시저 파일 제어 기능에서 사용하는 파일들을 저장할 디렉토리들은 CREATE
DIRECTORY문을 사용하여 데이터베이스 객체로 생성한다.

CREATE DIRECTORY문을 수행하면 SYS_DIRECTORIES\_ 메타 테이블에 디렉토리 정보가
등록되며, 실제 운영 체제의 파일 시스템에 디렉토리가 생성되지는 않는다. 따라서
사용자는 실제 파일 시스템에 디렉토리를 생성하는 작업을 먼저 수동으로 해야 한다.

사용자는 CREATE DIRECTORY문에 데이터베이스가 참조할 논리적인 디렉토리명과 실제
파일 시스템 상에서의 디렉토리 절대 경로를 명시해야 한다.

예를 들어 다음과 같이 /home/altibase/altibase_home/psm_msg 디렉토리 밑에
alti_dir1 디렉토리를 생성한다.

```
$ mkdir /home/altibase/altibase_home/psm_msg/alti_dir1
```

다음으로, alti_dir1 디렉토리 내의 파일들을 제어할 수 있도록 대응하는 디렉토리
객체를 데이터베이스 내에 생성한다.

```
iSQL> create directory alti_dir1 as '/home/altibase/altibase_home/psm_msg';
Create success.
```

##### 디렉토리 변경

CREATE OR REPLACE DIRECTORY문을 사용해 이미 생성한 디렉토리의 절대 경로를 다음과
같이 변경할 수 있다.

```
iSQL> create or replace directory alti_dir1 as '/home/altibase/altibase_home/psm_result';
Create success.
```

위의 예제에서 alti_dir1 디렉토리가 이미 데이터베이스에 존재할 경우에는 사용자가
명시한 절대 경로 정보를 변경하며, alti_dir1 디렉토리가 존재하지 않을 경우에는
새로운 객체를 데이터베이스에 생성한다.

##### 디렉토리 삭제

디렉토리 객체는 DROP DIRECTORY문을 사용해서 데이터베이스에서 삭제할 수 있다.

DROP DIRECTORY문을 사용해 디렉토리를 삭제하는 경우 데이터베이스에서 관리하는
오브젝트만 삭제되며 실제 파일 시스템 상의 디렉토리가 제거되는 것은 아니다.

따라서 사용자는 파일 시스템 상에 존재하는 불필요한 디렉토리와 파일들은 운영 체제
명령어를 이용해 직접 제거해야 한다.

다음은 DROP DIRECTORY문을 사용해 데이터베이스에서 디렉토리를 삭제하는 예제이다.

```
iSQL> DROP DIRECTORY alti_dir1;
Drop success.
```



#### 파일 제어

##### 데이타 타입

저장 프로시저 내에서 파일 제어를 위해서 Altibase는 FILE_TYPE이라는 데이터 타입을
지원한다.

FILE_TYPE은 내부적으로 파일 식별자 및 기타 정보를 가지고 있으나, 사용자가 직접
이 내부 데이터에 접근할 수는 없다.

저장 프로시저 내에서 FILE_TYPE 데이터 타입의 지역변수들은 파일 제어 관련 시스템
저장 프로시저 및 저장 함수들의 인자로 사용될 수 있다.

FILE_TYPE으로 변수를 선언하는 예제는 다음과 같다.

```
CREATE OR REPLACE PROCEDURE WRITE_T1
AS
	V1	FILE_TYPE;
	ID 	INTEGER;
	NAME 	VARCHAR(40);
BEGIN
……
END;
/
```



##### 파일 제어 프로시저와 함수

Altibase는 저장 프로시저 및 저장 함수 내에서 파일 제어와 관련해서 다음과 같은
시스템 프로시저와 함수를 제공한다.

| 시스템 프로시저 및 함수명 | 설명                                                         |
| ------------------------- | ------------------------------------------------------------ |
| FCLOSE                    | 파일을 닫는다.                                               |
| FCLOSE_ALL                | 현재 세션에 열려있는 모든 파일을 닫는다.                     |
| FCOPY                     | 파일을 복사한다.                                             |
| FFLUSH                    | 파일에 데이터를 물리적으로 기록한다.                         |
| FOPEN                     | 읽기 또는 쓰기 목적으로 파일을 오픈한다.                     |
| FREMOVE                   | 파일을 삭제한다.                                             |
| FRENAME                   | 파일명을 변경한다.                                           |
| GET_LINE                  | 파일에서 한 라인을 읽는다.                                   |
| IS_OPEN                   | 파일이 열려있는지 검사한다.                                  |
| NEW_LINE                  | 개행 문자를 출력한다.                                        |
| PUT                       | 문자열을 파일에 기록한다                                     |
| PUT_LINE                  | 문자열에 개행 문자를 붙여서 파일에 기록한다 (= PUT+NEW_LINE). |

위 표의 시스템 프로시저와 함수들은 최초 데이터베이스 생성시 시스템 내에서 자동
생성되는 저장 프로시저 및 저장 함수로 PUBLIC 시노님으로 정의되어 있어 임의의
사용자가 이들을 이용해 저장 프로시저 내에서 파일을 제어 할 수 있다.

이러한 시스템 프로시저 및 함수를 사용한 파일 제어 작업은 다음 그림과 같이
표현된다.

![file_control](media/StoredProcedure/file_control.gif)

##### 주의사항

다음은 저장 프로시저 실행 시 오류를 발생시킬 수 있는 사항들이므로 주의해야 한다.

###### **디렉토리** 이름

파일제어 함수 사용시 디렉토리 파라미터는 CREATE DIRECTORY문으로 생성한 디렉토리
객체의 이름을 사용하되 반드시 대문자로 표기한다.

예를 들어,

```
CREATE DIRECTORY alti_dir AS ‘…’;
```

위와 같이 디렉토리 객체를 생성하였다면 저장 프로시저 내에서는 다음과 같이
사용해야 한다.

```
file = FOPEN( ‘ALTI_DIR’, ‘a.txt’, ‘r’ );
```

디렉토리 생성 시 소문자로 디렉토리 객체의 이름을 명시하여도 데이터베이스 내 객체
이름은 모두 대문자로 저장되기 때문에 시스템 프로시저 및 함수의 파라미터로
디렉토리 이름을 입력할 때는 대문자를 사용해야 한다.

###### **한 라인의 문자열 길이**

파일 내 한 라인의 최대 문자열 길이는 32767 bytes를 넘을 수 없다. 만약 최대
길이를 초과할 경우 오류가 발생한다.

###### **파일 데이터 타입**

FILE_TYPE은 사용자가 임의로 변수 값을 대입하거나 정보를 읽을 수 없으며, 시스템
프로시저 및 함수의 파라미터로만 사용할 수 있다.

###### **파일 제어 관련 시스템 프로시저 및 함수**

파일 제어 관련 시스템 프로시저 및 함수들은 기본적인 시스템 정의 예외 외에 다른
예외들을 발생시킬 수 있다.

예를 들면 디스크 공간 부족, 열 수 있는 파일 핸들 부족, 또는 운영체제 상에서
오류가 발생할 경우 INVALID OPERATION 등의 예기치 않은 오류를 발생시킨다.

파일 제어 관련 시스템 프로시저 및 함수들은 인자를 잘못 넘겨 받은 경우
VALUE_ERROR EXCEPTION을 발생시킨다.

#### FCLOSE

열려있는 파일 핸들을 닫고 다시 초기화 하는 기능을 제공하는 저장 프로시저다.

##### 구문

```
FCLOSE ( file IN OUT FILE_TYPE );
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명      |
|------|--------|-------------|-----------|
| file | IN OUT | FILE_TYPE   | 파일 핸들 |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

수행 시 오류 발생 없이 항상 성공한다. 이미 닫힌 파일 핸들에 대해 수행할 때도
오류 없이 성공한다.

##### 예제

FOPEN후에는 FCLOSE를 호출하여 열린 파일 핸들을 다음과 같이 닫아 주어야 한다.

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 FILE_TYPE;
    V2 VARCHAR(1024);
BEGIN
    V1 := FOPEN( 'ALTI_DIR', 'schema.sql', 'r' );
    GET_LINE( V1, V2, 100 );
    PRINTLN(V2);
    FCLOSE(V1);
END;
/
```



#### FCLOSE_ALL

현재 세션에 열려있는 모든 파일 핸들을 닫는 기능을 제공하는 저장 프로시저다. 저장
프로시저 수행 중 예외가 발생했을 때에도 파일을 닫기 위해서, 주로 예외 처리 시에
사용한다.

##### 구문

```
FCLOSE_ALL;
```



##### 파라미터

파라미터가 없다.

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

수행 시 오류를 발생시키지 않으며 항상 성공한다.

##### 예제

다음은 예외 처리 시 열려 있는 모든 파일 핸들을 닫는 예제이다.

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 FILE_TYPE;
    V2 VARCHAR(1024);
BEGIN
    V1 := FOPEN( 'ALTI_DIR', 'schema.sql', 'r' );
    GET_LINE( V1, V2, 100 );
    PRINTLN(V2);
FCLOSE(V1);
EXCEPTION
    WHEN READ_ERROR THEN
         PRINTLN('READ ERROR!!!');
         FCLOSE_ALL;
END;
/
```



#### FCOPY

파일을 라인 단위로 복사하는 기능을 제공하는 저장 프로시저이다. 결과 파일이 해당
디렉토리 내에 존재하지 않을 경우에는 새로운 파일을 생성하여 소스 파일 내용을
복사하고, 이미 결과 파일이 존재하는 경우에는 오류 없이 그대로 내용을 덮어 쓴다.

##### 구문

```
FCOPY (
location IN VARCHAR(40),
filename IN VARCHAR(256),
dest_dir IN VARCHAR(40),
dest_file IN VARCHAR(256),
start_line IN INTEGER DEFAULT 1,
end_line IN INTEGER DEFAULT NULL);
```



##### 파라미터

| 이름       | 입출력 | 데이터 타입  | 설명                                                         |
| ---------- | ------ | ------------ | ------------------------------------------------------------ |
| location   | IN     | VARCHAR(40)  | 소스 파일이 위치하는 경로에 해당하는 디렉토리 객체의 이름    |
| filename   | IN     | VARCHAR(256) | 소스 파일의 이름                                             |
| dest_dir   | IN     | VARCHAR(40)  | 결과 파일이 위치하는 경로에 해당하는 디렉토리 객체의 이름    |
| dest_file  | IN     | VARCHAR(256) | 결과 파일의 이름                                             |
| start_line | IN     | INTEGER      | 복사할 시작 라인 번호 <br />기본값: 1                        |
| end_line   | IN     | INTEGER      | 복사할 마지막 라인 번호. NULL로 주게 되면 파일의 끝까지 복사한다. <br />기본값: NULL |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

FCOPY는 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_PATH

-   ACCESS_DENIED

-   INVALID_OPERATION

-   READ_ERROR

-   WRITE_ERROR

예외 처리에 대한 자세한 설명은 이 장의 “파일 제어 예외 처리” 절을 참조한다.

##### 예제

다음은 a.txt의 파일의 모든 내용을 b.txt에 복사하는 에제이다.

```
iSQL> EXEC FCOPY( 'ALTI_DIR', 'a.txt', 'ALTI_DIR', 'b.txt' );
Execute success.

$ cat a.txt
1-ABCDEFG
2-ABCDEFG
3-ABCDEFG
4-ABCDEFG
5-ABCDEFG
6-ABCDEFG
7-ABCDEFG
8-ABCDEFG
9-ABCDEFG
10-ABCDEFG

$ cat b.txt
1-ABCDEFG
2-ABCDEFG
3-ABCDEFG
4-ABCDEFG
5-ABCDEFG
6-ABCDEFG
7-ABCDEFG
8-ABCDEFG
9-ABCDEFG
10-ABCDEFG
```

다음은 특정 라인만을 a.txt에서 b.txt로 복사하는 예제이다.

```
iSQL> EXEC FCOPY( 'ALTI_DIR', 'a.txt', 'ALTI_DIR2', 'b.txt', 4, 9 );
Execute success.

$ cat a.txt
1-ABCDEFG
2-ABCDEFG
3-ABCDEFG
4-ABCDEFG
5-ABCDEFG
6-ABCDEFG
7-ABCDEFG
8-ABCDEFG
9-ABCDEFG
10-ABCDEFG

$ cat b.txt
4-ABCDEFG
5-ABCDEFG
6-ABCDEFG
7-ABCDEFG
8-ABCDEFG
9-ABCDEFG
```



#### FFLUSH

파일에 물리적으로 기록하는 기능을 제공하는 저장 프로시저다.

##### 구문

```
FFLUSH ( file IN FILE_TYPE );
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명      |
|------|--------|-------------|-----------|
| file | IN     | FILE_TYPE   | 파일 핸들 |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

FFLUSH는 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_FILEHANDLE

-   WRITE_ERROR

예외 처리에 대한 자세한 설명은 이 장의 “파일 제어 예외 처리” 절을 참조한다.

##### 예제

다음은 T1 테이블의 I1 칼럼의 모든 데이터를 파일에 한번에 기록하는 예제로
PUT_LINE의 마지막 인자인 *autoflush* 에 FALSE를 넘겨 PUT_LINE 호출 때마다 flush
하지 않고 마지막에 한번 FFLUSH를 호출해 flush 하는 예제이다.

```
CREATE OR REPLACE PROCEDURE PROC1
AS
   V1 FILE_TYPE;
   R2 T1%ROWTYPE;
   CURSOR C1 IS SELECT I1 FROM T1;
BEGIN
   V1 := FOPEN( 'ALTI_DIR', 'a.txt', 'w' );
   FOR R2 IN C1 LOOP
       PUT_LINE( V1, R2.I1, FALSE );
   END LOOP;
   FFLUSH(V1);
   FCLOSE(V1);
EXCEPTION
   WHEN INVALID_PATH THEN
       PRINTLN('CANNOT OPEN FILE.');
   WHEN NO_DATA_FOUND THEN
       PRINTLN('NO DATA FOUND.');
       FCLOSE( V1 );
END;
/
```



#### FOPEN

파일을 열고 파일 핸들을 반환하는 기능을 제공하는 저장 함수이다.

##### 구문

```
FILE_TYPE variable :=
FOPEN (
         location IN VARCHAR(40),
         filename IN VARCHAR(256),
         open_mode IN VARCHAR(4) );
```



##### 파라미터

| 이름      | 입출력 | 데이터 타입  | 설명                                                         |
| --------- | ------ | ------------ | ------------------------------------------------------------ |
| location  | IN     | VARCHAR(40)  | 파일이 위치하는 경로에 해당하는 디렉토리 객체의 이름         |
| filename  | IN     | VARCHAR(256) | 파일의 이름                                                  |
| open_mode | IN     | VARCHAR(4)   | 입력 가능 옵션은 다음 세 가지이다.<br /> r: 읽기 w: 쓰기 a: 이어 쓰기 <br />* 주의 사항: rw, wa와 같이 조합해서 사용 할 수 없다. |

##### 결과값

성공적으로 수행할 경우 데이터 타입이 FILE_TYPE인 파일 핸들을 반환한다.

##### 예외

FOPEN은 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_PATH

-   ACCESS_DENIED

-   INVALID_OPERATION

-   INVALID_MODE

예외 처리에 대한 자세한 설명은 이 장의 “파일 제어 예외 처리” 절을 참조한다.

##### 예제

파일을 읽거나 쓰기 위해서는 우선 FOPEN을 사용해 다음과 같이 파일을 열어야 한다.

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 FILE_TYPE;
    V2 VARCHAR(1024);
BEGIN
    V1 := FOPEN( 'ALTI_DIR', 'schema.sql', 'r' );
    GET_LINE( V1, V2, 100 );
    PRINTLN(V2);
    FCLOSE(V1);
END;
/
```



#### FREMOVE

해당 파일을 삭제하는 기능을 제공하는 저장 프로시저다.

##### 구문

```
FREMOVE (
  location IN VARCHAR(40),
  filename IN VARCHAR(256));
```



##### 파라미터

| 이름     | 입출력 | 데이터 타입  | 설명                                                 |
|----------|--------|--------------|------------------------------------------------------|
| location | IN     | VARCHAR(40)  | 파일이 위치하는 경로에 해당하는 디렉토리 객체의 이름 |
| filename | IN     | VARCHAR(256) | 파일의 이름                                          |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

FREMOVE는 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_PATH

-   ACCESS_DENIED

-   DELETE_FAILED

예외 처리에 대한 자세한 설명은 이 장의 “파일 제어 예외 처리” 절을 참조한다.

##### 예제

다음은 파일을 삭제하는 예제이다.

```
--## 현재 디렉토리 내의 파일 리스트
$ ls
a.sql       a.txt       b.txt       schema.sql

--## FREMOVE 실행
iSQL> EXEC FREMOVE('ALTI_DIR','b.txt');
Execute success.

--# 저장 프로시저 수행 후 디렉토리내의 파일 리스트
$ ls
a.sql       a.txt       schema.sql
```



#### FRENAME

UNIX mv 명령어와 동일한 기능을 가지며, 파일의 이름을 바꾸거나, 다른 위치로
옮기는 기능을 제공하는 저장 프로시저다.

##### 구문

```
FRENAME (
location IN VARCHAR(40),
filename IN VARCHAR(256),
dest_dir IN VARCHAR(40),
dest_file IN VARCHAR(256),
overwrite IN BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름      | 입출력 | 데이터 타입  | 설명                                                         |
| --------- | ------ | ------------ | ------------------------------------------------------------ |
| location  | IN     | VARCHAR(40)  | 원본 파일이 위치하는 경로에 해당하는 디렉토리                |
| filename  | IN     | VARCHAR(256) | 원본 파일의 이름                                             |
| dest_dir  | IN     | VARCHAR(40)  | 결과 파일이 위치하는 경로에 해당하는 디렉토리                |
| dest_file | IN     | VARCHAR(256) | 결과 파일의 이름                                             |
| overwrite | IN     | BOOLEAN      | 이미 파일이 존재하는 경우 덮어 쓸지 여부를 지정한다. <br />TRUE: 기존 파일을 새로운 파일로 덮어 쓴다. <br />FALSE: 덮어 쓰지 않는다. <br />기본값: FALSE |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

FRENAME에서 발생 가능한 시스템 정의 예외들은 다음과 같다.

-   INVALID_PATH

-   ACCESS_DENIED

-   RENAME_FAILED

예외 처리에 대한 자세한 설명은 이 장의 “파일 제어 예외 처리” 절을 참조한다.

##### 예제

다음은 a.txt 파일을 result.txt로 이름을 변경하는 예제이다.

```
--## 현재 디렉토리내의 파일 리스트
$ ls
a.sql       a.txt       schema.sql

--## FRENAME 수행
iSQL> EXEC FRENAME('ALTI_DIR','a.txt','ALTI_DIR','result.txt',TRUE);
Execute success.

--# 저장 프로시저 수행 후 디렉토리내의 파일 리스트
$ ls
a.sql       result.txt  schema.sql
```



#### GET_LINE

해당 파일에서 한 줄씩 읽어오는 기능을 제공하는 저장 프로시저다.

##### 구문

```
GET_LINE (
   file IN FILE_TYPE,
   buffer OUT VARCHAR(32768),
   len IN INTEGER DEFAULT NULL);
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입    | 설명                                                         |
| ------ | ------ | -------------- | ------------------------------------------------------------ |
| file   | IN     | FILE_TYPE      | 파일 핸들                                                    |
| buffer | OUT    | VARCHAR(32768) | 파일에서 읽은 한 라인을 저장할 버퍼                          |
| len    | IN     | INTEGER        | 파일의 한 라인에서 읽어 올 최대 bytes 수로 입력하지 않을 경우 1024 bytes 크기만큼 읽어온다. <br />기본값: NULL |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

GET_LINE에서 발생 가능한 시스템 정의 예외는 다음과 같다.

-   NO_DATA_FOUND

-   READ_ERROR

-   INVALID_FILEHANDLE

예외 처리에 대한 자세한 설명은 이 장의 “파일 제어 예외 처리” 절을 참조한다.

##### 예제

다음은 파일의 한 라인에서 100 bytes를 읽어 출력하는 예제이다.

```
iSQL> CREATE OR REPLACE PROCEDURE PROC1
    2 AS
    3     V1 FILE_TYPE;
    4     V2 VARCHAR(1024);
    5 BEGIN
    6     V1 := FOPEN( 'ALTI_DIR', 'schema.sql', 'r' );
    7     GET_LINE( V1, V2, 100 );
    8     PRINTLN(V2);
    9     FCLOSE(V1);
    10 END;
    11 /
Create success.
iSQL> EXEC PROC1;
create table t1 (i1 integer, i2 integer, i3 integer);
Execute success.
```



#### IS_OPEN

파일이 열려 있는지 여부를 검사하는 기능을 제공하는 저장 함수다.

##### 구문

```
BOOLEAN variable :=
IS_OPEN ( file IN FILE_TYPE );
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명      |
|------|--------|-------------|-----------|
| file | IN     | FILE_TYPE   | 파일 핸들 |

##### 결과값

결과값은 BOOLEAN 데이터 타입으로 열려있으면 TRUE, 열려있지 않으면 FALSE를
반환한다.

##### 예외

파일 핸들이 정상적으로 열려 있는 경우에 TRUE를 반환하며 그 외의 경우에는 모두
FALSE를 반환하므로 수행 시 오류가 발생하지 않는다.

##### 예제

다음은 파일 핸들이 열려 있는지 없는지 검사하는 예제이다.

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 FILE_TYPE;
BEGIN
    IF IS_OPEN(V1) = FALSE THEN
        PRINTLN('V1 IS NOT OPENED.');
    ELSE
        PRINTLN('V1 IS OPENED.');
    END IF;
    V1 := FOPEN( 'ALTI_DIR', 'a.txt', 'w' );
    PRINTLN('FOPEN FUNCTION CALLED.');
    IF IS_OPEN(V1) = FALSE THEN
        PRINTLN('V1 IS NOT OPENED.');
    ELSE
        PRINTLN('V1 IS OPENED.');
    END IF;
    FCLOSE( V1 );
    PRINTLN('FCLOSE FUNCTION CALLED.');
    IF IS_OPEN(V1) = FALSE THEN
        PRINTLN('V1 IS NOT OPENED.');
    ELSE
        PRINTLN('V1 IS OPENED.');
    END IF;
END;
/
```



#### NEW_LINE

파일에 해당 개수의 개행 문자를 기록하는 기능을 제공하는 저장 프로시저다.

##### 구문

```
NEW_LINE  (
file IN FILE_TYPE,
lines IN INTEGER DEFAULT 1 );
```



##### 파라미터

| 이름  | 입출력 | 데이터 타입 | 설명                       |
|-------|--------|-------------|----------------------------|
| file  | IN     | FILE_TYPE   | 파일 핸들                  |
| lines | IN     | INTEGER     | 기록할 라인의 수 기본값: 1 |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

NEW_LINE에서 발생 가능한 시스템 정의 예외는 다음과 같다.

-   INVALID_FILEHANDLE

-   WRITE_ERROR

예외 처리에 대한 자세한 설명은 이 장의 “파일 제어 예외 처리” 절을 참조한다.

##### 예제

다음은 파일에 문자열을 기록하는 예제이다.

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 FILE_TYPE;
BEGIN
    V1 := FOPEN( 'ALTI_DIR', 'a.txt', 'w' );
    PUT_LINE( V1, 'REPORT', TRUE );
    NEW_LINE( V1, 3 );
    PUT_LINE( V1, '------', TRUE );
    FCLOSE( V1 );
END;
/

--## 위의 저장 프로시저 수행 후 a.txt 파일 결과
$ cat a.txt
REPORT



------
$
```



#### PUT

파일에 문자열을 기록하는 기능을 제공하는 저장 프로시저다.

##### 구문

```
PUT (
  file IN FILE_TYPE,
  buffer IN VARCHAR(32768));
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입    | 설명                               |
|--------|--------|----------------|------------------------------------|
| file   | IN     | FILE_TYPE      | 파일 핸들                          |
| buffer | IN     | VARCHAR(32768) | 기록할 문자열을 저장하고 있는 버퍼 |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

PUT은 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_FILEHANDLE

-   WRITE_ERROR

예외 처리에 대한 자세한 설명은 이 장의 “파일 제어 예외 처리” 절을 참조한다.

##### 예제

다음은 파일에 문자열을 기록하는 예제이다.

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 FILE_TYPE;
BEGIN
    V1 := FOPEN( 'ALTI_DIR', 'a.txt', 'w' );
    PUT( V1, 'REPORT');
    PUT( V1, '-->');
    PUT_LINE( V1, 'SUCCESS', TRUE );
    FCLOSE( V1 );
END;
/
--## 위의 저장 프로시저 수행 후 a.txt 파일 결과
$ cat a.txt
REPORT-->SUCCESS
$
```



#### PUT_LINE

파일에 문자열을 포함한 한 라인을 기록하는 기능을 제공하는 저장 프로시저다.

##### 구문

```
PUT_LINE (
file IN FILE_TYPE,
buffer IN VARCHAR(32767),
autoflush IN BOOLEAN DEFAULT FALSE);
```



##### 파라미터

| 이름      | 입출력 | 데이터 타입    | 설명                                             |
| --------- | ------ | -------------- | ------------------------------------------------ |
| file      | IN     | FILE_TYPE      | 파일 핸들                                        |
| Buffer    | IN     | VARCHAR(32767) | 기록할 문자열을 저장하고 있는 버퍼               |
| autoflush | IN     | BOOLEAN        | 호출할 때마다 flush할지 여부 <br />기본값: FALSE |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

PUT_LINE는 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_FILEHANDLE

-   WRITE_ERROR

예외 처리에 대한 자세한 설명은 이 장의 “파일 제어 예외 처리” 절을 참조한다.

##### 예제

다음은 파일에 문자열의 라인을 기록하는 예제이다.

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 FILE_TYPE;
BEGIN
    V1 := FOPEN('ALTI_DIR', 'a.txt', 'w');
    PUT_LINE(V1, '1-ABCDEFG');
    PUT_LINE(V1, '2-ABCDEFG');
    PUT_LINE(V1, '3-ABCDEFG');
    PUT_LINE(V1, '4-ABCDEFG');
    PUT_LINE(V1, '5-ABCDEFG');
    PUT_LINE(V1, '6-ABCDEFG');
    PUT_LINE(V1, '7-ABCDEFG');
    PUT_LINE(V1, '8-ABCDEFG');
    PUT_LINE(V1, '9-ABCDEFG');
    PUT_LINE(V1, '10-ABCDEFG');
    FCLOSE(V1);
END;
/
```

위의 저장 프로시저를 수행한 후 파일 내용은 다음과 같다.

```
$ cat a.txt
1-ABCDEFG
2-ABCDEFG
3-ABCDEFG
4-ABCDEFG
5-ABCDEFG
6-ABCDEFG
7-ABCDEFG
8-ABCDEFG
9-ABCDEFG
10-ABCDEFG
```



#### 파일 제어 예외 처리

저장 프로시저 또는 함수 실행 중에 발생할 수 있는 파일 제어 관련 예외를 처리할 때
명심해야 할 몇 가지 주의 사항을 설명한다.

파일 제어 관련 내장 프로시저와 함수 실행 중 발생 가능한 예외는 다음 표와 같다.
이들 예외는 다른 시스템 정의 예외처럼 exception handler에서 처리할 수 있다.

| 예외 이름          | 설명                                                                                                                      |
|--------------------|---------------------------------------------------------------------------------------------------------------------------|
| INVALID_PATH       | 해당 디렉토리 객체가 존재하지 않음 (즉 명시한 객체는 CREATE DIRECTORY문으로 만들어진 디렉토리 객체가 아님)                |
| INVALID_MODE       | 파일 열기 모드의 값이 유효하지 않음 (r, w, a 중 하나를 지정해야 함)                                                       |
| INVALID_FILEHANDLE | 파일 핸들이 유효하지 않음 (파일이 열린 상태가 아님)                                                                       |
| INVALID_OPERATION  | 실제 디렉토리 및 파일이 파일 시스템 상에 존재하지 않거나 파일 시스템에 의해 접근이 거부됨                                 |
| READ_ERROR         | 열기에 성공한 파일이 READ 시 존재하지 않거나, 파일 시스템에 의해 파일이 접근 거부됨                                       |
| WRITE_ERROR        | 열기에 성공한 파일이 WRITE 시 존재하지 않거나, 파일 시스템에 의해 파일이 접근 거부되거나, 쓰기 모드로 연 파일이 아닌 경우 |
| ACCESS_DENIED      | 디렉토리 객체에 대한 접근이 거부됨 (GRANT문으로 사용자에게 객체 접근 권한을 부여 해야 함)                                 |
| DELETE_FAILED      | 삭제할 파일이 존재하지 않거나, 파일 시스템에 의해 파일 접근이 거부된 경우                                                 |
| RENAME_FAILED      | overwrite옵션을 주지 않았는데 이미 바꿀 파일이 존재하거나, 기타 운영 체제 에러가 발생한 경우                              |

#### 예제

##### 예제1

다음은 디렉토리와 파일 이름을 입력으로 받아 파일을 열어 파일의 내용을 조회하는
프로시저다. 이 때, 디렉토리 또는 파일 이름이 잘못 지정되거나 데이터가 존재하지
않는 빈 파일이 지정될 수도 있다. 그러므로 이 저장 프로시저는 INVALID_PATH 및
NO_DATA_FOUND 예외를 처리할 수 있는 exception handler를 포함하고 있다.

```
--# CREATE VERIFY PROCEDURE
CREATE OR REPLACE PROCEDURE PROC2( PATH VARCHAR(40), FILE VARCHAR(40) )
AS
   V1 FILE_TYPE;
   V2 VARCHAR(100);
BEGIN
   V1 := FOPEN( PATH, FILE, 'r' );
   LOOP
       GET_LINE( V1, V2, 100 );
       PRINT( V2 );
   END LOOP;
EXCEPTION
   WHEN INVALID_PATH THEN
       PRINTLN('CANNOT OPEN FILE.');
   WHEN NO_DATA_FOUND THEN
       PRINTLN('NO DATA FOUND.');
       FCLOSE( V1 );
END;
/
```



##### 예제2

다음 예제는 테이블의 데이터를 파일로 쓰거나 파일에서 읽는 방법을 보여준다.

사용자를 생성하고 그 사용자에게 적절한 권한을 부여한다.

```
CONNECT SYS/MANAGER;
CREATE USER MHJEONG IDENTIFIED BY MHJEONG;
GRANT CREATE ANY DIRECTORY TO MHJEONG;
GRANT DROP ANY DIRECTORY TO MHJEONG;
```

테이블을 생성하고 데이터를 입력한 후, 디렉토리 객체를 생성한다.

```
CONNECT MHJEONG/MHJEONG;
CREATE TABLE T1( ID INTEGER, NAME VARCHAR(40) );
INSERT INTO T1 VALUES( 1, ‘JAKIM’ );
INSERT INTO T1 VALUES( 2, ‘PEH’ );
INSERT INTO T1 VALUES( 3, ‘KUMDORY’ );
INSERT INTO T1 VALUES( 4, ‘KHSHIM’ );
INSERT INTO T1 VALUES( 5, ‘LEEKMO’ );
INSERT INTO T1 VALUES( 6, ‘MHJEONG’ );
CREATE DIRECTORY MYDIR AS ‘/home1/mhjeong’;
```

T1테이블의 모든 레코드를 읽어서, 그 데이터를 t1.txt파일에 쓰는 저장 프로시저를
생성한다.

```
CREATE OR REPLACE PROCEDURE WRITE_T1
AS
  V1 FILE_TYPE;
  ID INTEGER;
  NAME VARCHAR(40);
BEGIN
  DECLARE
    CURSOR T1_CUR IS
    SELECT * FROM T1;
  BEGIN
    OPEN T1_CUR;
    V1 := FOPEN( ‘MYDIR’, ‘t1.txt’, ‘w’ );
    LOOP
      FETCH T1_CUR INTO ID, NAME;
      EXIT WHEN T1_CUR%NOTFOUND;
      PUT_LINE( V1, ‘ID : ‘||ID||’ NAME : ‘||NAME);
    END LOOP;
    CLOSE T1_CUR;
    FCLOSE(V1);
  END;
END;
/
```

파일 t1.txt의 내용을 읽어서 화면에 출력하는 저장 프로시저를 생성한다.

```
CREATE OR REPLACE PROCEDURE READ_T1
AS
  BUFFER VARCHAR(200);
  V1 FILE_TYPE;
BEGIN
  V1 := FOPEN( ‘MYDIR’, ‘t1.txt’, ‘r’ );
  LOOP
    GET_LINE( V1, BUFFER, 200 );
    PRINT( BUFFER );
  END LOOP;
  FCLOSE( V1 );
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    FCLOSE( V1 );
END;
/
```



##### 실행 결과

위에서 생성한 저장 프로시저를 실행하면, 다음의 결과가 출력된다.

```
iSQL> exec write_t1;
EXECUTE success.
iSQL> exec read_t1;
ID : 1 NAME : JAKIM
ID : 2 NAME : PEH
ID : 3 NAME : KUMDORY
ID : 4 NAME : KHSHIM
ID : 5 NAME : LEEKMO
ID : 6 NAME : MHJEONG
EXECUTE success.
```

파일 시스템의 해당 디렉토리에 다음의 파일이 있을 것이다.

```
$ cd /home1/mhjeong
$ cat t1.txt
ID : 1 NAME : JAKIM
ID : 2 NAME : PEH
ID : 3 NAME : KUMDORY
ID : 4 NAME : KHSHIM
ID : 5 NAME : LEEKMO
ID : 6 NAME : MHJEONG
```



### TCP 접속 제어

#### TCP 접속 제어

##### 데이타 타입

저장 프로시저에서 TCP 접속을 제어하기 위해서 CONNECT_TYPE이라는 데이터 타입을
지원한다.

CONNECT_TYPE은 내부적으로 TCP 소켓 관련 정보를 저장하고 있으나, 사용자가 내부
데이터에는 접근할 수 없다.

##### CONNECT_TYPE의 함수

저장 프로시저 내에서 CONNECT_TYPE의 지역 변수들은 아래 함수의 인자 또는 반환
값으로 사용될 수 있다.

| 함수명              | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| CLOSEALL_CONNECT    | 세션에 연결된 모든 접속 핸들을 닫는다.                       |
| CLOSE_CONNECT       | 세션에 연결된 접속 핸들을 닫는다.                            |
| IS_CONNECTED        | CONNECT_TYPE의 접속 핸들이 연결된 상태를 확인한다.           |
| OPEN_CONNECT        | 읽기 또는 쓰기의 목적으로 파일을 연다.                       |
| WRITE_RAW           | RAW(VARBYTE) 타입의 자료를 접속된 핸들을 통해 네트워크에 전송한다. |
| CHECK_CONNECT_STATE | 현재 연결의 상태와 변경하기 원하는 상태를 비교하여, 상태변이가 가능한지 검사한다. |
| CHECK_CONNECT_REPLY | 접속 핸들의 프로토콜에 적합하게 응답 메시지를 검사한다.      |
| SEND_TEXT           | VARCHAR 타입의 데이터를 원격 서버에 전송한다.                |
| RECV_TEXT           | 원격 서버에서 VARCHAR 타입의 데이터를 수신한다.              |
| WRITE_RAW_VALUE     | RAW 타입의 VALUE 데이터를 원격 서버에 전송한다.              |

##### TCP 접속 제어 연결 상태

| 연결 상태  | 식별값 |
| :--------- | :----- |
| NO CONNECT | 0      |
| CONNECTED  | 1      |
| SMTP HELO  | 2      |
| SMTP MAIL  | 3      |
| SMTP RCPT  | 4      |
| SMTP OPEN  | 5      |
| SMTP DATA  | 6      |
| SMTP CRLF  | 7      |

##### TCP 접속 제어 프로토콜 타입

| 프로토콜 타입 | 식별값 |
| :------------ | :----- |
| SMTP          | 1      |


#### CLOSEALL_CONNECT

현재 세션에 연결되어 있는 모든 접속 핸들을 닫는 저장 함수이다.

##### 구문

```
CONNECT_TYPE variable :=
CLOSEALL_CONNECT();
```



##### 결과값

성공적으로 수행하면 0을 반환한다.

##### 예외

이 함수는 예외를 발생시키지 않는다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 INTEGER;
BEGIN
    V1 := CLOSEALL_CONNECT();
END;
/
```



#### CLOSE_CONNECT

현재 세션에 연결되어 있는 접속 핸들을 닫는 저장 함수이다.

##### 구문

```
CONNECT_TYPE variable :=
CLOSE_CONNECT(
         coon IN CONNECT_TYPE);
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입  | 설명      |
|------|--------|--------------|-----------|
| coon | IN     | CONNECT_TYPE | 접속 핸들 |

##### 결과값

성공적으로 수행하면 0을 반환한다.

##### 예외

이 함수는 예외를 발생시키지 않는다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 CONNECT_TYPE;
    V2 INTEGER;
BEGIN
    V1 := OPEN_CONNECT('127.0.0.1', 22007, 1000, 3000);
    V2 := WRITE_RAW(V1, TO_RAW('MESSAGE'), RAW_SIZEOF('MESSAGE'));
    V2 := CLOSE_CONNECT(V1);
END;
/
```



#### IS_CONNECTED

CONNECT_TYPE 접속 핸들의 연결 상태를 확인하는 함수이다.

##### 구문

```
CONNECT_TYPE variable :=
IS_CONNECTED(
         coon IN CONNECT_TYPE);
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입  | 설명      |
|------|--------|--------------|-----------|
| coon | IN     | CONNECT_TYPE | 접속 핸들 |

##### 결과값

접속 핸들이 연결 상태이면 0을 반환하고, 연결되지 않았다면  -1을 반환한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
    AS
    V1 CONNECT_TYPE;
    V2 INTEGER;
BEGIN
    V1 := OPEN_CONNECT('127.0.0.1', 22007, 1000, 3000);
    V2 := IS_CONNECTED(V1);
    IF V2 = 0 THEN
        PRINTLN('CONNECTD');
        V2 := WRITE_RAW(V1, TO_RAW('MESSAGE'), RAW_SIZEOF('MESSAGE'));
        V2 := CLOSE_CONNECT(V1);
    ELSE
        PRINTLN('NOT CONNECTD');
    END IF;
END;
/
```



#### OPEN_CONNECT

TCP 소켓을 생성하고, 입력한 IP와 PORT로 원격 서버에 접속하는 기능을 제공하는
저장 함수이다.

##### 구문

```
CONNECT_TYPE variable :=
OPEN_CONNECT(
         ip IN VARCHAR(64),
         port IN INTEGER,
         connect_timeout IN INTEGER,
         tx_buffersize IN INTEGER);
```



##### 파라미터

| 이름            | 입출력 | 데이터 타입 | 설명                                                         |
| --------------- | ------ | ----------- | ------------------------------------------------------------ |
| ip              | IN     | VARCHAR(64) | 원격 서버의 IP 주소                                          |
| port            | IN     | INTEGER     | 원격 서버의 PORT 번호                                        |
| connect_timeout | IN     | INTEGER     | 접속을 허용하는 시간(마이크로초).<br />0 또는 Null을 입력하면 접속될 때까지 대기한다. |
| tx_buffersize   | IN     | INTEGER     | 송신 버퍼의 크기를 설정한다. <br />2048\~32767 바이트까지 설정할 수 있으며, Null 또는 2048 이하의 값은 2048 바이트로 설정된다. |

##### 결과값

성공적으로 수행할 경우 데이터 타입이 CONNECT_TYPE인 접속 핸들을 반환한다.

##### 예외

접속 핸들이 정상적으로 네트워크에 정상적으로 연결되지 않았다면, CONNECT_TYPE은
NULL값을 반환한다. IS_CONNECTED() 함수를 이용하여 반환된 CONNECT_TYPE의 값으로
접속 여부를 확인할 수 있다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 CONNECT_TYPE;
    V2 INTEGER;
BEGIN
    V1 := OPEN_CONNECT('127.0.0.1', 22007, 1000, 3000);
    V2 := WRITE_RAW(V1, TO_RAW('MESSAGE'), RAW_SIZEOF('MESSAGE'));
    V2 := CLOSE_CONNECT(V1);
END;
/
```



#### WRITE_RAW

RAW(VARBYTE) 타입의 자료를 접속된 핸들을 통해 네트워크에 전송하는 함수이다.

##### 구문

```
CONNECT_TYPE variable :=
WRITE_RAW (
         coon IN CONNECT_TYPE,
         data IN VARBYTE,
         length IN INTEGER );
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입  | 설명                 |
|--------|--------|--------------|----------------------|
| coon   | IN     | CONNECT_TYPE | 접속 핸들            |
| data   | IN     | VARBYTE      | 전송될 데이터        |
| length | IN     | INTEGER      | 전송될 데이터의 길이 |

##### 결과값

성공적으로 수행할 경우 네트워크에 전송된 데이터의 길이를 반환한다.

##### 예외

수행시 오류가 발생하면 -1을 반환한다.

만약 접속 핸들이 유실되었다면 IS_CONNECTED() 함수를 확인하여 결과값이 -1이 반환되어 확인할 수 있다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 CONNECT_TYPE;
    V2 INTEGER;
BEGIN
    V1 := OPEN_CONNECT('127.0.0.1', 22007, 1000, 3000);
    V2 := WRITE_RAW(V1, TO_RAW('MESSAGE'), RAW_SIZEOF('MESSAGE'));
    V2 := CLOSE_CONNECT(V1);
END;
```



#### CHECK_CONNECT_STATE

현재 연결의 상태와 변경하기 원하는 상태를 비교하여, 상태변이가 가능한지 검사한다.

##### 구문

```
INTEGER variable :=
CHECK_CONNECT_STATE(
  c IN CONNECT_TYPE,
  next_state IN INTEGER );
```



##### 파라미터

| 이름       | 입출력 | 데이터 타입  | 설명                      |
| :--------- | :----- | :----------- | :------------------------ |
| c          | IN     | CONNECT_TYPE | 원격 서버의 접속 핸들     |
| next_state | IN     | INTEGER      | 변경하기 원하는 상태의 값 |

##### 결과값

성공적으로 수행하면 0을 반환한다.

##### 예외

현재 연결 상태에서 원하는 상태로 변경을 지원하지 않을 때, UNSUPPORTED_STATE 예외가 발생한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 CONNECT_TYPE;
    V2 INTEGER;
BEGIN
    V1 := OPEN_CONNECT( '127.0.0.1', 25, null, null );
    V2 := CHECK_CONNECT_STATE( V1, 1 ); --# 1은 Connected 상태
    V2 := CLOSE_CONNECT( V1 );
END;
/
```



#### CHECK_CONNECT_REPLY

현재 연결의 프로토콜에 적합한 응답 결과인지 검사한다.

##### 구문

```
INTEGER variable :=
CHECK_CONNECT_REPLY(
  protocol_type IN INTEGER,
  reply IN VARCHAR(65534) );
```



##### 파라미터

| 이름          | 입출력 | 데이터 타입    | 설명            |
| :------------ | :----- | :------------- | :-------------- |
| protocol_type | IN     | INTEGER        | 프로토콜 타입   |
| reply         | IN     | VARCHAR(65534) | 응답받은 메세지 |

##### 결과값

성공적으로 수행하면 0을 반환한다.

##### 예외

지원하지 않는 프로토콜 타입을 사용하거나 응답의 내용이 에러인 경우 SMTP_REPLY_ERROR 예외가 발생한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 CONNECT_TYPE;
    V2 INTEGER;
    V3 VARCHAR(65534);
BEGIN
    V1 := OPEN_CONNECT( '127.0.0.1', 25, null, null );
    V2 := CHECK_CONNECT_STATE( V1, 1 ); --# 1은 Connected 상태
    IF ( V2 > 0 ) THEN
        V3 := RECV_TEXT( V1, 100 );
        V2 := CHECK_CONNECT_REPLY( 1, V3 ); --# 1은 SMTP
    END IF;
END;
/
```



#### SEND_TEXT

VARCHAR 타입의 자료를 접속된 핸들을 통해 네트워크에 전송하는 함수이다.

##### 구문

```
INTEGER variable :=
SEND_TEXT(
  c IN CONNECT_TYPE,
  data IN VARCHAR(65534),
  length IN INTEGER );
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입    | 설명                  |
| :----- | :----- | :------------- | :-------------------- |
| c      | IN     | CONNECT_TYPE   | 원격 서버의 접속 핸들 |
| data   | IN     | VARCHAR(65534) | 전송할 데이터         |
| length | IN     | INTEGER        | 전송할 데이터의 길이  |

##### 결과값

성공적으로 수행할 경우, 네크워크로 전송된 데이터의 길이를 반환한다.

##### 예외

수행시 오류가 발생하면 -1을 반환한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 CONNECT_TYPE;
    V2 INTEGER;
BEGIN
    V1 := OPEN_CONNECT( '127.0.0.1', 25, null, null );
    V2 := SEND_TEXT( V1, 'HELO 127.0.0.1' || CHR( 13 ) || CHR( 10 ), 16 );
    V2 := CLOSE_CONNECT( V1 );
END;
/
```



#### RECV_TEXT

접속된 핸들을 통해 네트워크로 VARCHAR 타입의 자료를 전송받는 함수이다.

##### 구문

```
VARCHAR variable :=
RECV_TEXT(
  c IN CONNECT_TYPE,
  length IN INTEGER );
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입  | 설명                        |
| :----- | :----- | :----------- | :-------------------------- |
| c      | IN     | CONNECT_TYPE | 원격 서버의 접속 핸들       |
| length | IN     | INTEGER      | 전송받을 응답 데이터의 길이 |

##### 결과값

성공적으로 수행할 경우, 네크워크로 받은 VARCHAR 데이터를 반환한다.

##### 예외

수행시 오류가 발생하면 null 를 반환한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 CONNECT_TYPE;
    V2 INTEGER;
    V3 VARCHAR(65534);
BEGIN
    V1 := OPEN_CONNECT( '127.0.0.1', 25, null, null );
    V2 := SEND_TEXT( V1, 'HELO 127.0.0.1'  || CHR( 13 ) || CHR( 10 ), 16 );
    V3 := RECV_TEXT( V1, 100 );
    V2 := CLOSE_CONNECT( V1 );
END;
/
```



#### WRITE_RAW_VALUE

RAW 타입의 VALUE 데이터를 접속된 핸들을 통해 네트워크에 전송하는 함수이다.

##### 구문

```
INTEGER variable :=
WRITE_RAW_VALUE(
  c IN CONNECT_TYPE,
  data IN RAW(65534),
  length IN INTEGER );
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입  | 설명                  |
| :----- | :----- | :----------- | :-------------------- |
| c      | IN     | CONNECT_TYPE | 원격 서버의 접속 핸들 |
| data   | IN     | RAW(65534)   | 전송할 데이터         |
| length | IN     | INTEGER      | 전송할 데이터의 길이  |

##### 결과값

성공적으로 수행할 경우, 네크워크로 전송된 데이터의 길이를 반환한다.

##### 예외

수행시 오류가 발생하면 -1을 반환한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
    V1 CONNECT_TYPE;
    V2 INTEGER;
    V3 VARCHAR(65534);
BEGIN
    V1 := OPEN_CONNECT( '127.0.0.1', 25, null, null );
    V2 := WRITE_RAW_VALUE( V1, TO_RAW( 'HELO 127.0.0.1'  || CHR( 13 ) || CHR( 10 ) ), 16 );
    V2 := CLOSE_CONNECT( V1 );
END;
/
```



### DBMS Stats

DBMS Stats 은 Altibase 데이터베이스의 통계 자료를 수집, 변경(설정), 삭제하는
기능이다. 이 기능은 시스템 저장 프로시저 형태로 제공된다.

#### 개요

데이터베이스 내의 객체들에 대한 통계 자료는 쿼리 옵티마이저가 최적화된 실행
계획을 만들기 위해 사용한다. DBMS Stats 저장 프로시저를 이용해서 이 통계 자료를
구축하고 갱신할 수 있으며, 개별의 칼럼, 인덱스, 테이블 또는 시스템 별로 통계
자료를 설정하거나 삭제할 수 있다.

#### DBMS Stats 프로시저

Altibase는 통계 자료 수집을 위해 다음과 같은 시스템 저장 프로시저를 제공한다. 이
저장 프로시저를 사용해서 통계 자료를 수집하고 실행 계획을 재구축할 수 있다.

| 이름                  | 설명                                             |
|-----------------------|--------------------------------------------------|
| GATHER_SYSTEM_STATS   | 데이터베이스 시스템에 대한 통계 자료를 수집한다. |
| GATHER_DATABASE_STATS | 모든 테이블에 대한 통계 자료를 수집한다.         |
| GATHER_TABLE_STATS    | 특정 테이블에 대한 통계 자료를 수집한다.         |
| GATHER_INDEX_STATS    | 특정 인덱스에 대한 통계 자료를 수집한다.         |

아래는 개별적인 칼럼, 인덱스, 테이블 또는 시스템 관련 통계 자료를 변경하는 저장
프로시저이다.

| 이름             | 설명                                             |
|------------------|--------------------------------------------------|
| SET_SYSTEM_STATS | 데이터베이스 시스템에 대한 통계 자료를 변경한다. |
| SET_TABLE_STATS  | 특정 테이블에 대한 통계 자료를 변경한다.         |
| SET_INDEX_STATS  | 특정 인덱스에 대한 통계 자료를 변경한다.         |
| SET_COLUMN_STATS | 특정 테이블의 칼럼에 대한 통계 자료를 변경한다.  |

아래는 개별적인 칼럼, 인덱스, 테이블 또는 시스템 관련 통계 자료를 조회하는 저장
프로시저이다.

| 이름             | 설명                                             |
|------------------|--------------------------------------------------|
| GET_SYSTEM_STATS | 데이터베이스 시스템에 대한 통계 자료를 조회한다. |
| GET_TABLE_STATS  | 특정 테이블에 대한 통계 자료를 조회한다.         |
| GET_INDEX_STATS  | 특정 인덱스에 대한 통계 자료를 조회한다.         |
| GET_COLUMN_STATS | 특정 테이블의 칼럼에 대한 통계 자료를 조회한다.  |

아래는 개별적인 칼럼, 인덱스, 테이블 또는 시스템 관련 통계 자료를 복사 및
삭제하는 저장 프로시저이다.

| 이름                  | 설명                                             |
|-----------------------|--------------------------------------------------|
| COPY_TABLE_STATS      | 통계 정보를 새로운 파티션에 복사한다.            |
| DELETE_SYSTEM_STATS   | 데이터베이스 시스템에 대한 통계 자료를 삭제한다. |
| DELETE_DATABASE_STATS | 모든 테이블에 대한 통계 자료를 삭제한다.         |
| DELETE_TABLE_STATS    | 특정 테이블에 대한 통계 자료를 삭제한다.         |
| DELETE_INDEX_STATS    | 특정 인덱스에 대한 통계 자료를 삭제한다.         |
| DELETE_COLUMN_STATS   | 특정 테이블의 칼럼에 대한 통계 자료를 삭제한다.  |

#### 주의사항

-   통계 자료 수집 시 Altibase 서버에 부하가 가중될 수 있다.

-   통계 자료는 그 근사치를 수집한다.

-   통계 자료 수집 후 통계 자료를 수집한 대상 객체와 관련된 모든 쿼리의 실행
    계획을 재구축하게 된다. 이때 Altibase 서버의 성능이 다소 떨어질 수 있다.

#### COPY_TABLE_STATS

원본 파티션의 통계 정보를 새로운 파티션으로 복사한다. 원본 파티션의 통계 정보가
없는 경우에는 복사하지 않는다.

##### 구문

```
COPY_TABLE_STATS(
  ownname IN VARCHAR(128),
  tabname IN VARCHAR(128),
  srcpartname IN VARCHAR(128),
  dstpartname IN VARCHAR(128));
```



##### 파라미터

| 이름          | 입출력 | 데이터 타입  | 설명                                                   |
|---------------|--------|--------------|--------------------------------------------------------|
| *ownname*     | IN     | VARCHAR(128) | 원본 및 대상 파티션의 테이블 소유자의 이름             |
| *tabname*     | IN     | VARCHAR(128) | 원본 파티션의 테이블 이름 및 대상 파티션의 테이블 이름 |
| *srcpartname* | IN     | VARCHAR(128) | 원본 파티션의 이름                                     |
| *dstpartname* | IN     | VARCHAR(128) | 대상 파티션의 이름                                     |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC COPY_TABLE_STATS('SYS','T1','P3','P4');
Execute success.
```



#### GATHER_DATABASE_STATS

이 프로시저는 데이터베이스에 존재하는 모든 테이블에 대한 통계 자료를 수집한다.

##### 구문

```
GATHER_DATABASE_STATS (
  estimate_percent   FLOAT   DEFAULT 0,
  degree                INTEGER DEFAULT 0,
  gather_system_stats BOOLEAN DEFAULT FALSE,
  no_invalidate       BOOLEAN DEFAULT FALSE);
```



##### 파라미터

| 이름                  | 입출력 | 데이터 타입 | 설명                                                         |
| --------------------- | ------ | ----------- | ------------------------------------------------------------ |
| *estimate_percent*    | IN     | FLOAT       | 통계치를 추정하기 위해 수집할 샘플링 데이터의 양을 수집 대상 전체의 데이터 양으로 나눈 비율. <br />0 \~ 1.0의 값을 지정할 수 있다. 입력하지 않거나, NULL을 입력할 경우, 각 수집 대상의 크기에 따라 자동으로 설정된다. |
| *degree*              | IN     | INTEGER     | 통계 자료 수집을 병렬로 수행할 쓰레드의 수. <br />입력하지 않을 경우, 기본값은 0이다. |
| *gather_system_stats* | IN     | BOOLEAN     | 데이터베이스 시스템에 대한 통계 자료 수집을 같이 할 것인지 여부이다. <br />기본값은 FALSE이며, 이 경우 사용자는 GATHER_SYSTEM_STATS 나 SET_SYSTEM_STATS를 실행하여 시스템 통계 자료를 수집하거나 설정하여야 한다. |
| *no_invalidate*       | IN     | BOOLEAN     | 통계 자료를 수집한 테이블들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부이다. <br />실행 계획을 재구축하지 않으려면 TRUE를 입력한다. 입력하지 않을 경우의 기본값은 FALSE로, 실행 계획을 재구축 한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC GATHER_DATABASE_STATS();
SYSTEM_.SYS_TABLES_
SYSTEM_.SYS_COLUMNS_
SYSTEM_.SYS_DATABASE_
SYSTEM_.SYS_USERS_
.
.
.
Execute success.
```



#### GATHER_INDEX_STATS

특정 인덱스에 대한 통계 자료를 수집한다.

##### 구문

```
GATHER_INDEX_STATS (
  ownname             VARCHAR(128),
  idxname             VARCHAR(128),
  estimate_percent    FLOAT   DEFAULT 0,
  degree              INTEGER DEFAULT 0,
  no_invalidate       BOOLEAN DEFAULT FALSE);
```



##### 파라미터

| 이름               | 입출력 | 데이터 타입  | 설명                                                         |
| ------------------ | ------ | ------------ | ------------------------------------------------------------ |
| *ownname*          | IN     | VARCHAR(128) | 인덱스 소유자의 이름                                         |
| *idxname*          | IN     | VARCHAR(128) | 통계 자료를 수집할 인덱스의 이름                             |
| *estimate_percent* | IN     | FLOAT        | 통계치를 추정하기 위해 수집할 샘플링 데이터의 양을 수집 대상 전체의 데이터 양으로 나눈 비율. <br />0 \~ 1.0의 값을 지정할 수 있다. 입력하지 않거나, NULL을 입력할 경우, 각 수집 대상의 크기에 따라 자동으로 설정된다. |
| *degree*           | IN     | INTEGER      | 통계 자료 수집을 병렬로 수행할 쓰레드의 수. <br />입력하지 않을 경우, 기본값은 0이다. |
| *no_invalidate*    | IN     | BOOLEAN      | 통계 자료를 수집한 테이블들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부이다. <br />실행 계획을 재구축하지 않으려면 TRUE를 입력한다. 입력하지 않을 경우의 기본값은 FALSE로, 실행 계획을 재구축 한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC GATHER_INDEX_STATS( 'SYS','T1_IDX');
Execute success.
```



#### GATHER_SYSTEM_STATS

이 프로시저는 데이터베이스 시스템에 대한 통계 자료를 수집한다. 이 저장
프로시저는 SYS 사용자만이 수행할 수 있다.

##### 구문

```
GATHER_SYSTEM_STATS ( );
```



##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC GATHER_SYSTEM_STATS();
Execute success.
```



#### GATHER_TABLE_STATS

이 프로시저는 특정 테이블과 그 테이블에 정의된 인덱스들에 대한 통계 자료를
수집한다.

##### 구문

```
GATHER_TABLE_STATS (
  ownname              VARCHAR(128),
  tabname              VARCHAR(128),
  partname             VARCHAR(128) DEFAULT NULL,
  estimate_percent     FLOAT   DEFAULT 0,
  degree               INTEGER DEFAULT 0,
  no_invalidate        BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름               | 입출력 | 데이터 타입  | 설명                                                         |
| ------------------ | ------ | ------------ | ------------------------------------------------------------ |
| *ownname*          | IN     | VARCHAR(128) | 테이블 소유자의 이름                                         |
| *tabname*          | IN     | VARCHAR(128) | 통계 자료를 수집할 테이블의 이름                             |
| *partname*         | IN     | VARCHAR(128) | 테이블의 파티션 이름. 파티션을 지정하면, 그 파티션에 대한 통계 자료만 수집한다. <br />입력하지 않을 경우의 기본값은 NULL이며, 지정한 테이블의 모든 파티션에 대한 통계 자료를 수집한다. |
| *estimate_percent* | IN     | FLOAT        | 통계치를 추정하기 위해 수집할 샘플링 데이터의 양을 수집 대상 전체의 데이터 양으로 나눈 비율. <br />0 \~ 1.0의 값을 지정할 수 있다. 입력하지 않거나, NULL을 입력할 경우, 각 수집 대상의 크기에 따라 자동으로 설정된다. |
| *degree*           | IN     | INTEGER      | 통계 자료 수집을 병렬로 수행할 쓰레드의 수. <br />입력하지 않을 경우, 기본값은 0이다. |
| *no_invalidate*    | IN     | BOOLEAN      | 통계 자료를 수집한 테이블들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부이다. <br />실행 계획을 재구축하지 않으려면 TRUE를 입력한다. 입력하지 않을 경우의 기본값은 FALSE로, 실행 계획을 재구축 한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC GATHER_TABLE_STATS( 'SYS','T1');
Execute success.
```



#### SET_COLUMN_STATS

이 프로시저는 테이블의 칼럼에 대한 통계 자료를 변경한다.

##### 구문

```
SET_COLUMN_STATS (
  ownname          VARCHAR(128),
  tabname          VARCHAR(128),
  colname          VARCHAR(128),
  partname         VARCHAR(128) DEFAULT NULL,
  numdist          BIGINT  DEFAULT NULL,
  numnull          BIGINT  DEFAULT NULL,
  avgclen          BIGINT  DEFAULT NULL,
  minvalue         VARCHAR(48) DEFAULT NULL,
  maxvalue         VARCHAR(48) DEFAULT NULL,
  no_invalidate    BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름            | 입출력 | 데이터 타입  | 설명                                                         |
| --------------- | ------ | ------------ | ------------------------------------------------------------ |
| *ownname*       | IN     | VARCHAR(128) | 테이블 소유자의 이름                                         |
| *tabname*       | IN     | VARCHAR(128) | 통계 자료를 변경할 테이블의 이름                             |
| *colname*       | IN     | VARCHAR(128) | 통계 자료를 변경할 칼럼의 이름                               |
| *partname*      | IN     | VARCHAR(128) | 테이블의 파티션 이름. 파티션을 지정하면 해당 파티션에 대한 통계 자료만 변경한다. <br />기본값은 NULL이며, 테이블의 모든 파티션에 대한 통계 자료를 변경한다. |
| *numdist*       | IN     | BIGINT       | 칼럼에서 고유한 값의 개수                                    |
| *numnull*       | IN     | BIGINT       | 칼럼에서 NULL의 개수                                         |
| *avgclen*       | IN     | BIGINT       | 칼럼의 평균 길이                                             |
| *minvalue*      | IN     | VARCHAR(48)  | 칼럼의 최소값. DATE 타입은 반드시 "YYYY-MM-DD HH:MI:SS" 형식으로 입력한다. |
| *maxvalue*      | IN     | VARCHAR(48)  | 칼럼의 최대값. DATE 타입은 반드시 "YYYY-MM-DD HH:MI:SS" 형식으로 입력한다. |
| *no_invalidate* | IN     | BOOLEAN      | 통계 자료가 수집된 테이블들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부. <br />기본값은 FALSE이며, 실행 계획을 재구축한다. 만약 재구축하지 않으려면, TRUE를 입력한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC SET_COLUMN_STATS('SYS', 'T1', 'I1', NULL, 1000);
Execute success.
```



#### SET_INDEX_STATS

이 프로시저는 인덱스에 대한 통계 자료를 변경한다.

##### 구문

```
SET_INDEX_STATS (
  ownname           VARCHAR(128),
  index             VARCHAR(128),
  keycnt            BIGINT DEFAULT NULL,
  numpage           BIGINT DEFAULT NULL,
  numdist           BIGINT DEFAULT NULL,
  clusfct           BIGINT DEFAULT NULL,
  idxheight         BIGINT DEFAULT NULL,
  avgslotcnt        BIGINT DEFAULT NULL,
  no_invalidate     BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름            | 입출력 | 데이터 타입  | 설명                                                                                                                                                                   |
|-----------------|--------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *ownname*       | IN     | VARCHAR(128) | 인덱스 소유자의 이름                                                                                                                                                   |
| *index*         | IN     | VARCHAR(128) | 통계 자료를 변경할 인덱스의 이름                                                                                                                                       |
| *keycnt*        | IN     | BIGINT       | 인덱스의 레코드 개수                                                                                                                                                   |
| *numpage*       | IN     | BIGINT       | 인덱스의 페이지 개수                                                                                                                                                   |
| *numdist*       | IN     | BIGINT       | 인덱스에서 고유한 키의 개수                                                                                                                                            |
| *clusfct*       | IN     | BIGINT       | 인덱스에 부합하게 데이터가 정렬되어 있는 정도                                                                                                                          |
| *idxheight*     | IN     | BIGINT       | 인덱스의 루트에서 리프 노드까지의 깊이                                                                                                                                 |
| avgslotcnt      | IN     | BIGINT       | 인덱스 리프 노드에 저장된 레코드의 평균 개수                                                                                                                           |
| *no_invalidate* | IN     | BOOLEAN      | 통계 자료가 수집된 인덱스들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부. 기본값은 FALSE이며, 실행 계획을 재구축한다. 만약 재구축하지 않으려면, TRUE를 입력한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC SET_INDEX_STATS('SYS', 'IDX1', 1000);
Execute success.
```



#### SET_SYSTEM_STATS

이 프로시저는 데이터베이스 시스템에 대한 통계 자료를 변경한다. 이 저장
프로시저는 SYS 사용자만이 수행할 수 있다.

##### 구문

```
SET_SYSTEM_STATS (
  statname            VARCHAR(100),
  statvalue           DOUBLE);
```



##### 파라미터

| 이름        | 입출력 | 데이터 타입  | 설명                                                         |
| ----------- | ------ | ------------ | ------------------------------------------------------------ |
| *statname*  | IN     | VARCHAR(100) | 변경할 시스템 통계 정보의 이름이다. 아래의 값 중에서 하나를 입력해야 한다. <br />SREAD_TIME: 하나의 페이지를 읽는 평균 소요 시간<br />MREAD_TIME: 여러 페이지를 읽는 평균 소요 시간<br />MREAD_PAGE_COUNT: 한번에 읽어 온 페이지 개수<br />HASH_TIME : 평균 해시 수행 시간<br />COMPARE_TIME: 평균 비교 수행 시간<br />STORE_TIME: 평균 메모리 임시 테이블 저장 수행 시간 |
| *statvalue* | IN     | DOUBLE       | 시스템 통계 정보의 값                                        |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC SET_SYSTEM_STATS('SREAD_TIME', 100);
Execute success.
```



#### SET_TABLE_STATS

이 프로시저는 테이블에 대한 통계 자료를 변경한다.

##### 구문

```
SET_TABLE_STATS (
  ownname         VARCHAR(128),
  tabname         VARCHAR(128),
  partname        VARCHAR(128) DEFAULT NULL,
  numrow          BIGINT  DEFAULT NULL,
  numblk          BIGINT  DEFAULT NULL,
  avgrlen         BIGINT  DEFAULT NULL,
  onerowreadtime  DOUBLE  DEFAULT NULL,
  no_invalidate   BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름            | 입출력 | 데이터 타입  | 설명                                                         |
| --------------- | ------ | ------------ | ------------------------------------------------------------ |
| *ownname*       | IN     | VARCHAR(128) | 테이블 소유자의 이름                                         |
| *tabname*       | IN     | VARCHAR(128) | 통계 자료를 변경할 테이블의 이름                             |
| *partname*      | IN     | VARCHAR(128) | 테이블의 파티션 이름. <br />파티션을 지정하면 해당 파티션에 대한 통계 자료만 변경된다. 입력하지 않을 경우 기본값은 NULL이며, 지정한 테이블의 모든 파티션에 대한 통계 자료가 변경된다. |
| *numrow*        | IN     | BIGINT       | 테이블의 레코드 개수                                         |
| *numblk*        | IN     | BIGINT       | 테이블의 페이지 개수                                         |
| *avgrlen*       | IN     | BIGINT       | 테이블의 레코드 평균 길이                                    |
| onerowreadtime  | IN     | DOUBLE       | 테이블의 레코드를 읽는 시간                                  |
| *no_invalidate* | IN     | BOOLEAN      | 통계 자료가 수집된 테이블들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부. <br />기본값은 FALSE이며, 실행 계획을 재구축한다. 만약 재구축하지 않으려면, TRUE를 입력한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC SET_TABLE_STATS('SYS', 'T1', NULL, 1000);
Execute success.
```



#### GET_COLUMN_STATS

이 프로시저는 테이블의 칼럼에 대한 통계 자료를 조회한다.

##### 구문

```
GET_COLUMN_STATS (
  ownname          VARCHAR(128),
  tabname          VARCHAR(128),
  colname          VARCHAR(128),
  partname         VARCHAR(128) DEFAULT NULL,
  numdist          BIGINT,
  numnull          BIGINT,
  avgrlen          BIGINT,
  minvalue         VARCHAR(48),
  maxvalue         VARCHAR(48) );
```

##### 파라미터

| 이름       | 입출력 | 데이터 타입  | 설명                                                         |
| ---------- | ------ | ------------ | ------------------------------------------------------------ |
| *ownname*  | IN     | VARCHAR(128) | 테이블 소유자의 이름                                         |
| *tabname*  | IN     | VARCHAR(128) | 통계 자료를 조회할 테이블의 이름                             |
| *colname*  | IN     | VARCHAR(128) | 통계 자료를 조회할 칼럼의 이름                               |
| *partname* | IN     | VARCHAR(128) | 테이블의 파티션 이름. <br />파티션을 지정하면 해당 파티션에 대한 통계 자료만 조회한다. 기본값은 NULL이다. |
| *numdist*  | OUT    | BIGINT       | 칼럼에서 고유한 값의 개수. <br />수집된 통계 정보가 없는 경우 NULL 값이 반환된다. |
| *numnull*  | OUT    | BIGINT       | 칼럼에서 NULL의 개수. <br />수집된 통계 정보가 없는 경우 NULL 값이 반환된다. |
| *avgrlen*  | OUT    | BIGINT       | 칼럼의 평균 길이. <br />수집된 통계 정보가 없는 경우 NULL 값이 반환된다. |
| *minvalue* | OUT    | VARCHAR(48)  | 칼럼의 최소값. <br />수집된 통계 정보가 없는 경우 NULL 값이 반환된다. |
| *maxvalue* | OUT    | VARCHAR(48)  | 칼럼의 최대값. <br />수집된 통계 정보가 없는 경우 NULL 값이 반환된다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC GET_COLUMN_STATS('SYS', 'T1', 'I1', NULL, :v1,:v2,:v3,:v4,:v5);
Execute success.
```



#### GET_INDEX_STATS

이 프로시저는 인덱스에 대한 통계 자료를 조회한다.

##### 구문

```
GET_INDEX_STATS (
  ownname          VARCHAR(128),
  index            VARCHAR(128),
  partname         VARCHAR(128) DEFAULT NULL,
  keycnt           BIGINT,
  numpage          BIGINT,
  numdist          BIGINT,
  clstfct          BIGINT,
  idxheight        BIGINT,
  cachedpage       BIGINT,
  avgslotcnt       BIGINT );
```



##### 파라미터

| 이름         | 입출력 | 데이터 타입  | 설명                                                         |
| ------------ | ------ | ------------ | ------------------------------------------------------------ |
| *ownname*    | IN     | VARCHAR(128) | 인덱스 소유자의 이름                                         |
| *index*      | IN     | VARCHAR(128) | 통계 자료를 조회할 인덱스의 이름                             |
| *partname*   | IN     | VARCHAR(128) | 테이블의 파티션 이름. 파티션을 지정하면, 그 파티션에 대한 통계 자료만 수집한다. <br />입력하지 않을 경우의 기본값은 NULL이다. |
| *keycnt*     | OUT    | BIGINT       | 인덱스의 레코드 개수. <br />수집된 통계 정보가 없는 경우에는 NULL 값을 반환한다. |
| *numpage*    | OUT    | BIGINT       | 인덱스의 페이지 개수. <br />수집된 통계 정보가 없는 경우에는 NULL 값을 반환한다. |
| *numdist*    | OUT    | BIGINT       | 인덱스에서 고유한 키의 개수. <br />수집된 통계 정보가 없는 경우에는 NULL 값을 반환한다. |
| *clstfct*    | OUT    | BIGINT       | 인덱스에 부합하게 데이터가 정렬되어 있는 정도. <br />수집된 통계 정보가 없는 경우에는 NULL 값을 반환한다. |
| *idxheight*  | OUT    | BIGINT       | 인덱스의 루트에서 리프 노드까지의 깊이. <br />수집된 통계 정보가 없는 경우에는 NULL 값을 반환한다. |
| *cachedpage* | OUT    | BIGINT       | 데이터베이스 버퍼에 캐쉬된 페이지의 개수. <br />수집된 통계 정보가 없는 경우에는 NULL 값을 반환한다. |
| avgslotcnt   | OUT    | BIGINT       | 인덱스 리프 노드에 저장된 레코드의 평균 개수. <br />수집된 통계 정보가 없는 경우에는 NULL 값을 반환한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC GET_INDEX_STATS('SYS', 'IDX1' null,:v1,:v2,:v3,:v4,:v5,:v6,:v7);
Execute success.
```



#### GET_SYSTEM_STATS

이 프로시저는 데이터베이스 시스템에 대한 통계 자료를 조회한다.

##### 구문

```
GET_SYSTEM_STATS (
  statname            VARCHAR(100),
  statvalue           DOUBLE);
```



##### 파라미터

| 이름        | 입출력 | 데이터 타입  | 설명                                                         |
| ----------- | ------ | ------------ | ------------------------------------------------------------ |
| *statname*  | IN     | VARCHAR(100) | 조회할 시스템 통계 정보의 이름이다. 아래의 값 중에서 하나를 입력해야 한다. <br />SREAD_TIME: 하나의 페이지를 읽는 평균 소요 시간<br />MREAD_TIME: 여러 페이지를 읽는 평균 소요 시간<br />MREAD_PAGE_COUNT: 한번에 읽어 온 페이지 개수<br />HASH_TIME : 평균 해시 수행 시간<br />COMPARE_TIME : 평균 비교 수행 시간<br />STORE_TIME: 평균 메모리 임시 테이블 저장 수행 시간 |
| *statvalue* | IN     | DOUBLE       | 시스템 통계 정보의 값.<br />수집된 통계 정보가 없을 경우에는 NULL 값을 반환한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC GET_SYSTEM_STATS('SREAD_TIME', :v1);
Execute success.
```

#### GET_TABLE_STATS

이 프로시저는 테이블에 대한 통계 자료를 조회한다.

##### 구문

```
GET_TABLE_STATS (
ownname          VARCHAR(128),
tabname          VARCHAR(128),
partname         VARCHAR(128) DEFAULT NULL,
numrow            BIGINT,
numpage           BIGINT,
avgrlen           BIGINT,
cashedpage       BIGINT,
onerowreadtime   DOUBLE );
```

##### 파라미터

| 이름             | 입출력 | 데이터 타입  | 설명                                                                                                                   |
|------------------|--------|--------------|------------------------------------------------------------------------------------------------------------------------|
| *ownname*        | IN     | VARCHAR(128) | 테이블 소유자의 이름                                                                                                   |
| *tabname*        | IN     | VARCHAR(128) | 통계 자료를 조회할 테이블의 이름                                                                                       |
| *partname*       | IN     | VARCHAR(128) | 테이블의 파티션 이름. 파티션을 지정하면 해당 파티션에 대한 통계 자료만 조회된다. 입력하지 않을 경우 기본값은 NULL이다. |
| *numrow*         | OUT    | BIGINT       | 테이블의 레코드 개수 수집된 통계 정보가 없는 경우 NULL 값이 반환된다.                                                  |
| *numpage*        | OUT    | BIGINT       | 테이블의 페이지 개수 수집된 통계 정보가 없는 경우 NULL 값이 반환된다.                                                  |
| *avgrlen*        | OUT    | BIGINT       | 테이블의 레코드 평균 길이 수집된 통계 정보가 없는 경우 NULL 값이 반환된다.                                             |
| *cashedpage*     | OUT    | BIGINT       | 데이터베이스 버퍼에 캐쉬된 페이지의 개수 수집된 통계 정보가 없는 경우 NULL 값이 반환된다.                              |
| *onerowreadtime* | OUT    | DOUBLE       | 테이블의 레코드를 읽는 평균 시간 수집된 통계 정보가 없는 경우 NULL 값이 반환된다.                                      |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC GET_TABLE_STATS('SYS', 'T1', NULL, :v1,:v2,:v3,:v4,:v5);
Execute success.
```



#### DELETE_COLUMN_STATS

이 프로시저는 테이블의 칼럼에 대한 통계 자료를 삭제한다.

##### 구문

```
DELETE_COLUMN_STATS (
ownname          VARCHAR(128),
tabname          VARCHAR(128),
colname          VARCHAR(128),
partname         VARCHAR(128) DEFAULT NULL,
cascade_part    BOOLEAN DEFAULT TRUE,
no_invalidate   BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름            | 입출력 | 데이터 타입  | 설명                                                                                                                                                                                                                                                                                                                                          |
|-----------------|--------|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *ownname*       | IN     | VARCHAR(128) | 테이블 소유자의 이름                                                                                                                                                                                                                                                                                                                          |
| *tabname*       | IN     | VARCHAR(128) | 통계 자료를 삭제할 칼럼이 속해 있는 테이블                                                                                                                                                                                                                                                                                                    |
| *colname*       | IN     | VARCHAR(128) | 통계 자료를 삭제할 칼럼의 이름                                                                                                                                                                                                                                                                                                                |
| *partname*      | IN     | VARCHAR(128) | 통계 자료를 삭제할 테이블 파티션의 이름. 파티션을 지정하면 *cascade_part* 값에 상관없이 지정한 파티션의 지정한 칼럼에 대한 통계 자료만 삭제된다. 만약 NULL인 경우, *cascade_part* 값에 따라 삭제될 칼럼 통계 자료가 결정된다.                                                                                                                 |
| *cascade_part*  | IN     | BOOLEAN      | *tabname*에 파티션드 테이블을 지정하고, *partname*이 NULL일 경우 이 값에 따라 삭제될 칼럼 통계 자료가 결정된다. 이 값이 TRUE이면 파티션드 테이블의 전체적인 칼럼 통계 자료 뿐만 아니라 테이블의 모든 파티션에 해당하는 칼럼의 통계 자료도 삭제된다. FALSE를 입력하면 파티션드 테이블의 전체적인 칼럼 통계 자료만 삭제한다. 기본값은 TRUE이다. |
| *no_invalidate* | IN     | BOOLEAN      | 통계 자료가 삭제된 테이블들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부이다. 기본값은 FALSE이며, 실행 계획을 재구축한다. TRUE를 입력하면, 실행계획을 재구축하지 않는다.                                                                                                                                                                |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC DELETE_COLUMN_STATS('SYS', 'T1', 'I1');
Execute success.
```



#### DELETE_DATABASE_STATS

이 프로시저는 데이터베이스에 존재하는 모든 테이블에 대한 통계 자료를 삭제한다.

##### 구문

```
DELETE_DATABASE_STATS (
no_invalidate       BOOLEAN DEFAULT FALSE);
```



##### 파라미터

| 이름            | 입출력 | 데이터 타입 | 설명                                                         |
| --------------- | ------ | ----------- | ------------------------------------------------------------ |
| *no_invalidate* | IN     | BOOLEAN     | 통계 자료를 삭제한 테이블들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부이다. <br />입력하지 않을 경우에 기본값은 FALSE로, 실행 계획을 재구축하지 않는다. TRUE를 입력하면, 실행 계획을 재구축한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC DELETE_DATABASE_STATS();
SYSTEM_.SYS_TABLES_
SYSTEM_.SYS_COLUMNS_
SYSTEM_.SYS_DATABASE_
SYSTEM_.SYS_USERS_
.
.
.
Execute success.
```



#### DELETE_INDEX_STATS

이 프로시저는 특정 인덱스에 대한 통계 자료를 삭제한다.

##### 구문

```
DELETE_INDEX_STATS (
ownname              VARCHAR(128),
idxname              VARCHAR(128),
no_invalidate        BOOLEAN DEFAULT FALSE);
```



##### 파라미터

| 이름            | 입출력 | 데이터 타입  | 설명                                                         |
| --------------- | ------ | ------------ | ------------------------------------------------------------ |
| *ownname*       | IN     | VARCHAR(128) | 인덱스 소유자의 이름                                         |
| *idxname*       | IN     | VARCHAR(128) | 통계 자료를 삭제할 인덱스의 이름                             |
| *no_invalidate* | IN     | BOOLEAN      | 통계 자료를 삭제한 테이블들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부이다. <br />기본값은 FALSE로, 실행 계획을 재구축한다. 실행 계획을 재구축하지 않으려면 TRUE를 입력한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC DELETE_INDEX_STATS('SYS','T1_IDX');
Execute success.
```



#### DELETE_SYSTEM_STATS

이 프로시저는 데이터베이스 시스템에 대한 통계 자료를 삭제한다. 이 저장
프로시저는 SYS 사용자만이 수행할 수 있다.

##### 구문

```
DELETE_SYSTEM_STATS ( );
```



##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC DELETE_SYSTEM_STATS();
Execute success.
```



#### DELETE_TABLE_STATS

이 프로시저는 특정 테이블과 그 테이블에 정의된 칼럼, 인덱스들에 대한 통계 자료를
삭제한다.

##### 구문

```
DELETE_TABLE_STATS (
ownname           VARCHAR(128),
tabname           VARCHAR(128),
partname          VARCHAR(128) DEFAULT NULL,
cascade_part      BOOLEAN DEFAULT TRUE,
cascade_column    BOOLEAN DEFAULT TRUE,
cascade_index     BOOLEAN DEFAULT TRUE,
no_invalidate     BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름             | 입출력 | 데이터 타입  | 설명                                                         |
| ---------------- | ------ | ------------ | ------------------------------------------------------------ |
| *ownname*        | IN     | VARCHAR(128) | 테이블 소유자의 이름                                         |
| *tabname*        | IN     | VARCHAR(128) | 통계 자료를 삭제할 테이블의 이름                             |
| *partname*       | IN     | VARCHAR(128) | 통계 자료를 삭제할 테이블 파티션의 이름. <br />파티션을 지정하면, *casdace_part* 값에 상관없이 해당 파티션의 통계 자료만 삭제된다. <br />이 값이 NULL이고 지정한 테이블이 파티션드 테이블인 경우, *casdace_part* 값에 따라 삭제될 테이블 통계 자료가 결정된다. |
| *cascade_part*   | IN     | BOOLEAN      | *tabname*이 파티션드 테이블이고 *partname*이 NULL일 경우, 이 값이 TRUE이면 전체적인 테이블 통계 자료 뿐만 아니라 테이블의 모든 파티션의 통계 자료도 삭제된다. <br />이 값이 FALSE이면 지정한 테이블의 통계 자료만 삭제된다. 기본값은 TRUE이다. |
| *cascade_column* | IN     | BOOLEAN      | 지정한 테이블의 통계 자료 뿐만 아니라, 지정한 테이블에 속한 모든 칼럼의 통계 자료도 삭제할지 여부이다. <br />기본값은 TRUE이며, 지정한 테이블과 테이블의 모든 칼럼의 통계 자료도 삭제한다. <br />이 값이 FALSE이면 지정한 테이블의 통계 자료만 삭제한다. |
| *cascade_index*  | IN     | BOOLEAN      | 지정한 테이블의 통계 자료 뿐만 아니라, 지정한 테이블에 속한 모든 인덱스의 통계 자료도 삭제할지 여부이다. <br />기본값은 TRUE이며, 지정한 테이블과 테이블의 모든 인덱스의 통계 자료도 삭제한다. FALSE가 입력되면 지정한 테이블의 통계 자료만 삭제한다. |
| *no_invalidate*  | IN     | BOOLEAN      | 통계 자료를 삭제한 테이블들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부이다. <br />기본값은 FALSE로, 실행 계획을 재구축한다. 실행 계획을 재구축하지 않으려면 TRUE를 입력한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예제

```
iSQL> EXEC DELETE_TABLE_STATS( 'SYS','T1');
Execute success.
```



### 그 외 함수들

#### REMOVE_XID

XA 환경에서 “heuristically completed” 된 (데이터베이스 서버에 의해 임의로 롤백
되거나 커밋 된) 트랜잭션의 XID 정보를 강제로 삭제한다.

##### 구문

```
REMOVE_XID (xidname     IN VARCHAR(256));
```



##### 파라미터

| 이름      | 입출력 | 데이터 타입  | 설명              |
|-----------|--------|--------------|-------------------|
| *xidname* | IN     | VARCHAR(256) | 삭제할 XID의 이름 |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

REMOVE_XID는 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   NOT_EXIST_XID

-   InvalidXaState

#### REFRESH_MATERIALIZED_VIEW

베이스 테이블의 데이터 변경 사항을 materialized view에 반영하는 저장
프로시저이다. 즉, 이 저장 프로시저를 실행하면 해당 materialized view의 데이터가
베이스 테이블의 최신 데이터로 갱신된다.

리프레쉬 하려는 materialized view의 소유자가 아닌 사용자가 이 저장 프로시저를
실행하려면 아래의 권한이 있어야 한다:

-   ALTER ANY MATERIALIZED VIEW 시스템 권한

-   SELECT ANY TABLE 시스템 권한 또는 materialized view 를 위해 자동으로 생성된
    뷰에 대한 SELECT 객체 권한

-   INSERT ANY TABLE 및 DELETE ANY TABLE 시스템 권한, 또는 materialized view를
    위해 자동으로 생성된 테이블에 대한 INSERT 및 DELETE 객체 권한

##### 구문

```
REFRESH_MATERIALIZED_VIEW (
owner_name        IN VARCHAR(128),
mview_name        IN VARCHAR(128));
```

##### 파라미터

| 이름         | 입출력 | 데이터 타입  | 설명                            |
|--------------|--------|--------------|---------------------------------|
| *owner_name* | IN     | VARCHAR(128) | Materialized view의 소유자 이름 |
| *mview_name* | IN     | VARCHAR(128) | Materialized view의 이름        |

##### 결과값

저장 프로시저이므로 반환되는 결과값이 없다.

##### 예외

-   권한 부재로 인한 SELECT, DELETE, 또는 INSERT 실패 예외

-   테이블스페이스 공간 부족, materialized view 최대 행 초과 등의 예외

-   아래 주의 사항과 관련한 예외

##### 주의 사항

아래의 몇 가지 이유로 리프레쉬가 실패할 수 있다.

-   사용자가 베이스 테이블의 정의를 변경하거나 테이블을 삭제한 경우

-   사용자가 ALTER TABLE 구문을 사용하여 materialized view를 위해 자동으로
    생성된 테이블의 정의를 변경한 경우

-   Lock Timeout이 발생하는 경우

-   테이블 제약 조건(constratints)에 대한 위반이 발생하는 경우

#### SET_CLIENT_INFO

V\$SESSION의 CLIENT_APP_INFO 칼럼과 CLIENT_INFO 칼럼정보를 설정한다.

##### 구문

```
SET_CLIENT_INFO (client_info IN VARCHAR(128));
```



##### 파라미터

| 이름          | 입출력 | 데이터 타입  | 설명            |
| ------------- | ------ | ------------ | --------------- |
| *client_info* | IN     | VARCHAR(128) | 클라이언트 정보 |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

이 프로시저는 예외를 발생시키지 않는다.

#### SET_MODULE

V\$SESSION에 MODULE칼럼과 ACTION 칼럼의 정보를 설정한다.

##### 구문

```
SET_MODULE (module IN VARCHAR(128),action IN VARCHAR(128));
```



##### 파라미터

| 이름     | 입출력 | 데이터 타입  | 설명          |
|----------|--------|--------------|---------------|
| *module* | IN     | VARCHAR(128) | 모듈 정보     |
| *action* | IN     | VARCHAR(128) | 모듈 활성정보 |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

이 프로시저는 예외를 발생시키지 않는다.

#### SLEEP

이 프로시저는 seconds 인자에 지정한 초만큼 세션을 쉬게 한다.

##### 구문

```
SLEEP (seconds IN INTEGER);
```



##### 파라미터

| 이름      | 입출력 | 데이터 타입 | 설명           |
| --------- | ------ | ----------- | -------------- |
| *seconds* | IN     | INTEGER     | 쉬는 시간 (초) |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

이 프로시저는 예외를 발생시키지 않는다.



