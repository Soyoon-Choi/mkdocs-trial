# 13.Altibase 저장 패키지

이 장에서는 Altibase가 제공하는 저장 패키지에 대해 설명한다.

### 시스템 정의 저장 패키지

시스템 정의 저장 패키지는 Altibase에서 기본으로 제공하는 패키지로써, SYS
사용자의 소유가 된다.

#### 시스템 패키지의 종류

Altibase에서 제공하는 패키지는 아래와 같다.

| 패키지                                               | 설명                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| [DBMS_APPLICATION_INFO](#dbms_application_info)      | 클라이언트의 애플리케이션 정보를 관리하기 위해 성능 뷰의 값을 설정한다. |
| [DBMS_ALERT](#dbms_alert)                            | 데이터베이스에 발생하는 이벤트를 다른 사용자에게 알린다.     |
| [DBMS_CONCURRENT_EXEC](#dbms_concurrent_exec-패키지) | 프로시저를 동시에 실행한다.                                  |
| [DBMS_LOCK](#dbms_lock)                              | 사용자가 잠금(Lock)을 요청하거나 해제한다.                   |
| [DBMS_METADATA](#dbms_metadata)                      | 데이터베이스 딕셔너리로부터 객체 생성 DDL 구문 또는 권한 GRANT 구문을 추출하는 기능을 제공한다. |
| [DBMS_OUPUT](#dbms_output)                           | 버퍼에 저장된 문자열을 사용자가 클라이언트에게 출력한다.     |
| [DBMS_RANDOM](#dbms_random)                          | 임의의 숫자를 생성한다.                                      |
| [DBMS_RECYCLEBIN](#dbms_recyclebin-패키지)           | 삭제(Drop)되어 휴지통에서 관리되고 있는 테이블을 시스템에서 완전히 삭제(Purge)한다. |
| [DBMS_SQL](#dbms_sql)                                | 동적 SQL을 사용한다.                                         |
| [DBMS_SQL_PLAN_CACHE](#dbms_sql_plan_cache)          | 특정 실행 계획(Execution Plan)을 SQL Plan Cache에 유지하거나 삭제하는 기능을 하는 저장 프로시저를 제공한다. |
| [DBMS_STATS](#dbms_stats)                            | 통계 정보를 조회 및 변경한다.                                |
| [DBMS_STANDARD](#dbms_standard)                      | 다양한 기본 서브프로그램을 제공한다.                         |
| [DBMS_UTILITY](#dbms_utility)                        | 다양한 유틸리티 서브프로그램을 제공한다.                     |
| [STANDARD](#standard)                                | 기본 데이터 타입 외에 PSM내에서 별도의 선언없이 사용할 수 있는 타입을 정의한다. |
| [SYS_SPATIAL](#sys_spatial)                          | Geometry에 관련 서브프로그램을 제공한다.                     |
| [UTL_COPYSWAP](#utl_copyswap)                        | Copy & Swap 방식으로 Online DDL을 지원한다.                  |
| [UTL_FILE](#standard)                                | 운영 체제에서 관리하는 텍스트 파일을 읽고(Read) 쓴다(Write). |
| [UTL_RAW](#utl_raw)                                  | RAW(VARBYTE) 타입의 데이터를 다른 데이터 타입으로 변환한다.  |
| [UTL_SMTP](#utl_smtp)                                | SMTP 서버로 EMAIL을 전송하도록, SMTP 프로토콜을 수행한다.    |
| [UTL_TCP](#utl_tcp)                                  | 저장 프로시저에서 TCP 접속을 제어한다.                       |

### DBMS_APPLICATION_INFO

DBMS_APPLICATION_INFO 패키지는 V\$SESSION 성능 뷰의 값들을 설정하거나 가져와서,
애플리케이션의 성능을 추적 및 관리한다.

DBMS_APPLICATION_INFO 패키지를 구성하는 프로시저와 함수는 아래의 표와 같이
제공한다.

| 프로시저 및 함수 | 설명                                           |
|------------------|------------------------------------------------|
| READ_CLIENT_INFO | V\$SESSION에 설정된 모듈과 액션 값을 가져온다. |
| READ_MODULE      | V\$SESSION에 설정된 모듈과 액션 값을 가져온다. |
| SET_ACTION       | V\$SESSION의 ACTION 값을 설정한다.             |
| SET_CLIENT_INFO  | V\$SESSION의 CLIENT_INFO 값을 설정한다.        |
| SET_MODULE       | V\$SESSION의 MODULE 및 ACTION 값을 설정한다.   |

#### READ_CLIENT_INFO

현재 세션에 접속한 클라이언트의 애플리케이션 정보를 가져온다.

##### 구문

```
DBMS_APPLICATION_INFO.READ_CLIENT_INFO(client_info OUT VARCHAR(128));
```



##### 파라미터

| 이름          | 입출력 | 데이터 타입  | 설명                                  |
|---------------|--------|--------------|---------------------------------------|
| *client_info* | OUT    | VARCHAR(128) | 설정된 클라이언트의 애플리케이션 정보 |

##### 결과값

커서를 실행하여 처리된 레코드의 개수를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

현재 세션에서 수행중인 클라이언트의 정보 값을 가져와 출력한다.

```
iSQL> var v1 varchar(128);
iSQL> EXEC DBMS_APPLICATION_INFO.READ_CLIENT_INFO(:v1);
iSQL> EXEC PRINTLN(:v1);
```



#### READ_MODULE

V\$SESSION 성능 뷰에 설정된 MODULE 및 ACTION의 값을 가져온다.

##### 구문

```
DBMS_APPLICATION_INFO.READ_MODULE(module_name OUT VARCHAR(128), action_name OUT VARCHAR(128));
```



##### 파라미터

| 이름          | 입출력 | 데이터 타입  | 설명             |
|---------------|--------|--------------|------------------|
| *module_name* | OUT    | VARCHAR(128) | 설정된 모듈의 값 |
| *action_name* | OUT    | VARCHAR(128) | 설정된 액션의 값 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

수행중인 프로시저의 모듈명과 액션 값을 가져와 출력한다.

```
iSQL> var v1 varchar(128);
iSQL> var v2 varchar(128)
iSQL> EXEC DBMS_APPLICATION_INFO.READ_MODEUL(:v1, :v2);
iSQL> EXEC PRINTLN(:v1);
iSQL> EXEC PRINTLN(:v2);
```



#### SET_ACTION

V\$SESSION 성능 뷰에 있는 ACTION 칼럼의 값을 설정하는 프로시저이다.

##### 구문

```
DBMS_APPLICATION_INFO.SET_ACTION (action_name VARCHAR(128));
```



##### 파라미터

| 이름          | 입출력 | 데이터 타입  | 설명                    |
|---------------|--------|--------------|-------------------------|
| *action_name* | IN     | VARCHAR(128) | 설정할 ACTION 칼럼의 값 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

수행중인 프로시저의 동작 상태를 stop으로 변경한다.

```
iSQL> EXEC DBMS_APPLICATION_INFO.SET_ACTION( 'stop');
```



#### SET_CLIENT_INFO

V\$SESSION 성능 뷰에 접속된 클라이언트의 정보를 설정한다.

##### 구문

```
DBMS_APPLICATION_INFO.SET_CLIENT_INFO(client_info VARCHAR(128));
```



##### 파라미터

| 이름          | 입출력 | 데이터 타입  | 설명                           |
|---------------|--------|--------------|--------------------------------|
| *client_info* | IN     | VARCHAR(128) | 클라이언트의 애플리케이션 정보 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

클라이언트 정보를 test_application으로 설정한다.

```
iSQL> EXEC DBMS_APPLICATION_INFO.SET_CLIENT_INFO('test_application');
```



#### SET_MODULE

V\$SESSION 성능 뷰의 MODULE 및 ACTION 칼럼의 값을 설정하는 프로시저이다.

##### 구문

```
DBMS_APPLICATION_INFO.SET_MODULE(module_name VARCHAR(128), action_name
VARCHAR(128));
```

##### 파라미터

| 이름          | 입출력 | 데이터 타입  | 설명             |
|---------------|--------|--------------|------------------|
| *module_name* | IN     | VARCHAR(128) | 설정할 모듈의 값 |
| *action_name* | IN     | VARCHAR(128) | 설정할 액션의 값 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

수행중인 프로시저의 모듈명을 altibase_module로 동작 상태를 running으로 변경한다.

```
iSQL> EXEC DBMS_APPLICATION_INFO.SET_MODULE('altibase_module', 'running');
```



### DBMS_ALERT

DBMS_ALERT패키지는 데이터베이스에 발생하는 이벤트를 다른 사용자에게 알리는
기능이며 인터페이스 형태로 지원한다.

| 프로시저 및 함수 | 설명                         |
|------------------|------------------------------|
| REGISTER         | 알람을 등록한다.             |
| REMOVE_EVENT     | 특정 알람을 해제한다..       |
| REMOVEALL        | 모든 알람을 해제한다.        |
| SET_DEFAULTS     | 알람의 대기 시간을 설정한다. |
| SIGNAL           | 알람에게 신호를 전달한다.    |
| WAITANY          | 모든 알람을 대기한다.        |
| WAITONE          | 특정 알람을 대기한다.        |

#### REGISTER

알람을 등록한다.

##### 구문

DBMS_ALERT.REGISTER( *name* );

##### 파라미터

| 이름   | 입출력 | 데이터 타입  | 설명      |
|--------|--------|--------------|-----------|
| *name* | IN     | VARCHAR2(30) | 알람 이름 |

##### 결과값

없음

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> EXEC DBMS_ALERT.REGISTER (‘S1’);
```



#### REMOVE_EVENT

등록되어 있는 특정 알람을 해제한다. 해제된 알람은 신호를 받을 수 없다.

##### 구문

```
DBMS_ALERT.REMOVE_EVENT( name );
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입  | 설명      |
|------|--------|--------------|-----------|
| name | IN     | VARCHAR2(30) | 알람 이름 |

##### 결과값

없음

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> EXEC DBMS_ALERT.REMOVE_EVENT (‘S1’);
```



#### REMOVEALL

등록되어 있는 모든 알람을 해제한다. 해제된 알람은 신호를 받을 수 없다.

##### 구문

```
DBMS_ALERT.REMOVEALL();
```



##### 파라미터

없음

##### 결과값

없음

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
EXEC DBMS_ALERT.REMOVEALL ();
```



#### SET_DEFAULTS

알람이 기다리는 시간을 설정한다.

##### 구문

```
DBMS_ALERT.SET_DEFAULTS( poll_interval );
```



##### 파라미터

| 이름            | 입출력 | 데이터 타입 | 설명                        |
|-----------------|--------|-------------|-----------------------------|
| *poll_interval* | IN     | INTEGER     | 알람의 대기 시간 (단위: 초) |

##### 결과값

없음

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
EXEC DBMS_ALERT.SET_DEFAULTS (5);
```



#### SIGNAL

알람에게 메시지가 포함된 신호를 보낸다. 신호를 여러 번 보낼 수 있다. 등록된
알람만 신호를 받을 수 있다.

##### 구문

```
DBMS_ALERT.SIGNAL( name, message );
```



##### 파라미터

| 이름      | 입출력 | 데이터 타입    | 설명      |
|-----------|--------|----------------|-----------|
| *name*    | IN     | VARCHAR2(30)   | 알람 이름 |
| *message* | IN     | VARCHAR2(1800) | 메시지    |

##### 결과값

없음

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
EXEC DBMS_ALERT.SIGNAL (‘S1’, 'MESSAGE 001’);
```



#### WAITANY

모든 알람이 신호를 기다린다. 등록되어 있는 알람만 신호를 받을 수 있으며, 신호를
받지 않은 상태에서 일정시간(timeout)이 지나면 프로시저가 종료된다.

##### 구문

```
DBMS_ALERT.WAITANY( name, message, status, timeout );
```



##### 파라미터

| 이름      | 입출력 | 데이터 타입    | 설명                                 |
|-----------|--------|----------------|--------------------------------------|
| *name*    | OUT    | VARCHAR2(30)   | 알람 이름                            |
| *message* | OUT    | VARCHAR2(1800) | 메시지                               |
| *status*  | OUT    | INTEGER        | 상태 (성공: 0, 실패: 1)              |
| *timeout* | IN     | INTEGER        | 알람의 대기 시간(Timeout) (단위: 초) |

##### 결과값

없음

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
VAR MESSAGE VARCHAR (1800);
VAR STATUS INTEGER;
EXEC DBMS_ALERT.WAITANY ( :NAME, :MESSAGE, :STATUS, 5 );
```



#### WAITONE

특정 알람이 신호를 기다린다. 등록되어 있는 알람만 신호를 받을 수 있으며, 신호를
받지 않은 상태에서 일정시간(timeout)이 지나면 프로시저가 종료된다.

##### 구문

```
DBMS_ALERT.WAITONE( name, message, status, timeout );
```



##### 파라미터

| 이름      | 입출력 | 데이터 타입    | 설명                                 |
|-----------|--------|----------------|--------------------------------------|
| *name*    | OUT    | VARCHAR2(30)   | 알람 이름                            |
| *message* | OUT    | VARCHAR2(1800) | 메시지                               |
| *status*  | OUT    | INTEGER        | 상태 (성공: 0, 실패: 1)              |
| *timeout* | IN     | INTEGER        | 알람의 대기 시간(Timeout) (단위: 초) |

##### 결과값

없음

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
VAR NAME VARCHAR (30);
VAR MESSAGE VARCHAR (1800);
VAR STATUS INTEGER;
EXEC :name := 'S1';
EXEC DBMS_ALERT.WAITONE ( :NAME, :MESSAGE, :STATUS, 5 );
```



### DBMS_CONCURRENT_EXEC 패키지

DBMS_CONCURRENT_EXEC 패키지는 프로시저를 동시에 실행할 수 있는 기능을 제공한다.
이 기능은 시스템 정의 저장 패키지 형태로 제공된다.

#### DBMS_CONCURRENT_EXEC의 프로시저와 함수

DBMS_CONCURRENT_EXEC 패키지를 구성하는 프로시저와 함수는 아래의 표에 목록화되어
있다.

| 프로시저/함수   | 설명                                                                                        |
|-----------------|---------------------------------------------------------------------------------------------|
| INITIALIZE      | DBMS_CONCURRENT_EXEC 패키지를 초기화하고, 프로시저를 동시에 실행할 수 있는 개수를 설정한다. |
| REQUEST         | DBMS_CONCURRENT_EXEC 패키지에서 프로시저의 실행을 요청한다.                                 |
| WAIT_ALL        | DBMS_CONCURRENT_EXEC 패키지에서 요청한 모든 프로시저가 완료하기를 기다린다.                 |
| WAIT_REQ        | 요청된 Request ID에 해당하는 프로시저 동작이 완료하기를 기다린다.                           |
| GET_ERROR_COUNT | 요청한 프로시저 동작 중 발생한 오류 개수를 반환한다.                                        |
| GET_ERROR       | Request ID에 해당하는 프로시저 실행 구문, 오류 코드, 오류 메시지를 가져온다.                |
| PRINT_ERROR     | Request ID에 해당하는 프로시저 실행 구문, 오류 코드, 오류 메시지를 출력한다.                |
| GET_LAST_REQ_ID | 마지막으로 패키지에서 수행이 성공한 Request ID를 반환한다.                                  |
| GET_REQ_TEXT    | Request ID에 해당하는 프로시저 실행 구문을 반환한다.                                        |
| FINALIZE        | DBMS_CONCURRENT_EXEC 패키지를 실행한 메모리를 시스템에 반납하고, 패키지는 초기화한다.       |

#### 관련 프로퍼티

DBMS_CONCURRENT_EXEC 관련 프로퍼티를 altibase.properties에 설정할 수 있다.

-   CONCURRENT_EXEC_DEGREE_MAX

-   CONCURRENT_EXEC_DEGREE_DEFAULT

-   CONCURRENT_EXEC_WAIT_INTERVAL

더 자세한 정보는 *General Reference*를 참고한다.

#### 제약 사항

DBMS_CONCURRENT_EXEC 패키지를 사용할 때 제약사항은 다음과 같다.

-   결과를 반환하지 않는 프로시저만 실행할 수 있으나, 결과를 반환하는 함수는
    실행할 수 없다.

-   파라미터의 입출력 형태가 OUT 속성인 프로시저는 실행할 수 없다.

-   패키지의 프로시저나 함수를 재귀적으로 호출할 수 없다. 재귀적인 호출을 할
    경우 RECURSIVE_CALL_IS_NOT_ALLOWED 예외가 발생한다.

-   병렬 질의(Parallel Query)에서는 사용할 수 없다.

-   DBMS_CONCURRENT_EXEC 패키지에서 실행하는 프로시저는 PRINT, PRINTLN을
    이용하여 화면에 출력할 수 없다. 출력할 내용은
    \$ALTIBASE_HOME/trc/altibase_qp.log에 저장한다.

#### INITIALIZE

DBMS_CONCURRENT_EXEC 패키지를 초기화하고, 병렬로 처리할 수 있는 프로시저의
개수를 설정한다. 병렬 처리될 프로시저의 개수를 지정하지 않으면,
CONCURRENT_EXEC_DEGREE_DEFAULT 프로퍼티에 설정된 값이 적용된다. 병렬로 처리될 수
있는 프로시저의 최대 개수는 CONCURRENT_EXEC_DEGREE_MAX 프로퍼티에서 설정한 값을
초과할 수 없다. 하지만 다른 세션에서 CONCURRENT_EXEC_DEGREE_MAX 프로퍼티의 설정
개수만큼 이미 사용하고 있다면, 0을 반환하고 동작하지 않는다.

##### 구문

```
INTERGER variable :=
  DBMS_CONCURRENT_EXEC.INITIALIZE (in_degree INTEGER DEFAULT NULL );
```

##### 파라미터

| 이름       | 입출력 | 데이터 타입 | 설명                          |
|------------|--------|-------------|-------------------------------|
| *in_dgree* | IN     | INTEGER     | 병렬로 처리할 프로시저의 개수 |

##### 결과값

성공적으로 수행할 경우 설정한 프로시저의 개수(DEGREE)를 반환한다. 그러나
서버에서 프로시저를 처리할 자원을 할당받지 못한 경우, 0을 반환한다.

##### 예외

DBMS_CONCURRENT_EXEC 패키지에서 실행되는 프로시저가 INITIALIZE를 호출하는 경우
다음의 예외가 발생할 수 있다.

```
RECURSIVE_CALL_IS_NOT_ALLOWED
```



##### 예제

DBMS_CONCURRENT_EXEC 패키지를 초기화하면서, 병렬로 처리할 프로시저의 개수를
4개로 지정한다.

```
VARIABLE OUT_DEGREE INTEGER;
EXEC :OUT_DEGREE := DBMS_CONCURRENT_EXEC.INITIALIZE(4);
```



#### REQUEST

DBMS_CONCURRENT_EXEC 패키지에 프로시저 실행을 요청한다.

##### 구문

```
INTERGER variable :=
  DBMS_CONCURRENT_EXEC.REQUEST(text VARCHAR(8192) );
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입   | 설명                                    |
|--------|--------|---------------|-----------------------------------------|
| *text* | IN     | VARCHAR(8192) | 실행할 프로시저를 인자와 함께 입력한다. |

##### 결과값

요청에 성공하면 즉시 Request ID를 반환한다. Request ID는 DBMS_CONCURRENT_EXEC
패키지에서 관리한다.

요청에 실패하면 -1을 반환한다. 그러나 프로시저의 실행에 실패하여도, Request ID를
가져올 수 있으며, 프로시저가 실행될 때 발생한 오류는 GET_ERROR 함수를 사용하여
확인할 수 있다.

##### 예외

DBMS_CONCURRENT_EXEC 패키지에서 실행되는 프로시저가 이 함수를 호출하는 경우
다음의 예외가 발생할 수 있다.

```
RECURSIVE_CALL_IS_NOT_ALLOWED
```



##### 예제

DBMS_CONCURRENT_EXEC 패키지에서 프로시저들을 병렬로 실행되도록 요청한다.

```
VARIABLE REQ_ID1 INTEGER;
VARIABLE REQ_ID2 INTEGER;
VARIABLE REQ_ID3 INTEGER;
VARIABLE REQ_ID4 INTEGER;
EXEC :REQ_ID1 := DBMS_CONCURRENT_EXEC.REQUEST('PROC1');
EXEC :REQ_ID2 := DBMS_CONCURRENT_EXEC.REQUEST('PROC2(1, 1, 3)');
EXEC :REQ_ID3 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''ABC'', 3, 3)');
EXEC :REQ_ID4 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''DEF'', 3, 3)');
```



#### WAIT_ALL

DBMS_CONCURRENT_EXEC 패키지를 이용하여 병렬로 수행을 요청한 프로시저의 동작이
모두 완료될 때까지 대기한다.

##### 구문

```
INTERGER variable :=
  DBMS_CONCURRENT_EXEC.WAIT_ALL(  );
```

##### 결과값

성공적으로 수행할 경우 1을 반환한다. 실패한 경우 -1을 반환한다.

##### 예외

DBMS_CONCURRENT_EXEC 패키지에서 실행하는 프로시저에서 WAIT_ALL을 호출하는 경우
다음의 예외가 발생할 수 있다.

```
RECURSIVE_CALL_IS_NOT_ALLOWED
```



##### 예제

아래는 DBMS_CONCURRENT_EXEC 패키지에서 요청한 프로시저들이 모두 완료될 때까지
기다리는 예제이다.

```
VARIABLE RC INTEGER;
VARIABLE REQ_ID1 INTEGER;
VARIABLE REQ_ID2 INTEGER;
VARIABLE REQ_ID3 INTEGER;
VARIABLE REQ_ID4 INTEGER;
EXEC :REQ_ID1 := DBMS_CONCURRENT_EXEC.REQUEST('PROC1');
EXEC :REQ_ID2 := DBMS_CONCURRENT_EXEC.REQUEST('PROC2(1, 1, 3)');
EXEC :REQ_ID3 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''ABC'', 3, 3)');
EXEC :REQ_ID4 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''DEF'', 3, 3)');
EXEC :RC := DBMS_CONCURRENT_EXEC.WAIT_ALL( );
```



#### WAIT_REQ

DBMS_CONCURRENT_EXEC 패키지에서 병렬로 처리중인 특정 프로시저의 동작이 완료될
때까지 대기한다.

##### 구문

```
INTERGER variable :=  
  DBMS_CONCURRENT_EXEC.WAIT_REQ( req_id INTEGER);
```



##### 파라미터

| 이름     | 입출력 | 데이터 타입 | 설명                            |
|----------|--------|-------------|---------------------------------|
| *req_id* | IN     | INTEGER     | 패키지로 실행되는 프로시저의 ID |

##### 결과값

성공적으로 수행한 경우 1을 반환한다.

해당 Request ID가 존재하지 않으면 -1을 반환한다.

##### 예외

DBMS_CONCURRENT_EXEC 패키지에서 실행되는 프로시저가 이 함수를 호출하는 경우
다음의 예외가 발생할 수 있다.

```
RECURSIVE_CALL_IS_NOT_ALLOWED
```



##### 예제

DBMS_CONCURRENT_EXEC 패키지에서 'REQ_ID1'으로 요청한 프로시저가 동작이 완료될
때까지 기다리는 예제이다.

```
VARIABLE RC INTEGER;
VARIABLE REQ_ID1 INTEGER;
VARIABLE REQ_ID2 INTEGER;
VARIABLE REQ_ID3 INTEGER;
VARIABLE REQ_ID4 INTEGER;
EXEC :REQ_ID1 := DBMS_CONCURRENT_EXEC.REQUEST('PROC1');
EXEC :REQ_ID2 := DBMS_CONCURRENT_EXEC.REQUEST('PROC2(1, 1, 3)');
EXEC :REQ_ID3 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''ABC'', 3, 3)');
EXEC :REQ_ID4 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''DEF'', 3, 3)');
EXEC :RC := DBMS_CONCURRENT_EXEC.WAIT_REQ(:REQ_ID1);
```



#### GET_ERROR_COUNT

DBMS_CONCURRENT_EXEC 패키지에서 요청한 프로시저가 동작할 때 발생하는 오류의
개수를 반환한다. 오류가 발생하는 개수를 정확하게 알기 위해서 우선 WAIT_ALL
함수를 호출한 다음에 GET_ERROR_COUNT 함수를 호출한다.

##### 구문

```
INTERGER variable :=
  DBMS_CONCURRENT_EXEC.GET_ERROR_COUNT( );
```

##### 결과값

성공적으로 수행한 경우 오류 개수를 반환한다.

0을 반환하면 요청한 프로시저 동작을 모두 성공한 것이다.

##### 예외

DBMS_CONCURRENT_EXEC 패키지에서 실행되는 프로시저가 이 함수를 호출하는 경우
다음의 예외가 발생할 수 있다.

```
RECURSIVE_CALL_IS_NOT_ALLOWED
```



##### 예제

아래는 DBMS_CONCURRENT_EXEC 패키지에서 요청한 프로시저가 동작 중에 발생한 오류의
개수를 구하는 예제이다.

```
VARIABLE ERR_COUNT INTEGER;
VARIABLE RC INTEGER;
VARIABLE REQ_ID1 INTEGER;
VARIABLE REQ_ID2 INTEGER;
VARIABLE REQ_ID3 INTEGER;
VARIABLE REQ_ID4 INTEGER;
EXEC :REQ_ID1 := DBMS_CONCURRENT_EXEC.REQUEST('PROC1');
EXEC :REQ_ID2 := DBMS_CONCURRENT_EXEC.REQUEST('PROC2(1, 1, 3)');
EXEC :REQ_ID3 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''ABC'', 3, 3)');
EXEC :REQ_ID4 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''DEF'', 3, 3)');
EXEC :RC := DBMS_CONCURRENT_EXEC.WAIT_ALL( );
EXEC :ERR_COUNT := DBMS_CONCURRENT_EXEC.GET_ERROR_COUNT( );
```



#### GET_ERROR

DBMS_CONCURRENT_EXEC 패키지에서 요청한 ID에 해당하는 프로시저에 대하여 실행
구문, 오류 코드, 오류 메세지를 가져온다. 오류 정보를 정확하게 알기 위해서 우선
WAIT_ALL 함수를 호출한 다음에 GET_ERROR 함수를 호출한다.

##### 구문

```
INTERGER variable :=
  DBMS_CONCURRENT_EXEC.GET_ERROR(
     req_id IN INTEGER,
     text OUT VARCHAR(8192),
     err_code OUT INTEGER,
     err_msg OUT VARCHAR(8192));
```



##### 파라미터

| 이름       | 입출력 | 데이터 타입   | 설명                             |
|------------|--------|---------------|----------------------------------|
| *req_id*   | IN     | INTEGER       | 오류 정보를 가져올 프로시저의 ID |
| *text*     | OUT    | VARCHAR(8192) | 프로시저의 실행 구문             |
| *err_code* | OUT    | INTEGER       | 오류 코드                        |
| *err_msg*  | OUT    | VARCHAR(8192) | 오류 메세지                      |

##### 결과값

성공적으로 수행한 경우 Request ID를 반환한다. 해당 Request ID가 존재하지 않거나,
오류가 발생하지 않은 경우에는 -1을 반환한다.

##### 예외

DBMS_CONCURRENT_EXEC 패키지에서 실행되는 프로시저가 이 함수를 호출하는 경우
다음의 예외가 발생할 수 있다.

```
RECURSIVE_CALL_IS_NOT_ALLOWED
```



##### 예제

다음은 DBMS_CONCURRENT_EXEC 패키지에서 요청한 프로시저가 동작 중에 발생한 오류를
가져오는 예제이다.

```
VARIABLE RC INTEGER;
VARIABLE TEXT VARCHAR(8192);
VARIABLE ERR_CODE INTEGER;
VARIABLE ERR_MSG VARCHAR(8192);
VARIABLE REQ_ID INTEGER;
EXEC :REQ_ID := DBMS_CONCURRENT_EXEC.REQUEST('PROC1');
EXEC :RC := DBMS_CONCURRENT_EXEC.WAIT_REQ(:REQ_ID);
EXEC :REQ_ID := DBMS_CONCURRENT_EXEC.GET_ERROR( :REQ_ID, :TEXT, :ERR_CODE, :ERR_MSG);
```



#### PRINT_ERROR

DBMS_CONCURRENT_EXEC 패키지에서 요청한 ID에 해당하는 프로시저 실행 구문, 오류
코드, 오류 메시지를 출력한다.

##### 구문

```
INTERGER variable :=
  DBMS_CONCURRENT_EXEC.PRINT_ERROR(req_id IN INTEGER);
```



##### 파라미터

| 이름     | 입출력 | 데이터 타입 | 설명             |
|----------|--------|-------------|------------------|
| *req_id* | IN     | INTEGER     | 출력을 요청할 ID |

##### 예외

DBMS_CONCURRENT_EXEC 패키지에서 실행되는 프로시저가 이 함수를 호출하는 경우
다음의 예외가 발생할 수 있다.

```
RECURSIVE_CALL_IS_NOT_ALLOWED
```



##### 예제

다음은 DBMS_CONCURRENT_EXEC 패키지를 통해서 요청한 프로시저 동작으로 발생한
오류를 출력하는 예제이다.

```
VARIABLE RC INTEGER;
VARIABLE REQ_ID1 INTEGER;
VARIABLE REQ_ID2 INTEGER;
VARIABLE REQ_ID3 INTEGER;
VARIABLE REQ_ID4 INTEGER;
EXEC :REQ_ID1 := DBMS_CONCURRENT_EXEC.REQUEST('PROC1');
EXEC :REQ_ID2 := DBMS_CONCURRENT_EXEC.REQUEST('PROC2(1, 1, 3)');
EXEC :REQ_ID3 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''ABC'', 3, 3)');
EXEC :REQ_ID4 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''DEF'', 3, 3)');
EXEC :RC := DBMS_CONCURRENT_EXEC.WAIT_ALL();
EXEC DBMS_CONCURRENT_EXEC.PRINT_ERROR(:REQ_ID1);
EXEC DBMS_CONCURRENT_EXEC.PRINT_ERROR(:REQ_ID2)
EXEC DBMS_CONCURRENT_EXEC.PRINT_ERROR(:REQ_ID3);
EXEC DBMS_CONCURRENT_EXEC.PRINT_ERROR(:REQ_ID4);
```



#### GET_LAST_REQ_ID

DBMS_CONCURRENT_EXEC 패키지에서 수행을 성공한 마지막 Request_ID를 반환한다.

##### 구문

```
INTERGER variable :=
  DBMS_CONCURRENT_EXEC.GET_LAST_REQ_ID( );
```

##### 결과값

성공적으로 수행한 경우 마지막 Request ID를 반환한다.

##### 예외

이 함수는 예외를 발생하지 않는다.

##### 예제

다음은 DBMS_CONCURRENT_EXEC 패키지를 통해서 마지막으로 요청한 프로시저 동작의
ID를 얻는 예제이다.

```
VARIABLE LAST_REQ_ID INTEGER;
VARIABLE REQ_ID1 INTEGER;
VARIABLE REQ_ID2 INTEGER;
VARIABLE REQ_ID3 INTEGER;
VARIABLE REQ_ID4 INTEGER;
EXEC :REQ_ID1 := DBMS_CONCURRENT_EXEC.REQUEST('PROC1');
EXEC :REQ_ID2 := DBMS_CONCURRENT_EXEC.REQUEST('PROC2(1, 1, 3)');
EXEC :REQ_ID3 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''ABC'', 3, 3)');
EXEC :REQ_ID4 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''DEF'', 3, 3)');
EXEC :LAST_REQ_ID := DBMS_CONCURRENT_EXEC.GET_LAST_REQ_ID( );
```



#### GET_REQ_TEXT

DBMS_CONCURRENT_EXEC 패키지에서 요청한 프로시저의 실행 구문을 반환한다.

##### 구문

```
VARCHAR(8192) variable :=
  DBMS_CONCURRENT_EXEC.GET_REQ_TEXT(req_id IN INTEGER);
```

##### 파라미터

| 이름     | 입출력 | 데이터 타입 | 설명                          |
|----------|--------|-------------|-------------------------------|
| *req_id* | IN     | INTEGER     | 반환을 요청하는 프로시저의 ID |

##### 결과값

성공적으로 수행한 경우 프로시저 실행 구문을 반환한다. Request ID가 존재하지 않는
경우에는 NULL을 반환한다.

##### 예외

이 함수는 예외를 발생하지 않는다.

##### 예제

다음은 DBMS_CONCURRENT_EXEC 패키지를 통해서 요청한 프로시저 동작 구문을 얻는
예제이다.

```
VARIABLE REQ_ID1 INTEGER;
VARIABLE REQ_ID2 INTEGER;
VARIABLE REQ_ID3 INTEGER;
VARIABLE REQ_ID4 INTEGER;
EXEC :REQ_ID1 := DBMS_CONCURRENT_EXEC.REQUEST('PROC1');
EXEC :REQ_ID2 := DBMS_CONCURRENT_EXEC.REQUEST('PROC2(1, 1, 3)');
EXEC :REQ_ID3 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''ABC'', 3, 3)');
EXEC :REQ_ID4 := DBMS_CONCURRENT_EXEC.REQUEST('PROC3(''DEF'', 3, 3)');
EXEC PRINTLN(DBMS_CONCURRENT_EXEC.GET_REQ_TEXT(:REQ_ID1));
EXEC PRINTLN(DBMS_CONCURRENT_EXEC.GET_REQ_TEXT(:REQ_ID2));
EXEC PRINTLN(DBMS_CONCURRENT_EXEC.GET_REQ_TEXT(:REQ_ID3));
EXEC PRINTLN(DBMS_CONCURRENT_EXEC.GET_REQ_TEXT(:REQ_ID4));
```



#### FINALIZE

세션에서 실행되는 DBMS_CONCURRENT_EXEC 패키지를 초기화하고, 사용된 자원들을
시스템에 반납한다.

##### 구문

```
INTERGER variable :=
  DBMS_CONCURRENT_EXEC.FINALIZE( );
```

##### 결과값

성공적으로 수행한 경우 1을 반환한다.

##### 예외

DBMS_CONCURRENT_EXEC 패키지에서 실행되는 프로시저가 이 함수를 호출하는 경우
다음의 예외가 발생할 수 있다.

```
RECURSIVE_CALL_IS_NOT_ALLOWED
```



##### 예제

다음은 DBMS_CONCURRENT_EXEC 패키지를 초기화하고, 사용한 시스템 자원을 반납하는
예제이다.

```
VARIABLE RC INTEGER;
VARIABLE REQ_ID INTEGER;
EXEC :REQ_ID := DBMS_CONCURRENT_EXEC.REQUEST('PROC1');
EXEC :RC := DBMS_CONCURRENT_EXEC.FINALIZE( );
```



### DBMS_LOCK

DBMS_LOCK 패키지는 잠금(Lock)을 관리하는 인터페이스를 제공한다. 잠금을 요청하고,
해제할 수 있다.

DBMS_LOCK 패키지를 구성하는 프로시저와 함수는 아래의 표와 같이 제공한다.

| 프로시저 및 함수 | 설명                              |
|------------------|-----------------------------------|
| RELEASE          | 사용자 잠금을 해제한다.           |
| REQUEST          | 사용자 잠금을 요청한다.           |
| SLEEP            | 설정한 시간만큼 세션을 쉬게 한다. |
| SLEEP2           | 설정한 시간만큼 세션을 쉬게 한다. |

#### 관련 프로퍼티

DBMS_LOCK 관련 프로퍼티를 altibase.properties에 설정할 수 있다.

-   USER_LOCK_POOL_INIT_SIZE

-   USER_LOCK_REQUEST_CHECK_INTERVAL

-   USER_LOCK_REQUEST_LIMIT

-   USER_LOCK_REQUEST_TIMEOUT

더 자세한 정보는 *General Reference*를 참고한다.

#### RELEASE

사용자 잠금을 해제하는 함수이다.

##### 구문

```
INTEGER variable :=
  DBMS_LOCK.RELEASE(id IN INTEGER);
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명                    |
|------|--------|-------------|-------------------------|
| *id* | IN     | INTEGER     | Lock ID 0 \~ 1073741823 |

##### 결과값

결과값은 아래와 같다.

-   0 : Success

-   3 : Parameter error

-   4: Already own lock specified by id

##### 예외

이 함수는 예외를 발생시키지 않지만, 실패할 경우 0이 아닌 다른 값을 반환한다.

##### 예제

ID가 0인 잠금을 해제한다.

```
iSQL> var v1 integer;
iSQL> v1 := dbsm_lock.release(0);
```



#### REQUEST

사용자 잠금을 요청하는 함수이다.

##### 구문

```
INTEGER variable :=
  DBMS_LOCK.REQUEST(
    id IN INTEGER,
    lockmode IN INTEGER DEFAULT x_mode,
    timeout IN INTEGER DEFAULT MAXWAIT,
    release_on_commit IN BOOLEAN DEFAULT FALSE);
```

##### 파라미터

| 이름                | 입출력 | 데이터 타입 | 설명                                                                    |
|---------------------|--------|-------------|-------------------------------------------------------------------------|
| *id*                | IN     | INTEGER     | Lock ID 0 \~ 1073741823                                                 |
| *lockmode*          | IN     | INTEGER     | 호환성을 위한 파라미터이며 무시된다. x_mode(exclusive lock)만 지원된다. |
| *timeout*           | IN     | INTEGER     | 호환성을 위한 파라미터이며 무시된다. 기본값은 MAXWAIT이다.              |
| *release_on_commit* | IN     | INTEGER     | 호환성을 위한 파라미터이며 무시된다. 기본값은 FALSE이다.                |

##### 결과값

결과값은 아래와 같다.

-   0 : Success

-   1 : Timeout

-   3 : Parameter error

-   4: Already own lock specified by id

##### 예외

이 함수는 예외를 발생시키지 않지만, 실패할 경우 0이 아닌 다른 값을 반환한다.

##### 예제

ID가 0인 잠금을 요청한다.

```
iSQL> var v1 integer;
iSQL> v1 := dbsm_lock.request(0);
```



#### SLEEP

설정한 시간만큼 세션을 쉬게 하는 프로시저이다.

##### 구문

```
DBMS_LOCK.SLEEP(seconds IN INTEGER);
```



##### 파라미터

| 이름     | 입출력 | 데이터 타입 | 설명                                |
|----------|--------|-------------|-------------------------------------|
| *second* | IN     | INTEGER     | 세션의 쉬는 시간(초) 최댓값은 없다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

#### SLEEP2

설정한 시간만큼 세션을 쉬게 하는 프로시저이다.

##### 구문

```
DBMS_LOCK.SLEEP2(seconds IN INTEGER, microseconds IN INTEGER);
```



##### 파라미터

| 이름     | 입출력 | 데이터 타입 | 설명                                |
|----------|--------|-------------|-------------------------------------|
| *second* | IN     | INTEGER     | 세션의 쉬는 시간(초) 최댓값은 없다. |
| *microseconds* | IN | INTEGER | 세션이 쉬는 시간(마이크로초) 최대값은 999999 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

### DBMS_METADATA

DBMS_METADATA 패키지는 데이터베이스 딕셔너리로부터 객체 생성 DDL 구문 또는 권한 GRANT 구문을
추출하는 기능을 제공한다. 아래는 DBMS_METADATA 패키지를 구성하는 프로시저와 함수를 정리한 표이다.

| 프로시저 및 함수      | 설명                                                   |
| --------------------- | ------------------------------------------------------ |
| GET_DDL               | 지정한 객체에 대한 DDL 구문 반환                       |
| GET_DEPENDENT_DDL     | 지정한 객체에 종속된 객체들의 DDL 구문 반환            |
| GET_GRANTED_DDL       | 지정한 사용자에게 부여된 권한들에 대한 GRANT 구문 반환 |
| SET_TRANSFORM_PARAM   | 반환되는 DDL 문 내의 특정 항목들의 포함 여부 설정      |
| SHOW_TRANSFORM_PARAMS | 현재 설정된 transform parameter 값 출력                |

#### GET_DDL

지정한 객체에 대한 생성 DDL 구문을 반환한다.

##### 구문

```
DBMS_METADATA.GET_DDL (
   object_type     IN VARCHAR(20),
   object_name     IN VARCHAR(128),
   schema          IN VARCHAR(128) DEFAULT NULL)
RETURN VARCHAR(65534);
```

##### 파라미터

| 이름          | 입출력 | 데이터 타입  | 설명                                                         |
| ------------- | ------ | ------------ | ------------------------------------------------------------ |
| *object_type* | IN     | VARCHAR(20)  | 객체 종류                                                    |
| *object_name* | IN     | VARCHAR(128) | 객체 이름 (대소문자 구분)                                    |
| *schema*      | IN     | VARCHAR(128) | 객체 소유자 (대소문자 구분).<br />object_type이 스키마 객체이면 기본값은 현재 접속한 사용자이고, 비스키마 객체이면 기본값은 NULL이다. |

###### object_type

스키마 객체

- CONSTRAINT
- DB_LINK
- FUNCTION
- INDEX
- LIBRARY
- MATERIALIZED_VIEW
- PACKAGE
- PACKAGE_SPEC
- PACKAGE_BODY
- PROCEDURE
- QUEUE
- REF_CONSTRAINT
- SEQUENCE
- SYNONYM
- TABLE
- TRIGGER
- TYPESET
- VIEW

비스키마 객체

- DIRECTORY
- JOB
- REPLICATION
- ROLE
- TABLESPACE: 메모리 시스템 테이블스페이스는 DDL문이 반환되지 않고,
  디스크 시스템 테이블스페이스는 ALTER 구문이 반환된다.
- USER

##### 결과값

DDL 구문

##### 예외

invalid_argval
not_supported_obj_type
schema_not_found
object_not_found
not_supported_ddl

##### 예제

접속 사용자가 소유한 모든 테이블의 생성 DDL 구문을 구하는 예제이다.

```
set vertical on;
SELECT TO_CHAR(dbms_metadata.get_ddl('TABLE', table_name, null)) as ddl
FROM system_.sys_tables_
WHERE table_type = 'T' AND user_id = user_id()
ORDER BY table_name;
```

#### GET_DEPENDENT_DDL

지정한 객체에 종속된 객체들의 생성 DDL 구문을 반환한다.

##### 구문

```
DBMS_METADATA.GET_DEPENDENT_DDL (
   object_type          IN VARCHAR(20),
   base_object_name     IN VARCHAR(128),
   base_object_schema   IN VARCHAR(128) DEFAULT NULL)
RETURN VARCHAR(65534);
```

##### 파라미터

| 이름                 | 입출력 | 데이터 타입  | 설명                                                         |
| -------------------- | ------ | ------------ | ------------------------------------------------------------ |
| *object_type*        | IN     | VARCHAR(20)  | 객체 종류                                                    |
| *base_object_name*   | IN     | VARCHAR(128) | 베이스 객체 이름 (대소문자 구분)                             |
| *base_object_schema* | IN     | VARCHAR(128) | 베이스 객체 소유자 (대소문자 구분).<br />기본값은 현재 접속한 사용자이다. |

###### object_type

- COMMENT
- CONSTRAINT
- INDEX
- OBJECT_GRANT
- REF_CONSTRAINT
- TRIGGER

##### 결과값

DDL 구문

##### 예외

invalid_argval
not_supported_obj_type
schema_not_found
object_not_found

##### 예제

접속 사용자의 T1 테이블에 대한 모든 객체 권한을 구하는 예제이다.

```
set vertical on;
SELECT TO_CHAR(dbms_metadata.get_dependent_ddl('OBJECT_GRANT', 'T1')) as ddl
FROM dual;
```

#### GET_GRANTED_DDL

지정한 사용자에게 부여된 권한들의 생성 DDL 구문을 반환한다.

##### 구문

```
DBMS_METADATA.GET_GRANTED_DDL (
   object_type          IN VARCHAR(20),
   grantee              IN VARCHAR(128) DEFAULT NULL)
RETURN VARCHAR(65534);
```

##### 파라미터

| 이름          | 입출력 | 데이터 타입  | 설명                                                         |
| ------------- | ------ | ------------ | ------------------------------------------------------------ |
| *object_type* | IN     | VARCHAR(20)  | 객체 종류                                                    |
| *grantee*     | IN     | VARCHAR(128) | grantee (대소문자 구분).<br />기본값은 현재 접속한 사용자이다. |

###### object_type

- OBJECT_GRANT
- ROLE_GRANT
- SYSTEM_GRANT

##### 결과값

DDL 구문

##### 예외

invalid_argval
not_supported_obj_type
grantee_not_found
object_not_found

##### 예제

USER1 사용자에 부여된 모든 시스템 권한을 구하는 예제이다.

```
set vertical on;
SELECT TO_CHAR(dbms_metadata.get_granted_ddl('SYSTEM_GRANT', 'USER1')) as ddl
FROM dual;
```

#### SET_TRANSFORM_PARAM

반환되는 DDL 문 내의 특정 항목들의 포함 여부를 설정한다. 파라미터 설정은 같은 세션 내에서만 적용된다.

##### 구문

```
DBMS_METADATA.SET_TRANSFORM_PARAM (
   name          IN VARCHAR(40),
   value         IN CHAR(1));
```

##### 파라미터

| 이름    | 입출력 | 데이터 타입 | 설명          |
| ------- | ------ | ----------- | ------------- |
| *name*  | IN     | VARCHAR(40) | 파라미터 이름 |
| *value* | IN     | CHAR(1)     | 값            |

###### 객체 종류별 적용되는 파라미터

| Object Type                    | Name               | Description                                                  | Default |
| ------------------------------ | ------------------ | ------------------------------------------------------------ | ------- |
| 모든 객체                      | SQLTERMINATOR      | DDL 문에 SQL 종결자(terminator)를 덧붙일지 여부를 지정한다.<br />T: SQL 종결자를 덧붙임<br/>F: SQL 종결자를 덧붙이지 않음 | F       |
| TABLE<br/>INDEX<br/>CONSTRAINT | SEGMENT_ATTRIBUTES | segment attributes (physical attributes, storage clause, tablespace, logging) 포함 여부를 지정한다.<br />T: 포함<br/>F: 미포함 | T       |
|                                | STORAGE            | storage clause 포함 여부를 지정한다.<br />T: 포함<br/>F: 미포함 | T       |
|                                | TABLESPACE         | tablespace 포함 여부를 지정한다.<br/>T: 포함<br/>F: 미포함   | T       |
| TABLE                          | CONSTRAINTS        | foreign key를 제외한 constraint(primary key, unique, check)의 포함 여부를 지정한다.<br/>T: 포함<br/>F: 미포함 | T       |
|                                | REF_CONSTRAINTS    | foreign key 포함 여부를 지정한다.<br/>T: 포함<br/>F: 미포함  |         |

##### 결과값

없음

##### 예외

invalid_argval

##### 예제

반환되는 DDL문에 SQL 종결자를 덧붙이도록 설정하는 예제이다.

```
exec dbms_metadata.set_transform_param('SQLTERMINATOR', 'T');
```

#### SHOW_TRANSFORM_PARAMS

현재 설정된 transform parameter 값을 출력한다.

##### 구문

```
DBMS_METADATA.SHOW_TRANSFORM_PARAMS;
```

##### 결과값

없음

##### 예외

예외를 발생시키지 않는다.

### DBMS_OUTPUT

DBMS_OUTPUT 패키지는 버퍼에 저장된 문자열을 사용자가 클라이언트에게 출력할 수
있는 인터페이스를 제공한다. DBMS_OUTPUT 패키지를 구성하는 프로시저와 함수는
아래의 표와 같이 제공한다.

| 프로시저 및 함수 | 설명                                       |
|------------------|--------------------------------------------|
| NEW_LINE         | 버퍼에 저장된 문자열과 함께 개행 문자 출력 |
| PUT              | 버퍼에 문자열을 저장                       |
| PUT_LINE         | 버퍼에 저장된 문자열을 출력                |

#### NEW_LINE

개행 문자(“\\n”)를 출력한다.

##### 구문

```
DBMS_OUTPUT.NEWLINE;
```



##### 파라미터

없음

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

#### PUT

버퍼에 문자열을 저장하는 함수이다.

##### 구문

```
DBMS_OUTPUT.PUT(str IN VARCHAR(65534));
```



##### 파라미터

| 이름  | 입출력 | 데이터 타입    | 설명                               |
|-------|--------|----------------|------------------------------------|
| *str* | IN     | VARCHAR(65534) | 파일에서 읽은 문자열을 저장할 버퍼 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

#### PUT_LINE

버퍼에 출력되는 문자열 마지막에 개행 문자(“\\n”)를 붙여서 출력하는 함수이다.

##### 구문

```
DBMS_OUTPUT.PUT_LINE(str IN VARCHAR(65533));
```



##### 파라미터

| 이름  | 입출력 | 데이터 타입    | 설명                               |
|-------|--------|----------------|------------------------------------|
| *str* | IN     | VARCHAR(65534) | 파일에서 읽은 문자열을 저장할 버퍼 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

### DBMS_RANDOM

DBMS_RANDOM 패키지는 임의의 숫자를 생성한다. DBMS_RANDOM 패키지를 구성하는
프로시저와 함수는 아래의 표와 같이 제공한다.

| 프로시저 및 함수 | 설명                                     |
|------------------|------------------------------------------|
| INITIALIZE       | 패키지 초기화                            |
| SEED             | 주어진 값이나 문자열을 시드(seed)로 설정 |
| STRING           | 임의의 문자열 생성                       |
| VALUE            | 주어진 범위 내에서 임의의 값을 생성      |
| RANDOM           | 임의의 숫자를 생성한다.                  |

#### INITIALIZE

DBMS_RANDOM 패키지를 초기화하는 프로시저이다.

##### 구문

```
DBMS_RANDOM.INITIALIZE(val IN INTEGER);
```



##### 파라미터

| 이름  | 입출력 | 데이터 타입 | 설명             |
|-------|--------|-------------|------------------|
| *val* | IN     | INTEGER     | 시드로 설정된 값 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

#### SEED

주어진 값이나 문자열을 시드(seed)로 하여 임의의 시퀀스 값을 생성하는
프로시저이다.

##### 구문

```
DBMS_RANDOM.SEED(seedval IN INTEGER);
DBMS_RANDOM.SEED(seedval IN VARCHAR(2000));
```



##### 파라미터

| 이름      | 입출력 | 데이터 타입                | 설명                         |
|-----------|--------|----------------------------|------------------------------|
| *seedval* | IN     | INTEGER 또는 VARCHAR(2000) | 시드로 설정할 값 또는 문자열 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

#### STRING

임의의 문자열을 생성한다.

##### 구문

```
DBMS_RANDOM.STRING(opt IN CHAR, len IN NUMBER);
```



##### 파라미터

| 이름  | 입출력 | 데이터 타입 | 설명                 |
|-------|--------|-------------|----------------------|
| *opt* | IN     | CHAR        | 생성할 문자열.       |
| *len* | IN     | NUMBER      | 생성할 문자열의 길이 |

##### 설명

*opt*에는 아래의 파라미터 중 하나를 명시할 수 있다.

-   'u', 'U' : 임의의 대문자 알파벳 생성

-   'l', 'L' : 임의의 소문자 알파벳 생성

-   'a', 'A' : 대소문자를 구문하지 않고 임의의 알파벳 생성

-   'x', 'X' : 대문자 알파벳과 숫자를 생성

-   'p', 'P' : 출력할 수 있는 모든 문자열 생성

*len(gth)*에는 임의로 생성할 문자열의 길이를 명시하며, 0\~4000까지 입력이
가능하다.

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

#### VALUE

주어진 범위 내에서 임의의 값을 생성하는 프로시저이다. 범위가 지정되지 않으면,
0\~1 사이의 임의의 숫자를 반환한다.

##### 구문

```
NUMBER variable := DBMS_RANDOM.VALUE(low IN NUMBER, high IN NUMBER);
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입 | 설명                             |
|--------|--------|-------------|----------------------------------|
| *low*  | IN     | NUMBER      | 임의의 값을 생성할 범위의 최솟값 |
| *high* | IN     | NUMBER      | 임의의 값을 생성할 범위의 최댓값 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

#### RANDOM

이 함수는 임의의 정수형 값을 생성하는 프로시저이다.

##### 구문

DBMS_RANDOM. RANDOM();



##### 파라미터

없음

##### 결과값

성공적으로 수행하면 임의의 정수값을 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

임의의 숫자를 출력한다.

```
iSQL> select dbms_random.random() from dual;
```



### DBMS_RECYCLEBIN 패키지

DBMS_RECYCLEBIN 패키지는 삭제(Drop)되어 휴지통에서 관리되고 있는 테이블을
시스템에서 완전히 삭제(Purge)할 수 있는 기능을 제공한다. 이 기능은 시스템 정의
저장 패키지 형태로 제공된다.

#### DBMS_RECYCLEBIN의 프로시저와 함수

DBMS_RECYCYLEBIN 패키지를 구성하는 프로시저와 함수는 아래의 표에 목록화되어
있다.

| 프로시저/함수         | 설명                                                                           |
|-----------------------|--------------------------------------------------------------------------------|
| PURGE_USER_RECYCLEBIN | 휴지통에 있는 테이블을 사용자별로 시스템에서 제거한다.                         |
| PURGE_ALL_RECYCLEBIN  | 휴지통의 모든 테이블을 모두 제거한다.                                          |
| PURGE_TABLESPACE      | 명시한 테이블스페이스의 모든 테이블을 제거한다.                                |
| PURGE_ORIGINAL_NAME   | DROP되기 전의 테이블 이름으로 휴지통에 존재하는 복수의 테이블을 모두 제거한다. |

#### 관련 프로퍼티

DBMS_RECYCLEBIN 관련 프로퍼티를 altibase.properties에 설정할 수 있다.

-   RECYCLEBIN_DISK_MAX_SIZE

-   RECYCLEBIN_MEM_MAX_SIZE

-   RECYCLEBIN_ENABLE

더 자세한 정보는 *General Reference*를 참고한다.

#### PURGE_USER_RECYCLEBIN

휴지통에서 관리되고 있는 테이블을 사용자 별로 데이터베이스 시스템에서 완전히
삭제한다.

##### 구문

```
EXEC DBMS_RECYCLEBIN.PURGE_USER_RECYCLEBIN;
```



##### 예제

현재 접속중인 사용자가 DROP한 테이블을 휴지통에서 모두 삭제한다.

```
EXEC DBMS_RECYCLEBIN.PURGE_USER_RECYCLEBIN;
```



#### PURGE_ALL_RECYCLEBIN

휴지통에서 관리되고 있는 모든 테이블을 데이터베이스 시스템에서 제거한다.

##### 구문

```
EXEC DBMS_RECYCLEBIN.PURGE_ALL_RECYCLEBIN;
```



##### 예제

휴지통에 있는 모든 테이블을 삭제한다.

```
EXEC DBMS_RECYCLEBIN.PURGE_ALL_RECYCLEBIN;
```



#### PURGE_TABLESPACE

휴지통에 있는 명시된 테이블스페이스의 모든 테이블을 시스템에서 제거한다.

##### 구문

```
EXEC DBMS_RECYCLEBIN.PURGE_TABLESPACE(
  tablespace_name IN VARCHAR(64));
```

##### 파라미터

| 이름              | 입출력 | 데이터 타입 | 설명                  |
|-------------------|--------|-------------|-----------------------|
| *tablespace_name* | IN     | VARCHAR(64) | 테이블스페이스의 이름 |

##### 예제

TBS_DISK_DATA 테이블스페이스에 존재하는 테이블을 휴지통에서 모두 삭제한다.

```
EXEC DBMS_RECYCLEBIN.PURGE_TABLESPACE('TBS_DISK_DATA');
```



#### PURGE_ORIGINAL_NAME

삭제(DROP)되기 전의 테이블 이름으로 휴지통에서 테이블을 제거한다. 동일한 이름의
테이블이 여러 번 삭제될 수 있으며, 휴지통에서 이를 한 번에 삭제할 수 있다.

##### 구문

```
EXEC DBMS_RECYCLEBIN.PURGE_ORIGINAL_NAME(
  original_table_name IN VARCHAR(128));
```

##### 파라미터

| 이름                  | 입출력 | 데이터 타입  | 설명                      |
|-----------------------|--------|--------------|---------------------------|
| *original_table_name* | IN     | VARCHAR(128) | 삭제되기 전의 테이블 이름 |

##### 예제

삭제되기 전의 테이블 이름이 'TABLE1'인 테이블을 시스템에서 모두 제거한다.

```
EXEC DBMS_RECYCLEBIN.PURGE_ORIGINAL_NAME('TABLE1');
```



### DBMS_SQL

DBMS_SQL 패키지는 동적 SQL을 사용하는 프로시저와 함수를 아래와 같이 제공한다.

| 프로시저 및 함수    | 설명                                                                                                                |
|---------------------|---------------------------------------------------------------------------------------------------------------------|
| OPEN_CURSOR         | 커서를 오픈한다. PSM_CURSOR_OPEN_LIMIT 프로퍼티에서 오픈할 수 있는 커서의 최대 개수를 설정할 수 있다(기본값: 32개). |
| IS_OPEN             | 커서가 열려있는지 여부를 확인하여 결과를 반환한다.                                                                  |
| PARSE               | SQL 구문을 파싱한다.                                                                                                |
| BIND_VARIABLE       | SQL 구문에 포함된 변수를 바인딩한다.                                                                                |
| EXECUTE_CURSOR      | 커서를 실행한다.                                                                                                    |
| DEFINE_COLUMN       | 커서에서 fetch될 칼럼의 타입을 정의한다. SELECT 구문에서만 사용한다.                                                |
| FETCH_ROWS          | 커서에서 fetch하려는 행을 가져온다. SELECT 구문에서만 사용한다.                                                     |
| COLUMN_VALUE        | 커서에서 변수에 해당하는 칼럼의 값을 가져온다. SELECT 구문에서만 사용한다.                                          |
| CLOSE_CURSOR        | 커서를 닫는다.                                                                                                      |
| LAST_ERROR_POSITION | 파싱할 때 발생한 에러 위치를 반환한다.                                                                              |

#### 관련 프로퍼티

DBMS_SQL 패키지 관련 프로퍼티를 altibase.properties에 설정할 수 있다.

-   PSM_CURSOR_OPEN_LIMIT

더 자세한 정보는 *General Reference*를 참고한다.

#### BIND_VARIABLE

SQL 구문에 포함된 변수를 바인딩한다.

##### 구문

```
DBMS_SQL.BIND_VARIABLE(c, name, value);
```



##### 파라미터

| 이름  | 입출력 | 데이터 타입                                                  | 설명                                                         |
| ----- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| c     | IN     | INTEGER                                                      | 커서 번호                                                    |
| name  | IN     | VARCHAR2(128)                                                | 콜론(:)으로 시작하는 변수 이름                               |
| value | IN     | VARCHAR2(32000), <br />CHAR(32000), <br />INTEGER, <br />BIGINT, <br />SMALLINT, <br />DOUBLE, <br />REAL, <br />NUMERIC(38), <br />DATE | 언어 옵션(지원되지 않으므로, 어떤 값을 지정하여도 내부적으로 무시) |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1
as
c integer;
b1 integer;
begin
c := dbms_sql.open_cursor;
println( c );
dbms_sql.parse( c, 'insert into t1 values ( :b1 )', dbms_sql.native );
b1 := 999;
dbms_sql.bind_variable( c, ':b1', b1 );
end;
/
Create success.

iSQL> exec proc1;
0
Execute success.
```



#### CLOSE_CURSOR

커서를 닫는다. 커서가 닫히지 않은 경우, 세션이 종료될 때 자동으로 닫힌다.

##### 구문

```
DBMS_SQL.CLOSE_CURSOR(c);
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명      |
|------|--------|-------------|-----------|
| c    | IN     | INTEGER     | 커서 번호 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1
as
c integer;
b1 integer;
c1 integer;
rc bigint;
begin
c := dbms_sql.open_cursor;
println( c );
dbms_sql.close_cursor( c );
end;
/
Create success.

iSQL> exec proc1;
0
Execute success.
```



#### COLUMN_VALUE

커서에서 바인드 변수에 해당하는 칼럼의 값을 가져온다. SELECT 구문에서만
사용한다.

##### 구문

```
DBMS_SQL.COLUMN_VALUE(c, position, column_value);
```



##### 파라미터

| 이름         | 입출력 | 데이터 타입                                                  | 설명                                        |
| ------------ | ------ | ------------------------------------------------------------ | ------------------------------------------- |
| c            | IN     | INTEGER                                                      | 커서 번호                                   |
| position     | IN     | INTEGER                                                      | fetch할 칼럼의 상대적 위치. 1부터 시작한다. |
| column_value | OUT    | VARCHAR2(32000), <br />CHAR(32000), <br />INTEGER, <br />BIGINT, <br />SMALLINT, <br />DOUBLE, <br />REAL, <br />NUMERIC(38), <br />DATE | 칼럼의 값을 저장                            |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1
as
c integer;
b1 integer;
c1 integer;
rc bigint;
begin
c := dbms_sql.open_cursor;
println( c );
dbms_sql.parse( c, 'select i1 from t1 where i1 = :b1', dbms_sql.native );
b1 := 999;
dbms_sql.bind_variable( c, ':b1', b1 );
rc := dbms_sql.execute_cursor( c );
dbms_sql.define_column( c, 1, c1 );
loop
exit when dbms_sql.fetch_rows( c ) = 0;
dbms_sql.column_value(c, 1, c1);
println( 'fetch -> ' || c1 );
end loop;
end;
/
Create success.

iSQL> exec proc1;
0
fetch -> 999
Execute success.
```



#### DEFINE_COLUMN

커서에서 FETCH될 칼럼의 타입을 정의한다. SELECT 구문에서만 사용한다.

##### 구문

```
DBMS_SQL.DEFINE_COLUMN(c, position, column_value);
```



##### 파라미터

| 이름         | 입출력 | 데이터 타입                                                  | 설명                         |
| ------------ | ------ | ------------------------------------------------------------ | ---------------------------- |
| c            | IN     | INTEGER                                                      | 커서 번호                    |
| position     | IN     | INTEGER                                                      | 칼럼의 위치. 1부터 시작한다. |
| column_value | IN     | VARCHAR2(32000), <br />CHAR(32000), <br />INTEGER, <br />BIGINT, <br />SMALLINT, <br />DOUBLE, <br />REAL, <br />NUMERIC(38), <br />DATE | 칼럼의 타입을 정의           |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1
as
c integer;
b1 integer;
c1 integer;
rc bigint;
begin
c := dbms_sql.open_cursor;
println( c );
dbms_sql.parse( c, 'select i1 from t1 where i1 = :b1', dbms_sql.native );
b1 := 999;
dbms_sql.bind_variable( c, ':b1', b1 );
rc := dbms_sql.execute_cursor( c );
dbms_sql.define_column( c, 1, c1 );
end;
/
Create success.

iSQL> exec proc1;
0
Execute success.
```



#### EXECUTE_CURSOR

커서를 실행한다.

##### 구문

```
BIGINT variable:=DBMS_SQL.EXECUTE_CURSOR(c);
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명      |
|------|--------|-------------|-----------|
| c    | IN     | INTEGER     | 커서 번호 |

##### 결과값

커서를 실행하여 처리된 레코드의 개수를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1
as
c integer;
b1 integer;
rc bigint;
begin
c := dbms_sql.open_cursor;
println( c );
dbms_sql.parse( c, 'insert into t1 values ( :b1 )', dbms_sql.native );
b1 := 999;
dbms_sql.bind_variable( c, ':b1', b1 );
rc := dbms_sql.execute_cursor( c );
println( rc );
end;
/
Create success.

iSQL> exec proc1;
0
1
Execute success.
```



#### FETCH_ROWS

커서에서 fetch하려는 행(row)을 가져온다. SELECT 구문에서만 사용할 수 있다.

##### 구문

```
INTEGER variable:=DBMS_SQL.FETCH_ROWS(c);
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명      |
|------|--------|-------------|-----------|
| c    | IN     | INTEGER     | 커서 번호 |

##### 결과값

fetch할 행(row)이 없으면 0을 반환하고, 있으면 1을 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1
as
c integer;
b1 integer;
c1 integer;
rc bigint;
begin
c := dbms_sql.open_cursor;
println( c );
dbms_sql.parse( c, 'select i1 from t1 where i1 = :b1', dbms_sql.native );
b1 := 999;
dbms_sql.bind_variable( c, ':b1', b1 );
rc := dbms_sql.execute_cursor( c );
dbms_sql.define_column( c, 1, c1 );
rc := dbms_sql.fetch_rows( c );
println( rc );
end;
/
Create success.

iSQL> exec proc1;
0
1
Execute success.
```



#### IS_OPEN

커서가 열려있는지를 확인하여 결과를 반환한다.

##### 구문

```
BOOLEAN variable:=DBMS_SQL.IS_OPEN(c);
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명      |
|------|--------|-------------|-----------|
| c    | IN     | INTEGER     | 커서 번호 |

##### 결과값

커서가 오픈되었으면 TRUE, 오픈되지 않았으면 FALSE를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1
as
c integer;
begin
c := dbms_sql.open_cursor;
println( c );
if dbms_sql.is_open( c ) = TRUE
then
println( 'cursor opened' );
else
println( 'invalid cursor' );
end if;
end;
/
Create success.

iSQL> exec proc1;
0
cursor opened
Execute success.
```



#### LAST_ERROR_POSITION

파싱할 때 발생한 에러의 위치를 반환한다.

이 함수는 PARSE 프로시저를 호출한 직후에 사용해야 올바른 결과를 얻을 수 있다.

##### 구문

```
DBMS_SQL.LAST_ERROR_POSITION;
```



##### 결과값

에러 위치를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1( a varchar(128) )
as
c integer;
begin
c := dbms_sql.open_cursor;
dbms_sql.parse( c, a, dbms_sql.native );
exception
 when others
  then
    println( dbms_sql.last_error_position );
    dbms_sql.close_cursor( c );
end;
/
Create success.
iSQL> exec proc1( 'select empno, ^a from emp' );
14
Execute success.
```



#### OPEN_CURSOR

커서를 연다.

##### 구문

```
INTEGER variable:=DBMS_SQL.OPEN_CURSOR;
```



##### 결과값

성공적으로 수행할 경우 커서의 번호를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1
as
c integer;
begin
c := dbms_sql.open_cursor;
println( c );
end;
/
Create success.

iSQL> exec proc1;
0
Execute success
```

#### PARSE

SQL 구문을 파싱한다.

##### 구문

```
DBMS_SQL.PARSE(c, sql, language_flag);
```



##### 파라미터

| 이름          | 입출력 | 데이터 타입     | 설명                                                               |
|---------------|--------|-----------------|--------------------------------------------------------------------|
| c             | IN     | INTEGER         | 커서 번호                                                          |
| sql           | IN     | VARCHAR2(32000) | 파싱할 SQL                                                         |
| language_flag | IN     | INTEGER         | 언어 옵션(지원되지 않으므로, 어떤 값을 지정하여도 내부적으로 무시) |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1
as
c integer;
begin
c := dbms_sql.open_cursor;
println( c );
dbms_sql.parse( c, 'insert into t1 values ( 1 )', dbms_sql.native );
end;
/
Create success.

iSQL> exec proc1;
0
Execute success.
```

### DBMS_SQL_PLAN_CACHE

DBMS_SQL_PLAN_CACHE 패키지는 특정 실행 계획(Execution Plan)을 SQL Plan Cache에 유지하거나 삭제하는 기능을 하는 다음 2가지의 저장 프로시저를 제공한다.

| 프로시저 및 함수 | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| KEEP_PLAN        | 지정한 실행 계획을 SQL Plan Cache에서 삭제하지 않고 유지한다. |
| UNKEEP_PLAN      | KEEP_PLAN 저장 프로시저로 등록한 실행 계획을 해제한다. 해제된 실행 계획은 체크-인(check-in) 방식에 따라 SQL Plan Cache에서 삭제될 수 있다. |

#### KEEP_PLAN

입력 파라미터로 받은 실행 계획을 SQL Plan Cache 교체 대상에서 제외하고 SQL Plan Cache에 KEEP 상태로 유지한다. 단, 실행 계획이 리빌드(Rebuild)등으로 유효하지 않은 상태(Invalid)가 되면 UNKEEP 상태로 변경한다.
실행 계획을 KEEP 상태로 유지하려는 SQL 문의 SQL_TEXT_ID는 V$SQL_PLAN_CACHE_SQLTEXT 에서 SQL_TEXT_ID, SQL_TEXT 컬럼으로 확인할 수 있다. 이 SQL_TEXT_ID를 Parent PCO로 갖는 모든 Child PCO 모두 KEEP 상태를 유지한다.
Parent PCO의 KEEP 상태는 V$SQL_PLAN_CACHE_SQLTEXT 성능 뷰 PLAN_CACHE_KEEP 컬럼으로 확인할 수 있으며 Child PCO 경우 V$SQL_PLAN_CACHE_PCO 성능 뷰 PLAN_CACHE_KEEP 컬럼으로 확인할 수 있다.
실행 계획의 KEEP 상태를 해제하려면 UNKEEP_PLAN 저장 프로시저를 사용한다.

##### 구문

```
DBMS_SQL_PLAN_CACHE.KEEP_PLAN(sql_text_id);
```



##### 파라미터

| 이름        | 입출력 | 데이터 타입 | 설명                                   |
| ----------- | ------ | ----------- | -------------------------------------- |
| sql_text_id | IN     | VARCHAR(64) | SQL Plan Cache내에서 SQL 문장의 식별자 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> SELECT SQL_TEXT_ID FROM V$SQL_PLAN_CACHE_SQLTEXT WHERE SQL_TEXT LIKE 'select count%';
SQL_TEXT_ID
------------------------
00510
1 rows selected.

iSQL> EXEC DBMS_SQL_PLAN_CACHE.KEEP_PLAN('00510');
Execute success.
```

#### UNKEEP_PLAN

입력 파라미터로 받은 실행 계획의 KEEP 상태를 해제한다. 해제된 실행 계획은 SQL Plan Cache 관리 정책, 체크-인(check-in) 방식에 따라 SQL Plan Cache에서 삭제될 수 있다.


##### 구문

```
DBMS_SQL_PLAN_CACHE.UNKEEP_PLAN(sql_text_id);
```



##### 파라미터

| 이름        | 입출력 | 데이터 타입 | 설명                                   |
| ----------- | ------ | ----------- | -------------------------------------- |
| sql_text_id | IN     | VARCHAR(64) | SQL Plan Cache내에서 SQL 문장의 식별자 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> SELECT SQL_TEXT_ID FROM V$SQL_PLAN_CACHE_SQLTEXT WHERE PLAN_CACHE_KEEP = 'KEEP';
SQL_TEXT_ID
------------------------
00510
1 row selected.

iSQL> EXEC DBMS_SQL_PLAN_CACHE.UNKEEP_PLAN('00510');
Execute success.
```



### DBMS_STATS

DBMS_STATS 패키지는 통계 정보를 조회 및 변경할 수 있는 인터페이스를 제공한다.
저장 프로시저 및 함수를 이용해서 통계 정보를 구축하고 갱신할 수 있으며, 개별의
칼럼, 인덱스, 테이블 또는 시스템 별로 통계 자료를 설정하거나 삭제할 수 있다.

DBMS_STATS 패키지를 구성하는 프로시저와 함수는 아래의 표와 같이 제공한다.

| 프로시저 및 함수      | 설명                                                         |
|-----------------------|--------------------------------------------------------------|
| COPY_TABLE_STATS      | 파티션의 통계 정보를 새로운 파티션에 복사한다.               |
| DELETE_COLUMN_STATS   | 특정 테이블의 칼럼에 대한 통계 자료를 삭제한다.              |
| DELETE_DATABASE_STATS | 모든 테이블에 대한 통계 자료를 삭제한다.                     |
| DELETE_INDEX_STATS    | 특정 인덱스에 대한 통계 자료를 삭제한다.                     |
| DELETE_TABLE_STATS    | 특정 테이블에 대한 통계 자료를 삭제한다.                     |
| DELETE_SYSTEM_STATS   | 데이터베이스 시스템에 대한 통계 자료를 삭제한다.             |
| GATHER_DATABASE_STATS | 모든 테이블에 대한 통계 자료를 수집한다.                     |
| GATHER_INDEX_STATS    | 특정 인덱스에 대한 통계 자료를 수집한다.                     |
| GATHER_SYSTEM_STATS   | 데이터베이스 시스템에 대한 통계 자료를 수집한다.             |
| GATHER_TABLE_STATS    | 특정 테이블에 대한 통계 자료를 수집한다.                     |
| GET_COLUMN_STATS      | 특정 테이블의 칼럼에 대한 통계 자료를 조회한다.              |
| GET_INDEX_STATS       | 특정 인덱스에 대한 통계 자료를 조회한다.                     |
| GET_SYSTEM_STATS      | 데이터베이스 시스템에 대한 통계 자료를 조회한다.             |
| GET_TABLE_STATS       | 특정 테이블에 대한 통계 자료를 조회한다.                     |
| SET_COLUMN_STATS      | 특정 테이블의 칼럼에 대한 통계 자료를 변경한다.              |
| SET_INDEX_STATS       | 특정 인덱스에 대한 통계 자료를 변경한다.                     |
| SET_PRIMARY_KEY_STATS | 특정 테이블의 PRIMARY KEY INDEX에 대한 통계 자료를 변경한다. |
| SET_SYSTEM_STATS      | 데이터베이스 시스템에 대한 통계 자료를 변경한다.             |
| SET_TABLE_STATS       | 특정 테이블에 대한 통계 자료를 변경한다.                     |
| SET_UNIQUE_KEY_STATS  | 특정 테이블의 UNIQUE KEY INDEX에 대한 통계 자료를 변경한다.  |

#### SET_PRIMARY_KEY_STATS

이 프로시저는 PRIMARY KEY INDEX에 대한 통계 자료를 변경한다.

##### 구문

```
SET_PRIMARY_KEY_STATS (
  ownname		VARCHAR(128),
  tabname		VARCHAR(128),
  keycount	    BIGINT DEFAULT NULL,
  numpage		BIGINT DEFAULT NULL,
  numdist		BIGINT DEFAULT NULL,
  clusteringfactor BIGINT DEFAULT NULL,
  indexheight	BIGINT DEFAULT NULL,
  avgslotcnt	BIGINT DEFAULT NULL,
  no_invalidate	BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름             | 입출력 | 데이터 타입  | 설명                                                         |
| ---------------- | ------ | ------------ | ------------------------------------------------------------ |
| ownname          | IN     | VARCHAR(128) | 인덱스 소유자의 이름                                         |
| tablename        | IN     | VARCHAR(128) | 통계자료를 변경할 테이블의 이름                              |
| keycount         | IN     | BIGINT       | 인덱스의 레코드 개수                                         |
| numpage          | IN     | BIGINT       | 인덱스의 페이지 개수                                         |
| numdist          | IN     | BIGINT       | 인덱스에서 고유한 키의 개수                                  |
| clusteringfactor | IN     | BIGINT       | 인덱스에 부합하게 데이터가 정렬되어 있는 정도                |
| indexheight      | IN     | BIGINT       | 인덱스의 루트에서 리프 노드까지의 깊이                       |
| avgslotcnt       | IN     | BIGINT       | 인덱스 리프 노드에 저장된 레코드의 평균 개수                 |
| no_invalidate    | IN     | BOOLEAN      | 통계 자료가 수집된 인덱스들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부. <br />기본값은 FALSE이며, 실행 계획을 재구축한다. 만약 재구축하지 않으려면, TRUE를 입력한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> EXEC DBMS_STATS.SET_PRIMARY_KEY_STATS( 'SYS', 'T1', 1, 2, 3, 4, 5, 6, TRUE );
__SYS_IDX_ID_148 c integer;
Execute success.
```



#### SET_UNIQUE_KEY_STATS

이 프로시저는 UNIQUE KEY INDEX에 대한 통계 자료를 변경한다.

##### 구문

```
SET_UNIQUE_KEY_STATS (
  ownname 		VARCHAR(128),
  tabname 		VARCHAR(128),
  colnamelist 	VARCHAR(32000),
  keycount 		BIGINT DEFAULT NULL,
  numpage 		BIGINT DEFAULT NULL,
  numdist 		BIGINT DEFAULT NULL,
  clusteringfactor BIGINT DEFAULT NULL,
  indexheight 	BIGINT DEFAULT NULL,
  avgslotcnt 	BIGINT DEFAULT NULL,
  no_invalidate 	BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름             | 입출력 | 데이터 타입    | 설명                                                                                                                                                                   |
|------------------|--------|----------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ownname          | IN     | VARCHAR(128)   | 인덱스 소유자의 이름                                                                                                                                                   |
| tablename        | IN     | VARCHAR(128)   | 통계 자료를 변경할 테이블의 이름                                                                                                                                       |
| colnamelist      | IN     | VARCHAR(32000) | 통계 자료를 변경할 칼럼 이름의 리스트. UNIQUE KEY INDEX를 생성할 때 컬럼에 DESC를 명시한 경우 colnamelist에도 대문자로 명시해야 한다.                                  |
| keycount         | IN     | BIGINT         | 인덱스의 레코드 개수                                                                                                                                                   |
| numpage          | IN     | BIGINT         | 인덱스의 페이지 개수                                                                                                                                                   |
| numdist          | IN     | BIGINT         | 인덱스에서 고유한 키의 개수                                                                                                                                            |
| clusteringfactor | IN     | BIGINT         | 인덱스에 부합하게 데이터가 정렬되어 있는 정도                                                                                                                          |
| indexheight      | IN     | BIGINT         | 인덱스의 루트에서 리프 노드까지의 깊이                                                                                                                                 |
| avgslotcnt       | IN     | BIGINT         | 인덱스 리프 노드에 저장된 레코드의 평균 개수                                                                                                                           |
| no_invalidate    | IN     | BIGINT         | 통계 자료가 수집된 인덱스들과 관련된 모든 쿼리들의 실행 계획을 재구축할지 여부. 기본값은 FALSE이며, 실행 계획을 재구축한다. 만약 재구축하지 않으려면, TRUE를 입력한다. |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> EXEC DBMS_STATS.SET_UNIQUE_KEY_STATS( 'SYS', 'T1', 'C1,C2', 1, 2, 3, 4, 5, 6, TRUE );
__SYS_IDX_ID_149
Execute success.
```



### DBMS_STANDARD

DBMS_STANDARD 패키지는 패키지 이름을 명시하지 않고 사용할 수 있는 다양한 서브 프로그램을 제공한다. DBMS_STANDARD 패키지를 구성하는 프로시저와 함수는 아래의 표와 같다.

| 프로시저 및 함수   | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| DELETING           | Trigger가 DELETE로부터 시작한 것인지 여부를 반환한다.        |
| INSERTING          | Trigger가 INSERT로부터 시작한 것인지 여부를 반환한다.        |
| UPDATING           | Trigger가 UPDATE로부터 시작한 것인지 여부를 반환한다.        |
| UPDATING (colname) | Trigger가 특정 컬럼의 UPDATE로부터 시작한 것인지 여부를 반환한다. |

#### DELETING

Trigger가 DELETE로부터 시작한 것인지를 반환한다.

##### 구문

```
BOOLEAN variable := DBMS_STANDARD.DELETING;
BOOLEAN variable := DELETING;
```



##### 결과값

trigger가 DELETE로부터 시작한 경우 TRUE를 반환한다.

##### 예외

예외를 발생시키지 않는다.

예제

```
CREATE TABLE T1 (C1 INTEGER);
CREATE TABLE TMP ( C1 VARCHAR(10) );
INSERT INTO T1 VALUES(1);

CREATE OR REPLACE TRIGGER TRIG1
BEFORE DELETE ON T1
FOR EACH ROW
BEGIN
 IF DELETING THEN
  INSERT INTO TMP VALUES ('DELETE');
 END IF;
END;
/

iSQL> DELETE FROM T1;
1 row deleted.
iSQL> SELECT & FROM TMP;
1 row selected.
```



#### INSERTING

Trigger가 INSERT로부터 시작한 것인지를 반환한다.

##### 구문

```
BOOLEAN variable := DBMS_STANDARD.INSERTING;
BOOLEAN variable := INSERTING;
```



##### 결과값

trigger가 INSERT로부터 시작한 경우 TRUE를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
CREATE TABLE T1 (C1 INTEGER);
CREATE TABLE TMP (C1 VARCHAR(10));

CREATE OR REPLACE TRIGGER TRIG1
BEFORE INSERT ON T1
FOR EACH ROW
BEGIN
 IF INSERTING THEN
  INSERT INTO TMP VALUES ('INSERT');
 END IF;
END;
/

iSQL> INSERT INTO T1 VALUES(2);
1 row inserted.
iSQL> SELECT * FROM TMP;
TMP.C1
--------------
INSERT
1 row selected.
```



#### UPDATING

Trigger가 UPDATE로부터 시작한 것인지를 반환한다.

##### 구문

```
BOOLEAN variable := DBMS_STANDARD.UPDATING;
BOOLEAN variable := UPDATING;
```



##### 결과값

trigger가 UPDATE로부터 시작한 경우 TRUE를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
(CREATE TABLE T1 (C1 INTEGER);
CREATE TABLE TMP (C1 VARCHAR(10));

INSERT INTO T1 VALUES(1);

CREATE OR REPLACE TRIGGER TRIG1
BEFORE UPDATE ON T1
FOR EACH ROW
BEGIN
 IF UPDATING THEN
  INSERT INTO TMP VALUES ('UPDATE');
 END IF;
END;
/

iSQL> UPDATE T1 SET C1 = 2;
1 row updated.
iSQL> SELECT * FROM TMP;
TMP.C1
--------------
UPDATE
1 row selected.
```



#### UPDATING (colname)

Trigger가 특정 컬럼의 UPDATE로부터 시작한 것인지를 반환한다.

##### 구문

```
BOOLEAN variable := DBMS_STANDARD.UPDATING(COLNAME IN VARCHAR(128));
BOOLEAN variable := UPDATING(COLNAME IN VARCHAR(128));
```



##### 파라미터

| 이름    | 입출력 | 데이터 타입  | 설명                  |
| :------ | :----- | :----------- | :-------------------- |
| COLNAME | IN     | VARCHAR(128) | 컬럼 이름을 명시한다. |

##### 결과값

trigger가 특정 컬럼의 UPDATE로부터 시작한 경우 TRUE를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
CREATE TABLE T1 (C1 INTEGER, C2 INTEGER);
CREATE TABLE TMP (C1 VARCHAR(10));

INSERT INTO T1 VALUES(1, 2);

CREATE OR REPLACE TRIGGER TRIG1
BEFORE UPDATE ON T1
FOR EACH ROW
BEGIN
 IF UPDATING('C1') THEN
  INSERT INTO TMP VALUES ('UPDATE-C1');
ELSE
 INSERT INTO TMP VALUES ('OTHER');
 END IF;
END;
/

iSQL> UPDATE T1 SET C1 = 2;
1 row updated.
iSQL> SELECT * FROM TMP;
TMP.C1
--------------
UPDATE-C1
1 row selected.
iSQL> UPDATE T1 SET C2 = 3;
1 row updated.
iSQL> SELECT * FROM TMP;
TMP.C1
--------------
UPDATE-C1
OTHER
2 rows selected.
```



### DBMS_UTILITY

DBMS_UTILITY 패키지는 다양한 유틸리티 서브프로그램을 제공한다. DBMS_UTILITY
패키지를 구성하는 프로시저와 함수는 아래의 표와 같다.

| 프로시저 및 함수       | 설명                                                  |
|------------------------|-------------------------------------------------------|
| FORMAT_CALL_STACK      | 호출 시점의 스택 정보를 가져온다.                     |
| FORMAT_ERROR_BACKTRACE | 예외가 발생한 시점의 스택 정보를 가져온다.            |
| FORMAT_ERROR_STACK     | FORMAT_ERROR_BACKTRACE 함수와 동일한 정보를 가져온다. |

#### FORMAT_CALL_STACK

호출 시점의 스택 정보를 문자열로 가져오는 함수이다.

##### 구문

```
VARCHAR variable := DBMS_UTILITY.FORMAT_CALL_STACK;
```



##### 결과값

호출 시점의 스택 정보를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1
is
  a integer;
begin
  a := 1;
  println( dbms_utility.format_call_stack );
end;
/
Create success.

iSQL> create or replace procedure proc2 as begin
  proc1;
end;
/
Create success.

iSQL> exec proc2;
object     line       object
handle     number     name
6261376    6          procedure "SYS.PROC1"
6258720    2          procedure "SYS.PROC2"
Execute success.
```



#### FORMAT_ERROR_BACKTRACE

예외가 발생한 시점의 스택 정보를 문자열로 가져오는 함수이다. 예외가 발생하지
않았다면 NULL 값을 가져온다.

##### 구문

```
VARCHAR variable := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
```



##### 결과값

예외가 발생한 시점의 스택 정보를 반환한다. 예외가 발생하지 않았다면 NULL을
반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> create or replace procedure proc1
is
  a integer;
begin
  a := 'aaaaa';
end;
/
Create success.

iSQL> create or replace procedure proc2 as begin
  proc1;
exception
when others then
  println( dbms_utility.format_error_backtrace );
end;
/
Create success.

iSQL> exec proc2;
ERR-21011 : Invalid literal
at "SYS.PROC1", line 5
at "SYS.PROC2", line 2
Execute success.
```



### STANDARD

STANDARD 패키지는 기본 데이터 타입 외에 PSM내에서 별도의 선언없이 사용할 수 있는
타입을 정의한다. STANDARD 패키지는 아래의 표에 명시한 타입을 제공한다.

| STANADARD 패키지 타입 이름 | 타입       |
|----------------------------|------------|
| SYS_REFCURSOR              | REF CURSOR |

##### 예제

```
iSQL> CREATE OR REPLACE PROCEDURE PROC1 AS
CUR1 SYS_REFCURSOR;
VAR1 INTEGER;
BEGIN
OPEN CUR1 FOR 'SELECT ROWNUM FROM DUAL';
FETCH CUR1 INTO VAR1;
 PRINTLN(VAR1);
CLOSE CUR1;
END;
/
```



### SYS_SPATIAL

Spatial에 관련한 서브프로그램을 제공한다.

SYS_SPATIAL 패키지를 구성하는 프로시저와 함수는 아래 표와 같다.
각 프로시저의 자세한 내용은 *Spatial SQL Reference* 의 'C.부록: Geometry 참조테이블 > 관련 저장 프로시저' 절의 설명을 참고한다.

| 프로시저 및 함수       | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| ADD_SPATIAL_REF_SYS    | SPATIAL_REF_SYS_ 테이블에 Spatial Reference System 메타데이터를 등록한다. |
| DELETE_SPATIAL_REF_SYS | SPATIAL_REF_SYS_ 테이블에 Spatial Reference System 메타데이터를 삭제한다. |



### UTL_COPYSWAP

UTL_COPYSWAP 패키지는 테이블 스키마 복사, 데이터 복제, 테이블 교환 인터페이스를
제공한다.

UTL_COPYSWAP 패키지를 구성하는 프로시저와 함수는 아래의 표와 같다.
UTL_COPYSWAP을 사용하기 위한 전제 조건은 CHECK_PRECONDITION의 설명을 참고한다.

| 프로시저 및 함수     | 설명                                                                             |
|----------------------|----------------------------------------------------------------------------------|
| CHECK_PRECONDITION   | 권한, 세션 프로퍼티, 시스템 프로퍼티, 이중화 제약조건을 검사한다.                |
| COPY_TABLE_SCHEMA    | 테이블 스키마를 복사한다. 이후에 복사한 테이블에 사용자가 원하는 DDL을 수행한다. |
| REPLICATE_TABLE      | 데이터를 복제한다.                                                               |
| SWAP_TABLE           | 테이블을 교환한다.                                                               |
| SWAP_TABLE_PARTITION | 테이블 파티션을 교환한다.                                                        |
| FINISH               | COPY_TABLE_SCHEMA, REPLICATE_TABLE에서 생성한 것을 정리한다.                     |

#### CHECK_PRECONDITION

UTL_COPYSWAP을 사용하기 위한 권한, 세션 프로퍼티, 시스템 프로퍼티, 이중화
제약조건 등의 전제조건을 검사하는 프로시저이다.

검사할 전제 조건들은 아래와 같다.

-   권한  
    SYS 사용자이어야 한다.

-   세션 프로퍼티  
    AUTOCOMMIT 프로퍼티가 FALSE이어야 한다.  
    REPLICATION 프로퍼티가 TRUE이어야 한다.

-   시스템 프로퍼티  
    REPLICATION_PORT_NO 프로퍼티가 0이 아니어야 한다.  
    REPLICATION_DDL_ENABLE 프로퍼티가 1이어야 한다.  
    REPLICATION_ALLOW_DUPLICATE_HOSTS 프로퍼티가 1이어야 한다.

-   이중화 제약 조건  
    Compressed Column을 지원하지 않는다.  
    관련 Eager Sender/Receiver Thread가 없어야 한다.

##### 구문

```
UTL_COPYSWAP.CHECK_PRECONDITION(
  source_user_name IN VARCHAR(128),
  source_table_name IN VARCHAR(128) );
```

##### 파라미터

| 이름                | 입출력 | 데이터 타입   | 설명                      |
|---------------------|--------|---------------|---------------------------|
| *source_user_name*  | IN     | VARCHAR2(128) | 원본 테이블의 소유자 이름 |
| *source_table_name* | IN     | VARCHAR2(128) | 원본 테이블 이름          |

##### 결과값

저장 프로시저이므로 반환되는 결과값은 없다.

##### 예외

파라미터를 잘못 입력하면, 예외가 발생한다.

##### 예제

```
iSQL> CREATE TABLE T1 ( I1 INTEGER PRIMARY KEY, V1 VARCHAR(1024) );
Create success.
iSQL> EXEC UTL_COPYSWAP.CHECK_PRECONDITION( 'SYS', 'T1' );
[SESSION PROPERTY] AUTOCOMMIT property value must be FALSE.
[SYSTEM PROPERTY] REPLICATION_PORT_NO property value must be larger than 0.
[SYSTEM PROPERTY] REPLICATION_DDL_ENABLE property value must be 1.
[SYSTEM PROPERTY] REPLICATION_ALLOW_DUPLICATE_HOSTS property value must be 1.
Execute success.
```



#### COPY_TABLE_SCHEMA

Table Schema를 복사하는 프로시저이다. 이후에 복사한 Table에 사용자가 원하는
DDL을 수행한다. 복사 대상은 아래와 같다.

-   Table 기본 정보

-   Column

-   Index

-   Constraint

-   Trigger

-   Comment

-   Partition

##### 구문

```
UTL_COPYSWAP.COPY_TABLE_SCHEMA(
  target_user_name IN VARCHAR(128),
  target_table_name IN VARCHAR(128),
  source_user_name IN VARCHAR(128),
  source_table_name IN VARCHAR(128) );
```



##### 파라미터

| 이름                | 입출력 | 데이터 타입   | 설명                      |
|---------------------|--------|---------------|---------------------------|
| *target_user_name*  | IN     | VARCHAR2(128) | 사본 테이블의 소유자 이름 |
| *target_table_name* | IN     | VARCHAR2(128) | 사본 테이블 이름          |
| *source_user_name*  | IN     | VARCHAR2(128) | 원본 테이블의 소유자 이름 |
| *source_table_name* | IN     | VARCHAR2(128) | 원본 테이블 이름          |

##### 결과값

저장 프로시저이므로 반환되는 결과값은 없다.

##### 예외

파라미터를 잘못 입력하면, 예외가 발생한다.

##### 예제

```
iSQL> CREATE TABLE T1 ( I1 INTEGER PRIMARY KEY, V1 VARCHAR(1024) );
Create success.
iSQL> INSERT INTO T1 VALUES ( 1, 'ABC' );
1 row inserted.
iSQL> ALTER SESSION SET AUTOCOMMIT = FALSE;
Alter success.
iSQL> ALTER SYSTEM SET REPLICATION_DDL_ENABLE = 1;
Alter success.
iSQL> ALTER SYSTEM SET REPLICATION_ALLOW_DUPLICATE_HOSTS = 1;
Alter success.
iSQL> EXEC UTL_COPYSWAP.COPY_TABLE_SCHEMA( 'SYS', 'T1_COPY', 'SYS', 'T1' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
0    
1 row selected.
iSQL> ALTER TABLE T1_COPY ALTER TABLESPACE SYS_TBS_DISK_DATA;
Alter success.
```



#### REPLICATE_TABLE

Replication을 사용하여 데이터를 복제하는 프로시저이다.

##### 구문

```
UTL_COPYSWAP.REPLICATE_TABLE(
  replication_name IN VARCHAR(35),
  target_user_name IN VARCHAR(128),
  target_table_name IN VARCHAR(128),
  source_user_name IN VARCHAR(128),
  source_table_name IN VARCHAR(128),
  sync_parallel_factor IN INTEGER DEFAULT 8,
  receiver_applier_count IN INTEGER DEFAULT 8 );
```



##### 파라미터

| 이름                     | 입출력 | 데이터 타입   | 설명                           |
|--------------------------|--------|---------------|--------------------------------|
| *replication_name*       | IN     | VARCHAR2(35)  | 이중화 이름                    |
| *target_user_name*       | IN     | VARCHAR2(128) | 사본 테이블의 소유자 이름      |
| *target_table_name*      | IN     | VARCHAR2(128) | 사본 테이블 이름               |
| *source_user_name*       | IN     | VARCHAR2(128) | 원본 테이블의 소유자 이름      |
| *source_table_name*      | IN     | VARCHAR2(128) | 원본 테이블 이름               |
| *sync_parallel_factor*   | IN     | INTEGER       | 초기 동기화에 적용할 병렬 인자 |
| *receiver_applier_count* | IN     | INTEGER       | 증분 동기화에 적용할 병렬 인자 |

##### 결과값

저장 프로시저이므로 반환되는 결과값은 없다.

##### 예외

파라미터를 잘못 입력하면, 예외가 발생한다.

##### 예제

```
iSQL> CREATE TABLE T1 ( I1 INTEGER PRIMARY KEY, V1 VARCHAR(1024) );
Create success.
iSQL> INSERT INTO T1 VALUES ( 1, 'ABC' );
1 row inserted.
iSQL> ALTER SESSION SET AUTOCOMMIT = FALSE;
Alter success.
iSQL> ALTER SYSTEM SET REPLICATION_DDL_ENABLE = 1;
Alter success.
iSQL> ALTER SYSTEM SET REPLICATION_ALLOW_DUPLICATE_HOSTS = 1;
Alter success.
iSQL> EXEC UTL_COPYSWAP.COPY_TABLE_SCHEMA( 'SYS', 'T1_COPY', 'SYS', 'T1' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
0    
1 row selected.
iSQL> ALTER TABLE T1_COPY ALTER TABLESPACE SYS_TBS_DISK_DATA;
Alter success.
iSQL> EXEC UTL_COPYSWAP.REPLICATE_TABLE( 'REP_LOCAL', 'SYS', 'T1_COPY', 'SYS', 'T1' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
1    
1 row selected.
```



#### SWAP_TABLE

Replication을 이용한 동기화를 완료하고 테이블을 교환하는 프로시저이다. 교환
대상은 아래와 같다.

-   Table 기본 정보

-   Column

-   Index

-   Constraint

-   Trigger

-   Comment

-   Partition

##### 구문

```
UTL_COPYSWAP.SWAP_TABLE(  
  replication_name IN VARCHAR(35),  
  target_user_name IN VARCHAR(128),  
  target_table_name IN VARCHAR(128),  
  source_user_name IN VARCHAR(128),  
  source_table_name IN VARCHAR(128),  
  force_to_rename_encrypt_column IN BOOLEAN DEFAULT FALSE,  
  ignore_foreign_key_child IN BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름                             | 입출력 | 데이터 타입   | 설명                                                                 |
|----------------------------------|--------|---------------|----------------------------------------------------------------------|
| *replication_name*               | IN     | VARCHAR2(35)  | 이중화 이름                                                          |
| *target_user_name*               | IN     | VARCHAR2(128) | 사본 테이블의 소유자 이름                                            |
| *target_table_name*              | IN     | VARCHAR2(128) | 사본 테이블 이름                                                     |
| *source_user_name*               | IN     | VARCHAR2(128) | 원본 테이블의 소유자 이름                                            |
| *source_table_name*              | IN     | VARCHAR2(128) | 원본 테이블 이름                                                     |
| *force_to_rename_encrypt_column* | IN     | BOOLEAN       | 암호화 컬럼이 있고 암호화 모듈이 Rename을 지원하면, TRUE로 설정한다. |
| *ignore_foreign_key_child*       | IN     | BOOLEAN       | 원본 테이블을 참조하는 테이블이 있으면, TRUE로 설정한다.             |

##### 결과값

저장 프로시저이므로 반환되는 결과값은 없다.

##### 예외

파라미터를 잘못 입력하면, 예외가 발생한다.

##### 예제

```
iSQL> CREATE TABLE T1 ( I1 INTEGER PRIMARY KEY, V1 VARCHAR(1024) );
Create success.
iSQL> INSERT INTO T1 VALUES ( 1, 'ABC' );
1 row inserted.
iSQL> ALTER SESSION SET AUTOCOMMIT = FALSE;
Alter success.
iSQL> ALTER SYSTEM SET REPLICATION_DDL_ENABLE = 1;
Alter success.
iSQL> ALTER SYSTEM SET REPLICATION_ALLOW_DUPLICATE_HOSTS = 1;
Alter success.
iSQL> EXEC UTL_COPYSWAP.COPY_TABLE_SCHEMA( 'SYS', 'T1_COPY', 'SYS', 'T1' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
0    
1 row selected.
iSQL> ALTER TABLE T1_COPY ALTER TABLESPACE SYS_TBS_DISK_DATA;
Alter success.
iSQL> EXEC UTL_COPYSWAP.REPLICATE_TABLE( 'REP_LOCAL', 'SYS', 'T1_COPY', 'SYS', 'T1' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
1    
1 row selected.
iSQL> INSERT INTO T1 VALUES ( 2, 'XYZ' );
1 row inserted.
iSQL> COMMIT;
Commit success.
iSQL> EXEC UTL_COPYSWAP.SWAP_TABLE( 'REP_LOCAL', 'SYS', 'T1_COPY', 'SYS', 'T1' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
2    
1 row selected.
```



#### SWAP_TABLE_PARTITION

Replication을 이용한 동기화를 완료하고 Table partition을 교환하는 프로시저이다.
교환 대상은 아래와 같다.

-   Partition

##### 구문

```
PROCEDURE swap_table_partition(  
  replication_name IN VARCHAR(35),  
  target_user_name IN VARCHAR(128),  
  target_table_name IN VARCHAR(128),  
  source_user_name IN VARCHAR(128),  
  source_table_name IN VARCHAR(128),  
  table_partition_name IN VARCHAR(128) );
```



##### 파라미터

| 이름                   | 입출력 | 데이터 타입   | 설명                      |
|------------------------|--------|---------------|---------------------------|
| *replication_name*     | IN     | VARCHAR2(35)  | 이중화 이름               |
| *target_user_name*     | IN     | VARCHAR2(128) | 사본 테이블의 소유자 이름 |
| *target_table_name*    | IN     | VARCHAR2(128) | 사본 테이블 이름          |
| *source_user_name*     | IN     | VARCHAR2(128) | 원본 테이블의 소유자 이름 |
| *source_table_name*    | IN     | VARCHAR2(128) | 원본 테이블 이름          |
| *table_partition_name* | IN     | VARCHAR2(128) | 교환대상인 테이블 파티션  |

##### 결과값

저장 프로시저이므로 반환되는 결과값은 없다.

##### 예외

파라미터를 잘못 입력하면, 예외가 발생한다.

##### 예제

```
iSQL> create table t1 (i1 int, i2 int)
partition by range (i1)
(
    partition p1 values less than (10),
    partition p2 values less than (20),
    partition p3 values default
)tablespace sys_tbs_disk_data;
Create success.

iSQL> alter table t1 add constraint pk_t1 primary key(i1) using index local
(
    partition  pk_p1 on p1 tablespace SYS_TBS_DISK_DATA,
    partition  pk_p2 on p2 tablespace SYS_TBS_DISK_DATA,
    partition  pk_p3 on p3 tablespace SYS_TBS_DISK_DATA
);
Alter success.
iSQL> INSERT INTO T1 VALUES ( 15, 15 );
1 row inserted.
iSQL> ALTER SESSION SET AUTOCOMMIT = FALSE;
Alter success.
iSQL> ALTER SYSTEM SET REPLICATION_DDL_ENABLE = 1;
Alter success.
iSQL> ALTER SYSTEM SET REPLICATION_ALLOW_DUPLICATE_HOSTS = 1;
Alter success.
iSQL> EXEC UTL_COPYSWAP.COPY_TABLE_SCHEMA( 'SYS', 'T1_COPY', 'SYS', 'T1' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
0    
1 row selected.
iSQL> ALTER TABLE T1_COPY ALTER TABLESPACE SYS_TBS_MEM_DATA;
Alter success.
iSQL> EXEC UTL_COPYSWAP.REPLICATE_TABLE( 'REP_LOCAL', 'SYS', 'T1_COPY', 'SYS', 'T1' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
1    
1 row selected.
iSQL> INSERT INTO T1 VALUES ( 16, 16 );
1 row inserted.

iSQL> commit ;
iSQL> EXEC UTL_COPYSWAP.SWAP_TABLE_PARTITION( 'REP_LOCAL', 'SYS', 'T1_COPY', 'SYS', 'T1','P2' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
2    
1 row selected.
```



#### FINISH

COPY_TABLE_SCHEMA, REPLICATE_TABLE에서 생성한 것을 정리하는 프로시저이다.

##### 구문

```
UTL_COPYSWAP.FINISH(  
  replication_name IN VARCHAR(35),  
  target_user_name IN VARCHAR(128),  
  target_table_name IN VARCHAR(128),  
  print_all_errors IN BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름                | 입출력 | 데이터 타입   | 설명                                                 |
|---------------------|--------|---------------|------------------------------------------------------|
| *replication_name*  | IN     | VARCHAR2(35)  | 이중화 이름                                          |
| *target_user_name*  | IN     | VARCHAR2(128) | 사본 테이블의 소유자 이름                            |
| *target_table_name* | IN     | VARCHAR2(128) | 사본 테이블 이름                                     |
| *print_all_errors*  | IN     | BOOLEAN       | Replication 관련 에러를 출력하려면, TRUE로 설정한다. |

##### 결과값

저장 프로시저이므로 반환되는 결과값은 없다.

##### 예외

파라미터를 잘못 입력하면, 예외가 발생한다.

##### 예제

```
iSQL> CREATE TABLE T1 ( I1 INTEGER PRIMARY KEY, V1 VARCHAR(1024) );
Create success.
iSQL> INSERT INTO T1 VALUES ( 1, 'ABC' );
1 row inserted.
iSQL> ALTER SESSION SET AUTOCOMMIT = FALSE;
Alter success.
iSQL> ALTER SYSTEM SET REPLICATION_DDL_ENABLE = 1;
Alter success.
iSQL> ALTER SYSTEM SET REPLICATION_ALLOW_DUPLICATE_HOSTS = 1;
Alter success.
iSQL> EXEC UTL_COPYSWAP.COPY_TABLE_SCHEMA( 'SYS', 'T1_COPY', 'SYS', 'T1' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
0    
1 row selected.
iSQL> ALTER TABLE T1_COPY ALTER TABLESPACE SYS_TBS_DISK_DATA;
Alter success.
iSQL> EXEC UTL_COPYSWAP.REPLICATE_TABLE( 'REP_LOCAL', 'SYS', 'T1_COPY', 'SYS', 'T1' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
1    
1 row selected.
iSQL> INSERT INTO T1 VALUES ( 2, 'XYZ' );
1 row inserted.
iSQL> COMMIT;
Commit success.
iSQL> EXEC UTL_COPYSWAP.SWAP_TABLE( 'REP_LOCAL', 'SYS', 'T1_COPY', 'SYS', 'T1' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
COUNT
-----------------------
2    
1 row selected.
iSQL> EXEC UTL_COPYSWAP.FINISH( 'REP_LOCAL', 'SYS', 'T1_COPY' );
Execute success.
iSQL> SELECT COUNT(*) FROM T1_COPY;
[ERR-31031 : Table or view was not found :
0001 : SELECT COUNT(*) FROM T1_COPY
^      ^
```



#### 주의사항

-   REPLICATE_TABLE 프로시저를 사용하여 데이터를 복제하려면, 원본 테이블의
    크기에 비례하여 Tablespace에 여유 공간이 필요하다. REPLICATE_TABLE
    프로시저가 생성한 로그 파일은 REPLICATE_TABLE 프로시저가 종료될 때까지
    Checkpoint로 제거되지 않는다.

-   UTL_COPYSWAP 패키지를 사용하는 동안 원본 테이블에 적용하는 DML을
    Replication이 분석할 수 있어야 한다. 이중화에서 분석할 수 없는 DML은 손실될
    수 있다.  
    - 원본 테이블에 DML을 수행할 때, REPLICATION 세션 프로퍼티가 TRUE이어야
    한다.  
    - 원본 테이블이 Replication 대상 테이블이면, Replication을 통해 원본
    테이블에 데이터를 반영하지 않도록 원본 테이블에 대응하는 원격 서버의
    Replication을 정지해야 한다.

-   FINISH 프로시저를 사용하여 사본 테이블을 제거할 때, RECYCLEBIN_ENABLE
    프로퍼티의 값이 1이면 휴지통으로 옮겨진다.

### UTL_FILE

UTL_FILE 패키지는 운영 체제에서 관리하는 텍스트 파일에 접근하여 읽기, 쓰기를
가능하게 한다.

UTL_FILE 패키지를 구성하는 프로시저와 함수는 아래의 표와 같이 제공한다.

| 프로시저 및 함수 | 설명                                                              |
|------------------|-------------------------------------------------------------------|
| FCLOSE           | 파일을 닫는다.                                                    |
| FCLOSE_ALL       | 현재 세션에 열려있는 모든 파일을 닫는다.                          |
| FCOPY            | 파일을 복사한다.                                                  |
| FFLUSH           | 파일에 데이터를 물리적으로 기록한다.                              |
| FOPEN            | 읽기 또는 쓰기 목적으로 파일을 오픈한다.                          |
| FREMOVE          | 파일을 삭제한다.                                                  |
| FRENAME          | 파일명을 변경한다.                                                |
| GET_LINE         | 파일에서 한 라인을 읽는다.                                        |
| IS_OPEN          | 파일이 열려있는지 검사한다.                                       |
| NEW_LINE         | 개행 문자를 출력한다.                                             |
| PUT              | 문자열을 파일에 기록한다                                          |
| PUT_LINE         | 문자열에 개행 문자를 붙여서 파일에 기록한다 (= PUT+NEW_LINE)한다. |

UTL_FILE 패키지에 해당하는 프로시저와 함수에 대한 자세한 설명은 Altibase 저장
프로시저의 "파일 제어"를 참고한다.

#### FCLOSE

열려 있는 파일 핸들을 닫고 다시 초기화 하는 기능을 제공하는 저장 프로시저이다.

##### 구문

```
UTL_FILE.FCLOSE(file IN OUT FILE_TYPE);
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입 | 설명      |
|--------|--------|-------------|-----------|
| *file* | IN OUT | FILE_TYPE   | 파일 핸들 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다.

#### FCLOSE_ALL

현재 세션에 열려있는 모든 파일 핸들을 닫는 기능을 제공하는 저장 프로시저이다.

##### 구문

```
UTL_FILE.FCLOSE_ALL;
```



##### 파라미터

파라미터가 없다.

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

수행 시 오류를 발생시키지 않으며 항상 성공한다.

#### FCOPY

파일을 라인 단위로 복사하는 기능을 제공하는 저장 프로시저이다. 결과 파일이 해당
디렉토리에 존재하지 않으면 파일이 생성되면서 소스 파일의 내용을 복사하고, 이미
결과 파일이 존재하면 내용을 그대로 덮어 쓴다.

##### 구문

```
UTL_FILE.FCOPY (
  location IN VARCHAR(40),
  filename IN VARCHAR(256),
  dest_dir IN VARCHAR(40),
  dest_file IN VARCHAR(256),
  start_line IN INTEGER DEFAULT 1,
  end_line IN INTEGER DEFAULT NULL);
```



##### 파라미터

| 이름         | 입출력 | 데이터 타입  | 설명                                                                        |
|--------------|--------|--------------|-----------------------------------------------------------------------------|
| *location*   | IN     | VARCHAR(40)  | 복사할 대상의 원본 파일이 위치하는 디렉토리의 이름                          |
| *filename*   | IN     | VARCHAR(256) | 소스 파일의 이름                                                            |
| *dest_dir*   | IN     | VARCHAR(40)  | 결과 파일이 위치하는 디렉토리의 이름                                        |
| *dest_file*  | IN     | VARCHAR(256) | 결과 파일의 이름                                                            |
| *start_line* | IN     | INTEGER      | 복사할 시작 라인 번호 (기본값: 1)                                           |
| *end_line*   | IN     | INTEGER      | 복사할 마지막 라인 번호. 기본값이면, 파일의 끝까지 복사한다. (기본값: NULL) |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

FCOPY는 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_PATH

-   ACCESS_DENIED

-   INVALID_OPERATION

-   READ_ERROR

-   WRITE_ERROR

#### FFLUSH

버퍼에 존재하는 데이터를 물리적으로 파일에 기록하는 저장 프로시저이다.

##### 구문

```
UTL_FILE.FFLUSH(file IN FILE_TYPE);
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입 | 설명      |
|--------|--------|-------------|-----------|
| *file* | IN     | FILE_TYPE   | 파일 핸들 |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

FFLUSH는 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_FILEHANDLE

-   WRITE_ERROR

#### FOPEN

파일을 읽거나 쓰기 위해 오픈한다.

##### 구문

```
UTL_FILE.FOPEN(
  location IN VARCHAR(40),
  filename IN VARCHAR(256),
  open_mode IN VARCHAR(4),
  max_linesize IN INTEGER DEFAULT NULL);
```



##### 파라미터

| 이름           | 입출력 | 데이터 타입  | 설명                                                         |
| -------------- | ------ | ------------ | ------------------------------------------------------------ |
| *location*     | IN     | VARCHAR(40)  | 파일이 위치한 디렉토리 객체의 이름                           |
| *filename*     | IN     | VARCHAR(256) | 파일의 이름                                                  |
| *open_mode*    | IN     | VARCHAR(4)   | 입력 가능 옵션은 다음 세 가지이다. <br />r: 읽기 w: 쓰기 a: 이어 쓰기 <br />* 주의 사항: rw, wa와 같이 조합해서 사용할 수 없다. |
| *max_linesize* | IN     | INTEGER      | 호환성을 위한 파라미터이며 무시된다.                         |

##### 결과값

성공적으로 수행할 경우 데이터 타입이 FILE_TYPE인 파일 핸들을 반환한다.

##### 예외

FOPEN은 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_PATH

-   ACCESS_DENIED

-   INVALID_OPERATION

-   INVALID_MODE

#### FREMOVE

파일을 삭제하는 저장 프로시저이다.

##### 구문

```
UTL_FILE.FREMOVE (
  location IN VARCHAR(40),
  filename IN VARCHAR(256));
```



##### 파라미터

| 이름       | 입출력 | 데이터 타입  | 설명                        |
|------------|--------|--------------|-----------------------------|
| *location* | IN     | VARCHAR(40)  | 파일이 위치한 디렉토리 이름 |
| *filename* | IN     | VARCHAR(256) | 파일의 이름                 |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

FREMOVE는 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_PATH

-   ACCESS_DENIED

-   DELETE_FAILED

#### FRENAME

파일의 이름을 바꾸거나, 다른 위치로 옮기는 저장 프로시저이다. UNIX mv 명령어와
동일한 기능이다.

##### 구문

```
UTL_FILE.FRENAME (
  location IN VARCHAR(40),
  filename IN VARCHAR(256),
  dest_dir IN VARCHAR(40),
  dest_file IN VARCHAR(256),
  overwrite IN BOOLEAN DEFAULT FALSE );
```



##### 파라미터

| 이름        | 입출력 | 데이터 타입  | 설명                                                         |
| ----------- | ------ | ------------ | ------------------------------------------------------------ |
| *location*  | IN     | VARCHAR(40)  | 원본 파일이 위치하는 디렉토리                                |
| *filename*  | IN     | VARCHAR(256) | 원본 파일의 이름                                             |
| *dest_dir*  | IN     | VARCHAR(40)  | 결과 파일이 위치하는 디렉토리                                |
| *dest_file* | IN     | VARCHAR(256) | 결과 파일의 이름                                             |
| *overwrite* | IN     | BOOLEAN      | 결과 파일이 이미 존재하는 경우 갱신 여부 <br />TRUE: 새로운 파일로 갱신 <br />FALSE(기본값): 갱신하지 않는다. |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

FRENAME에서 발생 가능한 시스템 정의 예외들은 다음과 같다.

-   INVALID_PATH

-   ACCESS_DENIED

-   RENAME_FAILED

#### GET_LINE

파일에서 한 줄씩 읽어오는 저장 프로시저이다.

##### 구문

```
UTL_FILE.GET_LINE(
  file IN FILE_TYPE,  
  buffer OUT VARCHAR(32768),  
  len IN INTEGER DEFAULT NULL);
```



##### 파라미터

| 이름     | 입출력 | 데이터 타입    | 설명                                                                                                                 |
|----------|--------|----------------|----------------------------------------------------------------------------------------------------------------------|
| *file*   | IN     | FILE_TYPE      | 파일 핸들                                                                                                            |
| *buffer* | OUT    | VARCHAR(32768) | 파일에서 읽은 한 라인을 저장할 버퍼                                                                                  |
| *len*    | IN     | INTEGER        | 파일의 하나의 라인에서 읽어 올 수 있는 최대 bytes이다. 입력하지 않을 경우 1024 bytes 크기만큼 읽어온다. 기본값: NULL |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

GET_LINE에서 발생 가능한 시스템 정의 예외는 다음과 같다.

-   NO_DATA_FOUND

-   READ_ERROR

-   INVALID_FILEHANDLE

#### IS_OPEN

파일이 열렸는지 확인한다.

##### 구문

```
UTL_FILE.IS_OPEN(file IN FILE_TYPE);
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입 | 설명      |
|--------|--------|-------------|-----------|
| *file* | IN     | FILE_TYPE   | 파일 핸들 |

##### 결과값

열려있으면 TRUE, 열려있지 않으면 FALSE를 반환한다.

##### 예외

예외를 발생시키지 않는다.

#### NEW_LINE

파일에 개행 문자(“\\n”)를 기록하는 저장 프로시저이다.

##### 구문

```
UTL_FILE.NEW_LINE(
  file IN FILE_TYPE,  
  lines IN INTEGER DEFAULT 1);
```



##### 파라미터

| 이름    | 입출력 | 데이터 타입 | 설명                       |
|---------|--------|-------------|----------------------------|
| *file*  | IN     | FILE_TYPE   | 파일 핸들                  |
| *lines* | IN     | INTEGER     | 기록할 라인의 수 기본값: 1 |

##### 결과값

저장 프로시저이므로 결과값을 반환하지 않는다.

##### 예외

예외를 발생시키지 않는다

#### PUT

버퍼에 파일에서 읽은 문자열을 저장하는 저장 프로시저이다.

##### 구문

```
UTL_FILE.PUT(
  file IN FILE_TYPE,
  buffer IN VARCHAR(32768));
```



##### 파라미터

| 이름     | 입출력 | 데이터 타입    | 설명                               |
|----------|--------|----------------|------------------------------------|
| *file*   | IN     | FILE_TYPE      | 파일 핸들                          |
| *buffer* | IN     | VARCHAR(32768) | 파일에서 읽은 문자열을 저장할 버퍼 |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

PUT은 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_FILEHANDLE

-   WRITE_ERROR

#### PUT_LINE

파일에 문자열을 포함한 한 라인을 기록하는 저장 프로시저이다.

##### 구문

```
UTL_FILE.PUT_LINE(
  file IN FILE_TYPE,
  buffer IN VARCHAR(32768)
  autoflush IN BOOLEAN DEFAULT FALSE);
```



##### 파라미터

| 이름        | 입출력 | 데이터 타입    | 설명                                               |
|-------------|--------|----------------|----------------------------------------------------|
| *file*      | IN     | FILE_TYPE      | 파일 핸들                                          |
| *buffer*    | IN     | VARCHAR(32768) | 파일에서 읽은 문자열을 저장할 버퍼                 |
| *autoflush* | IN     | BOOLEAN        | 버퍼를 비울 것인지 여부 기본값: FALSE(비우지 않음) |

##### 결과값

저장 프로시저이므로 반환하는 결과값은 없다.

##### 예외

PUT_LINE는 다음의 시스템 정의 예외들을 발생시킬 수 있다.

-   INVALID_FILEHANDLE

-   WRITE_ERROR

### UTL_RAW

UTL_RAW 패키지는 RAW(VARBYTE) 타입의 데이터를 다른 데이터 타입으로 변환하거나
조작할 수 있는 함수이다. UTL_RAW 패키지를 구성하는 프로시저와 함수는 아래의 표와
같이 제공한다.

| 프로시저 및 함수         | 설명                                                  |
|--------------------------|-------------------------------------------------------|
| CAST_FROM_BINARY_INTEGER | INTEGER 타입의 데이터를 RAW 타입으로 변환한다.        |
| CAST_FROM_NUMBER         | NUMERIC 타입의 데이터를 RAW 타입으로 변환한다.        |
| CAST_TO_BINARY_INTEGER   | RAW 타입의 데이터를 BINARY_INTEGER 타입으로 변환한다. |
| CAST_TO_NUMBER           | RAW 타입의 데이터를 NUMERIC 타입으로 변환한다.        |
| CAST_TO_RAW              | VARCHAR 타입의 데이터를 RAW 타입으로 변환한다.        |
| CAST_TO_VARCHAR2         | RAW 타입의 데이터를 VARCHAR 타입으로 변환한다.        |
| CONCAT                   | RAW 타입의 데이터를 연결한다.                         |
| LENGTH                   | 입력된 데이터 길이를 반환한다.                        |
| SUBSTR                   | 입력된 데이터의 일부 문자열을 반환한다.               |

#### CAST_FROM_BINARY_INTEGER

INTEGER 타입의 데이터를 RAW 타입으로 변환하여 반환하는 함수이다.

##### 구문

```
UTL_RAW.CAST_FROM_BINARY_INTEGER(
  n IN INTEGER,
  endianess IN INTEGER DEFAULT 1);
```



##### 파라미터

| 이름        | 입출력 | 데이터 타입 | 설명                                          |
|-------------|--------|-------------|-----------------------------------------------|
| *n*         | IN     | INTEGER     | 변환할 데이터                                 |
| *endianess* | IN     | INTEGER     | 호환성을 위한 파라미터이며, 이 값은 무시된다. |

##### 결과값

입력된 INTEGER 타입의 데이터를 RAW 타입으로 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

INTEGER 타입의 123456를 RAW 타입의 데이터로 변환하여 출력한다.

```
iSQL> select utl_raw.cast_from_binary_integer(123456) from dual;
CAST_FROM_BINARY_INTEGER(123456)  
------------------------------------
40E20100          
1 row selected.
```



#### CAST_FROM_NUMBER

NUMERIC 타입의 데이터를 RAW 타입으로 변환하여 반환하는 함수이다.

##### 구문

```
UTL_RAW.CAST_FROM_NUMBER(n IN NUMBER);
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명                       |
|------|--------|-------------|----------------------------|
| *n*  | IN     | NUMBER      | RAW 타입으로 변환할 데이터 |

##### 결과값

입력된 NUMERIC 타입의 데이터를 RAW 타입으로 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

NUMBER 타입의 1.123456789를 RAW 타입으로 변환하여 출력한다.

```
iSQL> select utl_raw.cast_from_number(1.123456789) from dual;
CAST_FROM_NUMBER(1.123456789)
------------------------------------------------------------------------------------
07C1010C22384E5A
1 row selected.
```



#### CAST_TO_BINARY_INTEGER

RAW 타입의 데이터를 INTEGER 타입으로 변환하여 반환하는 함수이다

##### 구문

```
UTL_RAW.CAST_TO_BINARY_INTEGER(
  r IN RAW(8),
  endianess IN INTEGER DEFAULT 1);
```



##### 파라미터

| 이름        | 입출력 | 데이터 타입 | 설명                                          |
|-------------|--------|-------------|-----------------------------------------------|
| *r*         | IN     | RAW(8)      | INTEGER 타입으로 변환할 데이터                |
| *endianess* | IN     | INTEGER     | 호환성을 위한 파라미터이며, 이 값은 무시된다. |

##### 결과값

입력된 RAW 타입의 데이터를 INTEGER타입으로 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

RAW 타입의 40E20100를 INTEGER로 변환하여 출력한다.

```
iSQL> select utl_raw.cast_to_binary_integer('40E20100') from dual;
CAST_TO_BINARY_INTEGER('40E20100')
-------------------------------------
123456      
1 row selected.
```



#### CAST_TO_NUMBER

RAW 타입의 데이터를 NUMERIC 타입으로 변환하여 반환하는 함수이다.

##### 구문

```
UTL_RAW.CAST_TO_NUMBER(r IN RAW(32767));
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명                           |
|------|--------|-------------|--------------------------------|
| *r*  | IN     | RAW(32767)  | NUMERIC 타입으로 변환할 데이터 |

##### 결과값

입력된 RAW 타입의 데이터를 NUMERIC 타입으로 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

RAW 타입의 07C1010C22384E5A 데이터를 NUMBER로 변환하여 출력한다.

```
iSQL> select utl_raw.cast_to_number('07C1010C22384E5A') from dual;
CAST_TO_NUMBER('07C1010C22384E5A')
-------------------------------------
1.12345679  
1 row selected.
```



#### CAST_TO_RAW

VARCHAR 타입의 데이터를 RAW(VARBYTE) 타입으로 변환하여 반환하는 함수이다.

##### 구문

```
UTL_RAW.CAST_TO_RAW(c IN VARCHAR(32767));
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입    | 설명                       |
|------|--------|----------------|----------------------------|
| *c*  | IN     | VARCHAR(32767) | RAW 타입으로 변환할 데이터 |

##### 결과값

입력된 데이터를 RAW 타입으로 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

'altibase'를 RAW 타입으로 출력한다.

```
iSQL> select cast(utl_raw.cast_to_raw('altibase') as raw(10)) from dual;
CAST(UTL_RAW.CAST_TO_RAW('altibase') as RA  
----------------------------------------------
0800616C746962617365  
1 row selected.
```



#### CAST_TO_VARCHAR2

RAW 타입의 데이터를 VARCHAR 타입으로 변환하여 반환하는 함수이다.

##### 구문

```
UTL_RAW.CAST_TO_VARCHAR2(c IN RAW(32767));
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명                           |
|------|--------|-------------|--------------------------------|
| *c*  | IN     | RAW(32767)  | VARCHAR 타입으로 변환할 데이터 |

##### 결과값

입력된 데이터를 VARCHAR 타입으로 변환하여 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

0800616C746962617365 RAW 타입의 데이터를 VARCHAR 타입으로 변환하여 출력한다.

```
iSQL> select cast(utl_raw.cast_to_varchar2('0800616C746962617365') as varchar(8)) from dual;
CAST(UTL_RAW.CAST_TO_VARCHAR2('0800616C746  
----------------------------------------------
altibase  
1 row selected.
```



#### CONCAT

파라미터에 입력된 RAW(VARBYTE) 타입의 데이터를 연결하여 반환하는 함수이다.

##### 구문

```
UTL_RAW.CONCAT(
  r1 IN RAW(32767) DEFAULT NULL,
  r2 IN RAW(32767) DEFAULT NULL,
  r3 IN RAW(32767) DEFAULT NULL,
  r4 IN RAW(32767) DEFAULT NULL,
  r5 IN RAW(32767) DEFAULT NULL,
  r6 IN RAW(32767) DEFAULT NULL,
  r7 IN RAW(32767) DEFAULT NULL,
  r8 IN RAW(32767) DEFAULT NULL,
  r9 IN RAW(32767) DEFAULT NULL,
  r10 IN RAW(32767) DEFAULT NULL,
  r11 IN RAW(32767) DEFAULT NULL,
  r12 IN RAW(32767) DEFAULT NULL);
```



##### 파라미터

| 이름       | 입출력 | 데이터 타입 | 설명                                          |
|------------|--------|-------------|-----------------------------------------------|
| *r1...r12* | IN     | RAW(32767)  | RAW 타입의 데이터 r1\~r12까지 입력할 수 있다. |

##### 결과값

r1\~r12까지 연결한 데이터를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

RAW 타입의 AA와 BB를 연결하여 출력한다.

```
iSQL> select cast(utl_raw.concat(raw'aa', raw'bb') as raw(4)) from dual;
CAST(UTL_RAW.CONCAT(RAW'aa', RAW'bb') as R  
----------------------------------------------
AABB      
1 row selected.
```



#### LENGTH

입력된 RAW 타입의 데이터 길이를 반환하는 함수이다

##### 구문

```
UTL_RAW.LENGTH(r IN RAW(32767));
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입 | 설명                            |
|------|--------|-------------|---------------------------------|
| *c*  | IN     | RAW(32767)  | 길이를 반환할 RAW 타입의 데이터 |

##### 결과값

입력된 RAW 타입의 데이터 길이를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

'altibase' 문자열을 RAW 타입의 데이터 길이로 출력한다.

```
iSQL> select utl_raw.length(utl_raw.cast_to_raw('altibase')) from dual;
LENGTH(UTL_RAW.CAST_TO_RAW('altibase'))
------------------------------------------
12          
1 row selected.
```



#### SUBSTR

입력된 RAW 타입의 데이터에서 문자열의 일부를 반환하는 함수이다.

##### 구문

```
UTL_RAW.SUBSTR(
  r IN RAW(32767),
  pos IN INTEGER,
  len IN INTEGER);
```



##### 파라미터

| 이름  | 입출력 | 데이터 타입 | 설명                                                                                                                                     |
|-------|--------|-------------|------------------------------------------------------------------------------------------------------------------------------------------|
| *r*   | IN     | RAW(32767)  | 입력된 데이터                                                                                                                            |
| *pos* | IN     | INTEGER     | 데이터의 반환을 시작하는 위치. 이 값이 양수이면, 입력 데이터의 앞에서부터 시작한다. 이 값이 음수이면, 입력 데이터의 뒤에서부터 시작한다. |
| *len* | IN     | INTEGER     | 반환할 데이터의 길이. 생략하면 문자열의 끝까지 반환된다.                                                                                 |

##### 결과값

입력된 데이터의 시작 위치부터 지정한 길이만큼의 RAW 데이터를 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

0102030405 RAW 타입의 데이터에서 첫 번째부터 2만큼 길이가 되는 데이터를
반환한다.

```
iSQL> select cast(utl_raw.substr('0102030405',1,2) as raw(2)) from dual;
CAST(UTL_RAW.SUBSTR('0102030405',1,2) as R  
----------------------------------------------
0102  
```



### UTL_SMTP

UTL_SMTP 패키지는 SMTP 서버로 EMAIL을 전송하도록, SMTP 프로토콜을 수행할 수 있다.
UTL_SMTP 패키지를 구성하는 프로시저와 함수는 아래의 표와 같이 제공한다.

| 프로시저 및 함수 | 설명                                                         |
| :--------------- | :----------------------------------------------------------- |
| OPEN_CONNECTION  | TCP 소켓을 생성하여, SMTP 서버에 접속한다.                   |
| HELO             | SMTP 프로토콜의 초기화인 HELO domain 명령어를 전송한다.      |
| MAIL             | SMTP 프로토콜의 송신자 설정인 MAIL FROM:\<reverse-path>명령어를 전송한다. |
| RCPT             | SMTP 프로토콜의 수신자 설정인 RCPT TO:\<forward-path>명령어를 전송한다. |
| OPEN_DATA        | SMTP 프로토콜의 데이터 전송 시작인 DATA 명령어를 전송한다.   |
| WRITE_DATA       | SMTP 프로토콜으로 데이터를 전송한다.                         |
| WRITE_RAW_DATA   | SMTP 프로토콜으로 RAW 데이터를 전송한다.                     |
| CLOSE_DATA       | SMTP 프로토콜의 데이터 전송 종료인 \<CRLF> . \<CRLF>를 전송한다. |
| QUIT             | SMTP 프로토콜의 QUIT 명령어로 연결을 종료한다.               |



#### OPEN_CONNECTION

TCP 소켓을 생성하고, 입력한 IP와 PORT로 SMTP 서버에 접속한다.

##### 구문

```
UTL_SMTP.OPEN_CONNECTION (
  host IN VARCHAR(64),
  port IN INTEGER DEFAULT 25,
  tx_timeout IN INTEGER DEFAULT NULL );
```



##### 파라미터

| 이름       | 입출력 | 데이터 타입 | 설명                                          |
| :--------- | :----- | :---------- | :-------------------------------------------- |
| host       | IN     | VARCHAR(64) | SMTP 서버의 IP 주소                           |
| port       | IN     | INTEGER     | SMTP 서버의 포트 번호                         |
| tx_timeout | IN     | INTEGER     | 호환성을 위한 파라마터이며, 이 값은 무시된다. |

##### 결과값

성공적으로 수행할 경우, CONNECT_TYPE인 접속 핸들을 반환한다.

##### 예외

수행에 실패하는 경우, CONNECT_TYPE은 NULL값으로 반환한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
  V1 CONNECT_TYPE;
  V2 INTEGER;
BEGIN
  V1 := SMTP.OPEN_CONNECTION( '127.0.0.1', 25, null );
  V2 := CLOSE_CONNECT( V1 );
END;
/
```



#### HELO

연결된 SMTP 서버로 HELO domain 명령어를 전송하여, 초기화 핸드 셰이킹를 수행한다.

##### 구문

```
UTL_SMTP.HELO (
  c IN OUT CONNECT_TYPE,
  domain IN VARCHAR(64) );
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입  | 설명                  |
| :----- | :----- | :----------- | :-------------------- |
| c      | IN OUT | CONNECT_TYPE | SMTP 서버의 접속 핸들 |
| domain | IN     | VARCHAR(64)  | 도메인 이름           |

##### 결과값

SMTP 서버의 응답 코드와 메시지를 포함한 VARCHAR 타입의 결과값을 반환한다.
서버 접속에 실패하는 경우 NULL값으로 반환한다.

##### 예외

SMTP 서버에서 실패인 응답 코드를 받거나, SMTP 프로토콜 위반 시에 예외가 발생한다.
HELO 함수를 호출하기 전에 OPEN_CONNECTION 함수를 호출해야 한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
  V1 CONNECT_TYPE;
  V2 INTEGER;
  V3 VARCHAR(65534);
BEGIN
  V1 := SMTP.OPEN_CONNECTION( '127.0.0.1', 25, null );
  V3 := SMTP.HELO( V1, '127.0.0.1', null );
  V2 := CLOSE_CONNECT( V1 );
END;
/
```



#### MAIL

연결된 SMTP 서버로 MAIL FORM:\<reverse-path> 명령어를 전송하여, 송신자를 지정한다.

##### 구문

```
UTL_SMTP.MAIL (
  c IN OUT CONNECT_TYPE,
  sender IN VARCHAR(256),
  parameters IN VARCHAR DEFAULT NULL );
```



##### 파라미터

| 이름       | 입출력 | 데이터 타입  | 설명                                          |
| :--------- | :----- | :----------- | :-------------------------------------------- |
| c          | IN OUT | CONNECT_TYPE | SMTP 서버의 접속 핸들                         |
| sender     | IN     | VARCHAR(256) | 송신자의 주소                                 |
| parameters | IN     | VARCHAR      | 호환성을 위한 파라마터이며, 이 값은 무시된다. |

##### 결과값

SMTP 서버의 응답 코드와 메시지를 포함한 VARCHAR 타입의 결과값을 반환한다.
서버 접속에 실패하는 경우 NULL값으로 반환한다.

##### 예외

SMTP 서버에서 실패인 응답 코드를 받거나, SMTP 프로토콜 위반 시에 예외가 발생한다.
MAIL 함수를 호출하기 전에 HELO 함수를 호출해야 한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
  V1 CONNECT_TYPE;
  V2 INTEGER;
  V3 VARCHAR(65534);
BEGIN
  V1 := SMTP.OPEN_CONNECTION( '127.0.0.1', 25, null );
  V3 := SMTP.HELO( V1, '127.0.0.1', null );
  V3 := SMTP.MAIL( V1, 'test@test.com', null );
  V2 := CLOSE_CONNECT( V1 );
END;
/
```



#### RCPT

연결된 SMTP 서버로 RCPT TO:\<forward-path> 명령어를 전송하여, 수신자를 지정한다.

##### 구문

```
UTL_SMTP.RCPT (
  c IN OUT CONNECT_TYPE,
  recipient IN VARCHAR(256),
  parameters IN VARCHAR DEFAULT NULL );
```



##### 파라미터

| 이름       | 입출력 | 데이터 타입  | 설명                                          |
| :--------- | :----- | :----------- | :-------------------------------------------- |
| c          | IN OUT | CONNECT_TYPE | SMTP 서버의 접속 핸들                         |
| recipient  | IN     | VARCHAR(256) | 수신자의 주소                                 |
| parameters | IN     | VARCHAR      | 호환성을 위한 파라마터이며, 이 값은 무시된다. |

##### 결과값

SMTP 서버의 응답 코드와 메시지를 포함한 VARCHAR 타입의 결과값을 반환한다.
서버 접속에 실패하는 경우 NULL값으로 반환한다.

##### 예외

SMTP 서버에서 실패인 응답 코드를 받거나, SMTP 프로토콜 위반 시에 예외가 발생한다.
RCPT 함수를 호출하기 전에 MAIL 함수를 호출해야 한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
  V1 CONNECT_TYPE;
  V2 INTEGER;
  V3 VARCHAR(65534);
BEGIN
  V1 := SMTP.OPEN_CONNECTION( '127.0.0.1', 25, null );
  V3 := SMTP.HELO( V1, '127.0.0.1', null );
  V3 := SMTP.MAIL( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V3 := SMTP.RCPT( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V2 := CLOSE_CONNECT( V1 );
END;
/
```



#### OPEN_DATA

연결된 SMTP 서버로 DATA 명령어를 전송하여, 데이터 전송을 시작한다.

##### 구문

```
UTL_SMTP.DATA (
  c IN OUT CONNECT_TYPE,
  body IN VARCHAR DEFAULT NULL );
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입  | 설명                                          |
| :--- | :----- | :----------- | :-------------------------------------------- |
| c    | IN OUT | CONNECT_TYPE | SMTP 서버의 접속 핸들                         |
| body | IN     | VARCHAR      | 호환성을 위한 파라마터이며, 이 값은 무시된다. |

##### 결과값

SMTP 서버의 응답 코드와 메시지를 포함한 VARCHAR 타입의 결과값을 반환한다.
서버 접속에 실패하는 경우 NULL값으로 반환한다.

##### 예외

SMTP 서버에서 실패인 응답 코드를 받거나, SMTP 프로토콜 위반 시에 예외가 발생한다.
DATA 함수를 호출하기 전에 RCPT 함수를 호출해야 한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
  V1 CONNECT_TYPE;
  V2 INTEGER;
  V3 VARCHAR(65534);
BEGIN
  V1 := SMTP.OPEN_CONNECTION( '127.0.0.1', 25, null );
  V3 := SMTP.HELO( V1, '127.0.0.1', null );
  V3 := SMTP.MAIL( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V3 := SMTP.RCPT( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V3 := SMTP.OPEN_DATA( V1, null );
  V2 := CLOSE_CONNECT( V1 );
END;
/
```



#### WRITE_DATA

연결된 SMTP 서버로 데이터 전송을 한다.

##### 구문

```
UTL_SMTP.WRITE_DATA (
  c IN OUT CONNECT_TYPE,
  data IN VARCHAR(65534) );
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입    | 설명                  |
| :--- | :----- | :------------- | :-------------------- |
| c    | IN OUT | CONNECT_TYPE   | SMTP 서버의 접속 핸들 |
| data | IN     | VARCHAR(65534) | 전송할 데이터         |

##### 결과값

성공적을 수행할 경우, 전송한 데이터의 길이를 반환한다. 실패하면 -1을 반환한다.

##### 예외

SMTP 프로토콜 위반 시에 예외가 발생한다.
WRITE_DATA 함수를 호출하기 전에 OPEN_DATA 함수를 호출해야 한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
  V1 CONNECT_TYPE;
  V2 INTEGER;
  V3 VARCHAR(65534);
BEGIN
  V1 := SMTP.OPEN_CONNECTION( '127.0.0.1', 25, null );
  V3 := SMTP.HELO( V1, '127.0.0.1', null );
  V3 := SMTP.MAIL( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V3 := SMTP.RCPT( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V3 := SMTP.OPEN_DATA( V1, null );
  V3 := SMTP.WRITE_DATA( V1, 'test' );
  V2 := CLOSE_CONNECT( V1 );
END;
/
```



#### WRITE_RAW_DATA

연결된 SMTP 서버로 RAW 데이터 전송을 한다.

##### 구문

```
UTL_SMTP.WRITE_DATA (
  c IN OUT CONNECT_TYPE,
  data IN RAW(65534) );
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입  | 설명                  |
| :--- | :----- | :----------- | :-------------------- |
| c    | IN OUT | CONNECT_TYPE | SMTP 서버의 접속 핸들 |
| data | IN     | RAW(65534)   | 전송할 RAW 데이터     |

##### 결과값

성공적을 수행할 경우, 전송한 데이터의 길이를 반환한다. 실패하면 -1을 반환한다.

##### 예외

SMTP 프로토콜 위반 시에 예외가 발생한다.
WRITE_RAW_DATA 함수를 호출하기 전에 OPEN_DATA 함수를 호출해야 한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
  V1 CONNECT_TYPE;
  V2 INTEGER;
  V3 VARCHAR(65534);
BEGIN
  V1 := SMTP.OPEN_CONNECTION( '127.0.0.1', 25, null );
  V3 := SMTP.HELO( V1, '127.0.0.1', null );
  V3 := SMTP.MAIL( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V3 := SMTP.RCPT( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V3 := SMTP.OPEN_DATA( V1, null );
  V3 := SMTP.WRITE_RAW_DATA( V1, TO_RAW( 'test' ) );
  V2 := CLOSE_CONNECT( V1 );
END;
/
```



#### CLOSE_DATA

연결된 SMTP 서버로 \<CRLF>.\<CRLF> 명령어를 전송하여, 데이터 전송을 종료한다.

##### 구문

```
UTL_SMTP.CLOSE_DATA (
  c IN OUT CONNECT_TYPE );
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입  | 설명                  |
| :--- | :----- | :----------- | :-------------------- |
| c    | IN OUT | CONNECT_TYPE | SMTP 서버의 접속 핸들 |

##### 결과값

SMTP 서버의 응답 코드와 메시지를 포함한 VARCHAR 타입의 결과값을 반환한다.
서버 접속에 실패하는 경우 NULL값으로 반환한다.

##### 예외

SMTP 서버에서 실패인 응답 코드를 받거나, SMTP 프로토콜 위반 시에 예외가 발생한다.
CLOSE_DATA 함수를 호출하기 전에 OPEN_DATA 함수를 호출해야 한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
  V1 CONNECT_TYPE;
  V2 INTEGER;
  V3 VARCHAR(65534);
BEGIN
  V1 := SMTP.OPEN_CONNECTION( '127.0.0.1', 25, null );
  V3 := SMTP.HELO( V1, '127.0.0.1', null );
  V3 := SMTP.MAIL( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V3 := SMTP.RCPT( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V3 := SMTP.OPEN_DATA( V1, null );
  V3 := SMTP.WRITE_RAW_DATA( V1, TO_RAW( 'test' ) );
  V3 := SMTP.CLOSE_DATA( V1 );
  V2 := CLOSE_CONNECT( V1 );
END;
/
```



#### QUIT

연결된 SMTP 서버로 QUIT 명령어를 전송하여, SMTP 세션과 SMTP 서버와의 연결을 종료한다.

##### 구문

```
UTL_SMTP.QUIT (
  c IN OUT CONNECT_TYPE );
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입  | 설명                  |
| :--- | :----- | :----------- | :-------------------- |
| c    | IN OUT | CONNECT_TYPE | SMTP 서버의 접속 핸들 |

##### 결과값

SMTP 서버의 응답 코드와 메시지를 포함한 VARCHAR 타입의 결과값을 반환한다.
서버 접속에 실패하는 경우 NULL값으로 반환한다.

##### 예외

SMTP 서버에서 실패인 응답 코드를 받거나, SMTP 프로토콜 위반 시에 예외가 발생한다.
QUIT 함수를 호출하기 전에 OPEN_CONNECTION 함수를 호출해야 한다.

##### 예제

```
CREATE OR REPLACE PROCEDURE PROC1
AS
  V1 CONNECT_TYPE;
  V3 VARCHAR(65534);
BEGIN
  V1 := SMTP.OPEN_CONNECTION( '127.0.0.1', 25, null );
  V3 := SMTP.HELO( V1, '127.0.0.1', null );
  V3 := SMTP.MAIL( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V3 := SMTP.RCPT( V1, ['test@test.com](http://nok.altibase.com/mailto:)', null );
  V3 := SMTP.OPEN_DATA( V1, null );
  V3 := SMTP.WRITE_RAW_DATA( V1, TO_RAW( 'test' ) );
  V3 := SMTP.CLOSE_DATA( V1 );
  V3 := SMTP.QUIT( V1 );
END;
/
```



### UTL_TCP

UTL_TCP 패키지는 저장 프로시저에서 TCP 접속을 제어한다. UTL_TCP 패키지를
구성하는 프로시저와 함수는 아래의 표와 같이 제공한다.

| 프로시저 및 함수      | 설명                                      |
|-----------------------|-------------------------------------------|
| CLOSE_ALL_CONNECTIONS | 세션에 연결된 모든 접속 핸들을 닫는다.    |
| CLOSE_CONNECTION      | 연결된 접속 핸들을 닫는다.                |
| IS_CONNECT            | 접속 핸들의 연결 상태를 확인한다.         |
| OPEN_CONNECTION       | 소켓을 생성하여 원격 서버에 접속한다.     |
| WRITE_RAW             | RAW 타입의 데이터를 원격 서버로 전송한다. |

#### CLOSE_ALL_CONNECTIONS

현재 세션에 접속된 모든 접속 핸들을 닫는 프로시저이다.

##### 구문

```
UTL_TCP.CLOSE_ALL_CONNECTIONS;
```



##### 결과값

저장 프로시저이므로 반환되는 결과값은 없다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> CREATE OR REPLACE PROCEDURE PROC1
AS
BEGIN
UTL_TCP.CLOSE_ALL_CONNECTIONS();
END;
/
```



#### CLOSE_CONNECTION

연결된 접속 핸들을 닫는 프로시저이다.

##### 구문

```
UTL_TCP.CLOSE_CONNECTION(c IN CONNECT_TYPE);
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입  | 설명      |
|------|--------|--------------|-----------|
| *c*  | IN     | CONNECT_TYPE | 접속 핸들 |

##### 결과값

저장 프로시저이므로 반환되는 결과값은 없다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> CREATE OR REPLACE PROCEDURE PROC1
 AS
 V1 CONNECT_TYPE;
 V2 INTEGER;
 BEGIN
 V1 := UTL_TCP.OPEN_CONNECTION('127.0.0.1', 22007, NULL, NULL, 1024);
 V2 := UTL_TCP.WRITE_RAW(V1, TO_RAW('MESSAGE'), RAW_SIZEOF('MESSAGE'));
 UTL_TCP.CLOSE_CONNECTION(V1);
 END;
 /
```



#### IS_CONNECT

접속 핸들의 연결 상태를 확인한다.

##### 구문

```
UTL_TCP.IS_CONNECT(c IN CONNECT_TYPE);
```



##### 파라미터

| 이름 | 입출력 | 데이터 타입  | 설명      |
|------|--------|--------------|-----------|
| *c*  | IN     | CONNECT_TYPE | 접속 핸들 |

##### 결과값

성공적으로 수행할 경우 1을 반환한다. 실패한 경우 -1을 반환한다.

##### 예외

예외를 발생시키지 않는다.

##### 예제

```
iSQL> CREATE OR REPLACE PROCEDURE PROC1
    AS
    V1 CONNECT_TYPE;
    V2 INTEGER;
    BEGIN
    V1 := UTL_TCP.OPEN_CONNECTION('127.0.0.1', 22007, NULL, NULL, 1000);
    V2 := UTL_TCP.IS_CONNECT(V1);
    IF V2 = 0 THEN
        PRINTLN('CONNECTED');
        V2 := UTL_TCP.WRITE_RAW(V1, TO_RAW('MESSAGE'), RAW_SIZEOF('MESSAGE'));
        UTL_TCP.CLOSE_CONNECTION(V1);
    ELSE
        PRINTLN('NOT CONNECTD');
    END IF;
    END;
    /
```



#### OPEN_CONNECTION

원격 서버에 접속하기 위하여 소켓을 생성하고, 접속하는 프로시저이다.

##### 구문

```
UTL_TCP.OPEN_CONNECTION(
  remote_host IN VARCHAR(64),
  remote_port IN INTEGER,
  local_host IN VARCHAR(64) DEFAULT NULL,
  local_port IN INTEGER DEFAULT NULL,
  in_buffer_size IN INTEGER DEF DEFAULT NULL,
  out_buffer_size IN INTEGER DEF DEFAULT NULL,
  charset IN VARCHAR(16) DEFAULT NULL,
  newline IN VARCHAR(2) DEFAULT CRLF,
  tx_timeout IN INTEGER DEF DEFAULT NULL,
  wallet_path IN VARCHAR(256) DEFAULT NULL,
  wallet_password IN VARCHAR DEFAULT NULL));
```



##### 파라미터

| 이름              | 입출력 | 데이터 타입  | 설명                                                                                                            |
|-------------------|--------|--------------|-----------------------------------------------------------------------------------------------------------------|
| *remote_host*     | IN     | VARCHAR(64)  | 원격 서버의 IP 주소                                                                                             |
| *remote_port*     | IN     | INTEGER      | 원격 서버의 포트 번호                                                                                           |
| *local_host*      | IN     | VARCHAR(64)  | 호환성을 위한 파라미터이며, 이 값은 무시된다.                                                                   |
| *local_port*      | IN     | INTEGER      | 호환성을 위한 파라미터이며, 이 값은 무시된다.                                                                   |
| *in_buffer_size*  | IN     | INTEGER      | 호환성을 위한 파라미터이며, 이 값은 무시된다.                                                                   |
| *out_buffer_size* | IN     | INTEGER      | 내부 송신 버퍼의 크기를 설정한다. 최솟값은 2048바이트, 최댓값은 32767바이트이다. Null 값은 최솟값으로 설정된다. |
| *charset*         | IN     | VARCHAR(16)  | 호환성을 위한 파라미터이며, 이 값은 무시된다.                                                                   |
| *newline*         | IN     | VARCHAR(2)   | 호환성을 위한 파라미터이며, 이 값은 무시된다.                                                                   |
| *tx_timeout*      | IN     | INTEGER      | 호환성을 위한 파라미터이며, 이 값은 무시된다.                                                                   |
| *wallet_path*     | IN     | VARCHAR(256) | 호환성을 위한 파라미터이며, 이 값은 무시된다.                                                                   |
| *wallet_password* | IN     | VARCHAR      | 호환성을 위한 파라미터이며, 이 값은 무시된다.                                                                   |

##### 결과값

성공적으로 수행할 경우 CONNECT_TYPE인 접속 핸들을 반환한다.

##### 예외

네트워크의 접속 실패 등으로 예외가 발생하면, CONNECT_TYPE으로 NULL 값이
반환된다. UTL_TCP.IS_CONNECT() 함수를 이용하여 접속 핸들의 연결 상태를 확인할 수
있다.

##### 예제

```
iSQL> CREATE OR REPLACE PROCEDURE PROC1
 AS
 V1 CONNECT_TYPE;
 V2 INTEGER;
 BEGIN
 V1 := UTL_TCP.OPEN_CONNECTION('127.0.0.1', 22007, NULL, NULL, 1024);
 V2 := UTL_TCP.WRITE_RAW(V1, TO_RAW('MESSAGE'), RAW_SIZEOF('MESSAGE'));
 UTL_TCP.CLOSE_CONNECTION(V1);
 END;
 /
```



#### WRITE_RAW

입력된 RAW 타입의 데이터를 네트워크에 접속된 핸들이 원격 서버로 전송한다.

##### 구문

```
UTL_TCP.WRITE_RAW(
  c IN CONNECT_TYPE,
  data IN RAW(65534),
  len IN INTEGER DEFAULT NULL);
```



##### 파라미터

| 이름   | 입출력 | 데이터 타입  | 설명                     |
|--------|--------|--------------|--------------------------|
| *c*    | IN     | CONNECT_TYPE | 접속 핸들                |
| *data* | IN     | RAW(65534)   | 전송하려는 데이터        |
| *len*  | IN     | INTEGER      | 전송하려는 데이터의 길이 |

##### 결과값

성공적으로 수행할 경우 네트워크로 전송한 데이터의 길이를 반환한다. 실패하면 -1을
반환한다.

##### 예외

접속 핸들의 연결이 유실되면, UTL_TCP.IS_CONNECT() 함수를 이용하여 접속 핸들의
상태를 확인할 수 있다.

##### 예제

```
iSQL> CREATE OR REPLACE PROCEDURE PROC1
    AS
    V1 CONNECT_TYPE;
    V2 INTEGER;
    BEGIN
    V1 := UTL_TCP.OPEN_CONNECTION('127.0.0.1', 22007, NULL, NULL, 1024);
    V2 := UTL_TCP.WRITE_RAW(V1, TO_RAW('MESSAGE'), RAW_SIZEOF('MESSAGE'));
    UTL_TCP.CLOSE_CONNECTION(V1);
    END;
    /
```



