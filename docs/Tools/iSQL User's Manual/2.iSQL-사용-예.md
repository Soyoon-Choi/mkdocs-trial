# 2.iSQL 사용 예

이 장은 iSQL을 이용하여 데이터베이스를 다루는 몇 가지 예를 설명한다.



### 로그인

iSQL 유틸리티를 사용하기 위해서는 먼저 로그인 과정을 거쳐야 하는데, 커맨드 라인
상에서 직접 연결 정보를 입력하는 방법과 입력 프롬프트 상에서 입력하는 방법이 있다.

```
isql -U userID -P password [-SYSDBA]
또는
isql [-SYSDBA]
```

서버와 연결하기 위한 부가 정보로는 서버 이름(-S), 사용자 ID(-U), 패스워드(-P)가
있다. 사용자 ID와 패스워드는 대소문자를 구별하지 않는다.

SYS 사용자가 관리자 모드로 iSQL 유틸리티를 사용하기 위해서는 -SYSDBA 옵션을
사용한다. SYSDBA 옵션으로 원격 접속이 가능하다.

사용자 ID에 특수 문자 또는 공백이 포함된 경우 큰따옴표를 사용해야 한다.

```
$ isql -U \"user name\"
```



#### 제한 사항

-   한 명의 사용자만 SYSDBA 모드로 접속할 수 있다. 2명 이상의 사용자가
    동시에 SYSDBA 모드로 접속할 수 없다.

-   원격에서 SYSDBA 모드로 접속할 수 있지만, DBMS를 구동할 수는 없다.

시스템 권한에 대한 자세한 정보는 *SQL Reference* 을 참조하기 바란다.

iSQL 사용 중 발생하는 에러에 대한 자세한 정보는 Error Message Reference를
참조하기 바란다.

```
$ isql -U sys -P manager [-SYSDBA]
```

```
$ isql [-sysdba]
-------------------------------------------------------
     Altibase Client Query utility.
     Release Version 7.3.0.0.1
     Copyright 2000, Altibase Corporation or its subsidiaries.
     All Rights Reserved.
-------------------------------------------------------
Write Server Name (default:127.0.0.1) :
Write UserID : sys
Write Password : manager             -> 화면에는 암호가 나타나지 않는다.
ISQL_CONNECTION = TCP, SERVER = 127.0.0.1, PORT_NO = 20300
iSQL(sysdba)>	-> iSQL이 서버와 연결된 상태이며, 여기에서 SQL, iSQL, PSM 명령등을 입력하여 실행할 수 있다.

```



### Altibase의 구동 및 종료

Altibase의 구동 및 종료는 iSQL을 사용해 수행한다.

#### Altibase 구동

Altibase를 구동시키기 위해서는 데이터베이스 생성 시와 마찬가지로 우선 iSQL을
–sysdba 옵션으로 띄워야 한다.

>  Altibase의 startup 명령어는 Altibase(iSQL 포함)를 설치한 유닉스 계정으로만
> 수행이 가능하다.

다음은 iSQL를 이용한 Altibase 구동 예제이며 Altibase 구동에 대한 자세한 설명은
*Administrator’s Manual* 제2장 Altibase 구동 및 종료의 내용을 참조한다.

```
$ isql –s 127.0.0.1 –u sys –p manager –sysdba
-------------------------------------------------------
     Altibase Client Query utility.
     Release Version 7.3.0.0.1
     Copyright 2000, Altibase Corporation or its subsidiaries.
     All Rights Reserved.
-------------------------------------------------------
ISQL_CONNECTION = TCP, SERVER = 127.0.0.1, PORT_NO = 20300
[Connected to idle instance]
iSQL(sysdba)> startup service
Connecting to the DB server... Connected.

TRANSITION TO PHASE : PROCESS

TRANSITION TO PHASE : CONTROL

TRANSITION TO PHASE : META
  [SM] Recovery Phase - 1 : Preparing Database
                            : Dynamic Memory Version => Parallel Loading
  [SM] Recovery Phase - 2 : Loading Database
  [SM] Recovery Phase - 3 : Skipping Recovery & Starting Threads...
                              Refining Disk Table
  [SM] Refine Memory Table : ........................................................ [SUCCESS]
  [SM] Rebuilding Indices [Total Count:134] .................................. [SUCCESS]
TRANSITION TO PHASE : SERVICE
  [CM] Listener started : TCP on port 20300
  [CM] Listener started : UNIX
  [RP] Initialization : [PASS]
--- STARTUP Process SUCCESS ---
Command execute success.
```



#### Altibase 종료

현재 구동중인 Altibase 서버를 종료하려면 SHUTDOWN 명령어를 사용한다.

다음은 iSQL를 이용한 Altibase 종료 예제이며 Altibase 종료에 대한 자세한 설명은
*Administrator’s Manual* 제2장 Altibase 구동 및 종료의 내용을 참조한다.

```
iSQL(sysdba)> shutdown normal
Ok..Shutdown Proceeding....


TRANSITION TO PHASE : Shutdown Altibase
  [RP] Finalization : PASS
shutdown normal success.
```



### 접속 연결 및 해제

#### 접속 연결(CONNECT)

명시된 사용자 ID로 Altibase에 연결한다. 첫 연결 실패 시 CONNECT 명령어는 사용자
ID나 패스워드를 다시 프롬프트(prompt) 하지 않는다.

```
CONNECT [logon][nls] [AS SYSDBA];  
logon: userID[/password]  
nls: NLS=character_set
```



- userID/password
  Altibase에 연결하고자 하는 사용자의 id와 패스워드

- NLS=character_set
  문자집합

  ```
  iSQL> CONNECT sys/manager NLS=US7ASCII
  Connect success.
  ```

- AS SYSDBA
  AS 절은 SYS 사용자가 sysdba 관리자 모드로 서버에 접속하는 것을 허용한다.
  CONNECT가 성공하면 현재의 세션을 종료하고 명시된 사용자 ID와 패스워드,
  altibase.properties 내의 프로퍼티 정보를 사용해서 서버에 접속한다. 따라서 이전의
  세션 정보는 없어진다.
  예를 들어 altibase.properties의 AUTOCOMMIT 모드가 TRUE였고, iSQL에서 AUTOCOMMIT
  모드를 FALSE로 변경하여 쿼리를 수행하다가 이 CONNECT문을 수행하였다면 AUTOCOMMIT
  모드는 altibase.properties 의 AUTOCOMMIT 프로퍼티에 의하여 TRUE로 변경된다.
  CONNECT가 실패한다면 이전의 세션은 종료되고 서버와의 연결이 끊어진 상태가 된다.
  즉, 이후에 수행되는 SQL문의 결과는 모두 “Not connected.” 이다. 만약, 다시 서버와
  연결을 시도할 때는 CONNECT *userID*/*password* [AS SYSDBA];를 수행한다.

```
$ isql
-------------------------------------------------------
     Altibase Client Query utility.
     Release Version 7.3.0.0.1
     Copyright 2000, Altibase Corporation or its subsidiaries.
     All Rights Reserved.
-------------------------------------------------------
Write Server Name (default:127.0.0.1) :
Write UserID : SYS
Write Password :
ISQL_CONNECTION = TCP, SERVER = 127.0.0.1, PORT_NO = 20300
iSQL> SHOW USER;
User : SYS
iSQL> CREATE USER altiadmin IDENTIFIED BY altiadmin1234;
Create success.
iSQL> CONNECT altiadmin/altiadmin1234;
Connect success.
iSQL> SHOW USER;
User : ALTIADMIN
iSQL> CREATE TABLE altitbl(i1 INTEGER, i2 CHAR(5));
Create success.
iSQL> SELECT * FROM tab;
TABLE NAME                               TYPE
---------------------------------------------
ALTITBL                                  TABLE
.
.
.
33 row selected.
iSQL> CONNECT sys/manager;
Connect success.
iSQL> SHOW USER;
User : SYS
iSQL> CREATE TABLE systbl(i1 INTEGER, i2 CHAR(5));
Create success.
iSQL> SELECT * FROM tab;
USER NAME	TABLE NAME	TYPE
-----------------------------------------------
SYSTEM_	SYS_COLUMNS_	SYSTEM TABLE
SYSTEM_	SYS_CONSTRAINTS_	SYSTEM TABLE
.
.
.
ALTIADMIN	ALTITBL		TABLE.
SYS		SYSTBL		TABLE
.
.
.
93 rows selected.
```



> ##### 주의사항
>
> 사용자 이름에 소문자, 특수 문자 또는 공백이 포함된 경우 큰따옴표를 사용해야
> 한다.
>
> ```
> iSQL\> CONNECT "user name";
> ```

#### SSL 접속

##### 서버 전용 모드

서버 전용 모드(SSL_CLIENT_AUTHENTICATION 프로퍼티 값이 0으로 설정)에서 개인
인증서를 사용하는 경우, 서버에서 클라이언트의 인증을 수행하지 않기 때문에
클라이언트 인증서와 개인키 파일의 위치를 지정할 필요가 없다.

서버에서 제공하는 인증서를 검증하기 위해서 -ssl_verify 옵션을 활성화시키고,
서버의 공개키(public key)가 포함된 CA 인증서 파일의 위치를 지정해야 한다.

```
$ export ISQL_CONNECTION=SSL
$ isql -s localhost -u sys -p MANAGER
or
$ isql -s localhost -u sys -p MANAGER -ssl_verify -ssl_ca ~/cert/ca-cert.pem
```



##### 상호 인증 모드

상호 인증 모드(SSL_CLIENT_AUTHENTICATION 프로퍼티 값이 1로 설정)로 개인 인증서를
사용하는 경우, 서버에서 클라이언트 인증을 수행한다. 따라서 서버에 제공하는
클라이언트의 인증서와 개인키 파일의 위치를 지정해야 한다.

서버에서 제공하는 인증서를 검증하기 위해서는 -ssl_verify 옵션을 활성화시키고,
서버의 공개키가 포함된 CA 인증서 파일의 위치를 지정해야 한다.

```
$ export ISQL_CONNECTION=SSL
$ isql -s localhost -u sys -p MANAGER \
-ssl_cert ~/cert/client-cert.pem \
-ssl_key ~/cert/client-key.pem
or
$ isql -s localhost -u sys -p MANAGER \
-ssl_verify -ssl_ca ~/cert/ca-cert.pem \
-ssl_cert ~/cert/client-cert.pem \
-ssl_key ~/cert/client-key.pem
```



#### 접속 해제

현재 세션을 종료하고 서버와의 연결을 끊는다. 이후에 수행되는 SQL문의 결과는 모두
“Not connected.”이며, 다시 서버와 연결을 시도할 때는 CONNECT userID/password;를
수행한다.

```
DISCONNECT;
iSQL> INSERT INTO systbl VALUES(1, 'A1');
1 row inserted.
iSQL> INSERT INTO systbl VALUES(2, 'A2');
1 row inserted.
iSQL> SELECT * FROM systbl;
SYSTBL.I1   SYSTBL.I2  
--------------------------
1           A1     
2           A2     
2 rows selected.
iSQL> DISCONNECT;
Disconnect success.
iSQL> INSERT INTO systbl VALUES(3, 'A3');
[ERR-91020 : No Connection State]
iSQL> SELECT * FROM systbl;
[ERR-91020 : No Connection State]
iSQL> CONNECT sys/manager;
Connect success.
```



#### NOLOG 옵션으로 iSQL 실행

'/NOLOG' 옵션은 대상 데이터베이스에 접속하지 않고 iSQL을 실행하기 위해 제공된다.
이 옵션을 사용하려면, 서버에 접속하지 않더라도 서버 IP 주소와 포트 번호를 반드시
입력해야 한다 .

```
isql -s localhost -port 20300 /NOLOG
```

iSQL을 구동한 후 SQL 구문을 수행하려면, CONNECT 명령어로 대상 데이터베이스
사용자 계정과 비밀번호를 입력하여 데이터베이스에 접속한 이후 가능하다.



### 데이터베이스와 객체 정보 조회

#### 성능 뷰 조회

성능 뷰는 서버의 상태 및 데이터베이스 정보를 조회할 수 있는 데이터 딕셔너리
테이블의 일종으로 Altibase가 제공하는 성능 뷰의 목록을 확인하기 위해서는 다음
명령어를 사용한다.

```
iSQL> SELECT * FROM V$TAB;
TABLE NAME                               TYPE
---------------------------------------------
V$ALLCOLUMN                              PERFORMANCE VIEW
V$ARCHIVE                                PERFORMANCE VIEW
V$BUFFPOOL_STAT                          PERFORMANCE VIEW
V$DATABASE                               PERFORMANCE VIEW
V$DATAFILES                              PERFORMANCE VIEW
V$DISKGC                                 PERFORMANCE VIEW
V$DISKTBL_INFO                           PERFORMANCE VIEW
V$FLUSHINFO                              PERFORMANCE VIEW
```

Altibase가 제공하는 전체 성능 뷰의 목록과 칼럼의 의미 등은 *General Reference*
의 데이터 딕셔너리 설명을 참조한다.

각 성능 뷰의 데이터는 일반 테이블 조회와 동일한 SELECT문을 사용하여 조회할 수
있으며 조인 등을 사용해 다양한 형태로 결과를 출력할 수 있다.

#### 테이블 목록 보기

데이터베이스에 존재하는 모든 테이블에 대한 정보를 알고 싶으면 아래와 같은 명령을
사용하면 된다. sys_tables\_ 메타 테이블은 Altibase에서 제공하는 데이터베이스
카탈로그 정보를 수록하는 시스템 내부 테이블이다.

```
iSQL> SELECT * FROM system_.sys_tables_;
.
.
iSQL> SELECT * FROM tab;  -> 이 명령어는 iSQL에서만 사용가능.
USER NAME	TABLE NAME	TYPE
-----------------------------------------------
.
..
```



#### 테이블 구조 보기

사용자가 생성한 테이블에 관한 정보를 알고 싶으면 아래와 같은 명령을 사용한다.

```
DESC table_name;

CREATE TABLE department (
DNO            SMALLINT     PRIMARY KEY,
DNAME          CHAR(30)     NOT NULL,
DEP_LOCATION   CHAR(9),
MGR_NO         INTEGER );

iSQL> DESC department; 	->table_name: 테이블 정보(구조)를 알고 싶은 테이블명
[ TABLESPACE : SYS_TBS_MEM_DATA ]
[ ATTRIBUTE ]
-----------------------------------------------------------
NAME                  TYPE                        IS NULL
-----------------------------------------------------------
DNO                   SMALLINT        FIXED       NOT NULL
DNAME                 CHAR(30)        FIXED       NOT NULL
DEP_LOCATION          CHAR(9)         FIXED       
MGR_NO                INTEGER         FIXED       
[ INDEX ]
-----------------------------------------------------------
NAME                  TYPE     IS UNIQUE     COLUMN
-----------------------------------------------------------
__SYS_IDX_ID_122      BTREE    UNIQUE        DNO ASC
[ PRIMARY KEY ]
-----------------------------------------------------------
DNO
```

테이블 이름에 소문자, 특수 문자 또는 공백이 포함된 경우 큰따옴표를 사용해야
한다.

```
iSQL> DESC "table name";
iSQL> DESC "user name"."table name";
```



#### 시퀀스 정보 보기

데이터베이스에 존재하는 모든 시퀀스에 대한 정보를 알고 싶으면 아래와 같은 명령을
사용하면 된다.

```
SELECT * FROM seq;

iSQL> CONNECT sys/manager;
Connect success.
iSQL> CREATE USER user1 IDENTIFIED BY user1;
Create success.
iSQL> CONNECT user1/user1;
Connect success.
iSQL> CREATE SEQUENCE seq1 MAXVALUE 100 CYCLE;
Create success.
iSQL> CREATE SEQUENCE seq2;
Create success.
iSQL> CONNECT sys/manager;
Connect success.
iSQL> CREATE SEQUENCE seq2 START WITH 20 INCREMENT BY 30;
Create success.
iSQL> CREATE SEQUENCE seq3 CACHE 40;
Create success.
iSQL> SELECT * FROM seq;
      ->SYS 계정으로 데이터베이스에 접속한 경우 생성된 모든 sequence의 정보를 출력한다.

USER_NAME                                 
--------------------------------------------
SEQUENCE_NAME                             CURRENT_VALUE   INCREMENT_BY    
------------------------------------------------
MIN_VALUE              MAX_VALUE              CYCLE           CACHE_SIZE      
------------------------------------------------
SYS                                       
SEQ2                                      20              30              
1                      9223372036854775806    NO              20              
SYS                                       
SEQ3                                      1               1               
1                      9223372036854775806    NO              40              
USER1                                     
SEQ1                                      1               1               
1                      100                    YES             20              
USER1                                     
SEQ2                                      1               1               
1                      9223372036854775806    NO              20           
4 rows selected.

iSQL> CONNECT user1/user1;
Connect success.

iSQL> SELECT * FROM seq;
	-> user1이 생성한 모든 sequence 들의 정보를 출력한다.
SEQUENCE_NAME                             CURRENT_VALUE   INCREMENT_BY    
------------------------------------------------
MIN_VALUE              MAX_VALUE              CYCLE           CACHE_SIZE      
------------------------------------------------
SEQ1                                      1               1               
1                      100                    YES             20              
SEQ2                                      1               1               
1                      9223372036854775806    NO              20           
2 rows selected.
```



### 트랜잭션 제어

#### 트랜잭션 모드 설정

한 번 명령어를 수행할 때마다 자동으로 commit 할 것인지 여부를 결정하는 기능이다.

```
iSQL> AUTOCOMMIT OFF; -> 사용자가 commit 하기 전에는 commit되지 않음
Set autocommit off success.

iSQL> AUTOCOMMIT ON; -> 명령어를 수행할 때마다 자동으로 commit
Set autocommit on success.
```



#### PLANCOMMIT

```
SET PLANCOMMIT ON/OFF;
```

autocommit off (non-autocommit) 모드에서 explain plan이 on (또는 only) 조건인
경우, desc, select \* from tab; 또는 select \* from seq; 등과 같은 명령어를
수행했을 때 자동으로 commit 할지를 결정하는 기능이다. 기본값은 OFF 이다.

> 참고: 기본값이 OFF 이므로 autocommit off 세션에서 explain plan이 on (또는 only) 조건일 때 Altibase는 위의 명령어(desc, select \* from tab; 또는 select * from seq;)를 자동 commit 하지 않고 오류 메시지를 발생한다.
>
> 이 값이 ON이면, iSQL은 이런 명령어들을 실행한 후 commit을 수행해서 에러가 발생하지 않도록 한다.



### 파일 관리

#### 작업 결과 저장

iSQL을 통해 작업한 결과를 지정한 파일로 저장하는 기능을 제공한다. 다음과 같이
spool 명령을 이용하면 지정한 book.txt 파일에 작업한 결과가 저장된다.

이 기능을 해제하고 싶으면 SPOOL OFF 명령을 사용한다.

```
iSQL> SPOOL book.txt	 
Spool start. [book.txt]	-> 이후의 모든 명령과 그 결과들이 book.txt 파일에  저장된다. 이 파일은 현재 디렉터리에 생성된다.
iSQL> SPOOL OFF
Spool Stop		-> 더 이상 명령과 그 결과들을 파일에 저장하지 않는다.
```



#### 스크립트 파일 실행

##### @ 명령어

```
@file_name[.sql]
또는
START file_name[.sql]
```

*file_name*[*.sql*]: 수행될 스크립트 파일, 확장자를 생략하면 iSQL은 기본
스크립트 파일 확장자(.sql)로 간주한다.

iSQL 명령어와 SQL구문들이 저장된 스크립트 파일을 실행하면, 한번에 파일내의
명령어들을 순차적으로 실행한다.

@ 명령어는 START와 같은 기능을 갖는다.

-   스크립트 파일내의 exit 또는 quit 명령어는 iSQL을 종료시킨다.

-   스크립트 파일내에는 일반적으로 SQL문, iSQL 명령어, 또는 Stored Procedure
    블록 등이 포함될 수 있다.

다음은 \$ALTIBASE_HOME/sample/APRE/schema 디렉터리에 있는 스크립트 schema.sql을
현재 디렉터리에서 수행하는 예이다.

```
iSQL> START schema.sql  	<- 파일내의 sql 문이 실행된다.
또는
iSQL> @schema.sql
```

스크립트 파일을 명시할 때, 사용자 계정의 Altibase 홈 디렉터리(\$ALTIBASE_HOME)를
의미하는 물음표(“?”)를 사용할 수 있다.

다음은 \$ALTIBASE_HOME/sample/APRE/schema 디렉터리에 있는 스크립트 schema.sql을
다른 디렉터리에서 수행하는 예이다.

```
iSQL> @?/sample/schema.sql
```

물음표(“?”)는 다음 iSQL 명령어에서도 사용할 수 있다:

edit, save, load, spool, start

> 스크립트 파일 내에서 주석의 사용은 -- 또는 /\* \*/으로 가능하다.
>
> --는 이 표시 다음부터 그 라인의 끝까지를 주석으로 처리하고 여러 라인을 주석으로 처리할 때는 주석부분을 /\*와 \*/ 사이에 넣으면 된다.

##### @@ 명령어

```
@@file_name[.sql]
```

*file_name*[*.sql*]: 수행될 내포형 스크립트를 나타낸다. 확장자를 생략하면 iSQL은
기본 명령어 파일 확장자(.sql)로 간주한다.

명시된 스크립트를 수행한다. @@ 명령어는 @ 명령어와 유사한 기능을 갖는다.

이 명령어는 수행될 스크립트와 같은 경로에서 명시된 스크립트를 찾는 기능을 가지고
있기 때문에 내포형 스크립트를 수행하는데 유용하다.

@@ 명령어는 다음과 같은 용도로 쓰일 수 있다.

-   사용자가 임의의 스크립트 파일 내에 @@file_name.sql을 입력하고 그 스크립트
    파일을 실행하면, iSQL은 file_name.sql을 호출한 스크립트 파일과 동일한
    디렉터리에서 file_name.sql을 찾아서 수행한다. file_name.sql 은 이를 호출한
    스크립트 파일과 같은 디렉터리에 있어야 한다. 만일 그런 파일이 존재하지
    않으면, iSQL은 오류 메시지를 보여준다.

-   사용자가 iSQL 프롬프트 상에서 @@file_name.sql을 입력하여 실행하는 것은
    @file_name.sql을 실행하는 것과 동일하다.

-   스크립트에는 일반적으로 SQL문, iSQL 명령어, 또는 Stored Procedure 블록 등이
    포함될 수 있다.

-   스크립트 내의 exit 또는 quit 명령어는 iSQL을 종료시킨다.

다음은 \$ALTIBASE_HOME 디렉터리에서 a.sql 스크립트 파일을 실행하는 예제로, 이
파일 내에서 schema.sql 스크립트 파일을 실행한다. 이 예제가 에러 없이 제대로
수행되려면, a.sql은 schema.sql파일이 위치하는 \$ALTIBASE_HOME/sample/APRE/schema
디렉터리에 같이 있어야 한다.

```
iSQL> @sample/APRE/schema/a.sql

$ cat a.sql
@@schema.sql
```

> 참고: 이 후의 예제는 위의 스크립트를 실행해서 생성된 테이블들을 (부록 Schema 참고) 가지고 iSQL 환경에서 질의에 따른 결과를 편집한 것이다.

##### START 명령에 파라미터 전달

```
START file_name[.sql] [param1 [param2] ...]
@file_name[.sql] [param1 [param2] ...]
@@file_name[.sql] [param1 [param2] ...]
```

[param1 [param2] ...] : 스크립트 파일에 파라미터로 전달할 값

스크립트 파일 내 SQL문의 특정 값을 고정하지 않고 사용자가 수행할 때마다
설정하고자 할 때 치환 변수를 사용한다. START, @ 또는 @@ 명령어로 스크립트
파일 수행 시, 치환 변수 자리에 대체하고자 하는 값을 입력하여 파라미터로 전달할
수 있다.

스크립트 파일 내의 치환 변수는 대체하고자 하는 자리에 &와 숫자를 붙여서
사용하며, 숫자는 순서를 의미한다. 단, 이 기능은 SET DEFINE ON이 설정된 경우에만
동작한다. 자세한 설명은 SET DEFINE을 참조하기 바란다.

예를 들어 아래와 같이 emp.sql 파일에 치환 변수가 사용된 경우

```
SELECT ENO, E_LASTNAME FROM EMPLOYEES
WHERE EMP_JOB = '&1'
AND SALARY > &2;
```

START 명령어 수행 시에 programmer, 2000을 파라미터로 같이 입력하면 &1에
programmer, &2에 2000 값이 대체되어 수행된다. 즉 직업이 programmer이고, 월급이
2000을 초과하는 직원이 조회된다.

```
iSQL> SET DEFINE ON; -- ON으로 설정해야 치환변수를 파라미터 값으로 대체
iSQL> START emp.sql programmer 2000
old   2: WHERE EMP_JOB = '&1'
new   2: WHERE EMP_JOB = 'programmer'
old   3: AND SALARY > &2;
new   3: AND SALARY > 2000;

ENO         E_LASTNAME
-------------------------------------
10          Bae
```

iSQL은 치환 변수를 포함하고 있는 라인에 대하여 파라미터 값이 치환되기 전후의 SQL
명령을 함께 출력한다. SET VERIFY OFF를 설정하면 대입 후의 SQL명령은 출력되지
않는다. 치환 변수는 하나의 스크립트에서 여러 번 사용될 수 있으며, 반드시
순서대로 사용하지 않아도 된다.

치환 변수는 아래와 같이 대화식으로도 스크립트의 변수를 파라미터로 치환할 수
있다.

```
START emp.sql
...
Enter value for 1: programmer
old   2: WHERE EMP_JOB = '&1'
new   2: WHERE EMP_JOB = 'programmer'
Enter value for 2: 2000
old   3: AND SALARY > &2;
new   3: AND SALARY > 2000;
```

또한 특정 문자를 치환 변수 뒤에 바로 연결하여 사용하려면, 마침표(.)를 사용하여
치환 변수와 문자를 구분해야 한다.

```
SELECT E_LASTNAME FROM EMPLOYEES WHERE ENO='&1.0';
Enter value for 1: 2
old   1: SELECT E_LASTNAME FROM EMPLOYEES WHERE ENO='&1.0';
new   1: SELECT E_LASTNAME FROM EMPLOYEES WHERE ENO='20';
```



##### SET DEFINE {ON\|OFF}

치환 변수가 포함된 스크립트 파일을 START, @ 또는 @@ 명령어로 수행 시, 치환
변수를 사용자가 입력한 파라미터 값으로 대체할지 여부를 지정한다.

기본값은 OFF로 사용자가 입력한 파라미터 값으로 치환 변수를 대체하지 않는다. 즉,
치환 변수가 포함된 스크립트 파일 수행 시에는 반드시 ON으로 지정해야 한다.

##### SET VERIFY {ON\|OFF}

치환 변수가 포함된 스크립트 파일을 START, @ 또는 @@ 명령어로 수행 시,
파라미터 값으로 교체되기 전후의 SQL문을 출력할지 여부를 지정한다.

기본값은 ON으로 전후 SQL문을 출력한다.

```
$cat Param1.sql
SELECT * FROM T1 WHERE I1 = &1;

iSQL> SET DEFINE ON;
iSQL> SHOW VERIFY;
Verify : On
iSQL> START Param1.sql 5;
iSQL> SELECT * FROM T1
WHERE I1 = &1;
old   2: WHERE I1 = &1;
new   2: WHERE I1 = 5;
T1.I1       T1.I2
---------------------------
5           Hyacinth
1 row selected.

iSQL> SET VERIFY OFF;
iSQL> SHOW VERIFY;
Verify : Off
iSQL> START Param1.sql 5;
iSQL> SELECT * FROM T1
WHERE I1 = &1;
T1.I1       T1.I2
---------------------------
5           Hyacinth
1 row selected.
```



#### SQL문의 저장

현재 iSQLbuffer에 있는 명령어 중 가장 최근에 수행한 명령어를 파일로 저장하는
기능이다.

이 파일은 현재 디렉터리에 생성된다.

```
iSQL> SELECT * FROM book;
iSQL> SAVE book.sql; -> book.sql 파일에 ‘SELECT * FROM book;’가 저장된다.
Save completed.
```



#### SQL문의 로드

지정한 파일의 첫 번째 명령어를 iSQL 버퍼의 마지막 위치에 로드시키는 기능이다.

```
iSQL> LOAD book.sql
iSQL> SELECT * FROM book;
Load completed.
iSQL> /		 -> SELECT * FROM book; 문이 실행된 것을 볼 수 있다.
```



#### DML문 저장

INSERT, UPDATE, DELETE, MOVE 등의 DML문 실행시 이를
\$ALTIBASE_HOME/trc/isql_query.log에 기록한다. 단, DML문 중 SELECT를 실행한 경우에는 로그에 기록되지 않는다.

이 기능을 설정하려면 SET QUERYLOGGING을 ON으로 하고, 해제하려면 OFF하면 된다.

```
iSQL> SET QUERYLOGGING ON;	-> 이후의 모든 DML 문이 $ALTIBASE_HOME/trc/isql_query.log에 저장된다.
iSQL> CREATE TABLE T1 ( I1 INTEGER );
Create success.
iSQL> INSERT INTO T1 VALUES ( 1 );
1 row inserted.
iSQL> UPDATE  T1 SET I1 = 2;
1 row updated.
iSQL> SELECT * FROM T1;
I1  
--------------
2
1 row selected.
iSQL> DELETE FROM T1;
1 row deleted.
iSQL> DROP TABLE T1;
Drop success.
iSQL> EXIT

% cat $ALTIBASE_HOME/trc/isql_query.log	-> SET QUERYLOGGING ON으로 실행한 후의 DML을 확인할 수 있다.
[2009/09/16 10:36:14] [127.0.0.1:25310 SYS] INSERT INTO T1 VALUES ( 1 )
[2009/09/16 10:36:31] [127.0.0.1:25310 SYS] UPDATE T1 SET I1 = 2
[2009/09/16 10:36:37] [127.0.0.1:25310 SYS] DELETE FROM T1
```



#### 질의문 편집

##### 최근 질의문 편집

iSQL 상에서 파일을 생성하고 편집할 수 있도록 명령어 edit를 제공한다.

인수 없이 ed를 실행하면 가장 최근 실행된 질의문이 iSQL.buf 라는 임시 파일로
생성되며 다음과 같은 화면을 볼 수 있다. (지면을 절약하기 위해 몇 줄만 화면으로 표시한다.)

```
iSQL> SELECT sysdate FROM dual;
SYSDATE      
---------------
01-JAN-2000  
1 row selected.

iSQL> ed
SELECT sysdate FROM dual;
~
~
~
"iSQL.buf" 1L, 26C
```



**기존 파일 편집**

존재하는 파일을 편집하기 위해서는 iSQL 상에서 ed 실행 시 그 파일 이름을 뒤에
넣으면 된다. 화면이 초기화 되어 있을 때 빈 줄은 \~(tilde) 문자로 표시된다.

```
iSQL> ed myquery.sql
"myquery.sql"
INSERT INTO employee(ENO, E_FIRSTNAME, E_LASTNAME, SEX) VALUES(21, 'MSJUNG', 'F');
INSERT INTO employee(ENO, E_FIRSTNAME, E_LASTNAME, SEX, JOIN_DATE)
VALUES(22, 'Joshua', 'Baldwin', 'M', TO_DATE('2001-11-19 00:00:00', 'YYYY-MM-DD HH:MI:SS'));
~
~"myquery.sql"
```



##### 히스토리 목록에 있는 질의문 편집

히스토리 목록에서 해당 번호를 사용하여 이전에 수행했던 명령을 편집할 수 있다.
즉, 해당 번호의 질의문이 iSQL.buf 임시 파일로 생성되어 편집을 할 수 있으며, 편집
결과는 히스토리의 마지막에 등록되어 가장 마지막 명령을 재수행하는 ‘/’ 으로도
실행이 가능하다.

```
iSQL> h
1  : SELECT * FROM customers;
2  : SELECT * FROM employees;
iSQL> 2ed
or
iSQL> 2 ed
SELECT * FROM employees;
~
~
"iSQL.buf"
```

> 파일을 편집하기 위해서 명령 줄에 인수 2라는 파일 이름을 넣은 (iSQL\> ed 2) 명령어와 구분된다.
>

편집 후 (employees를 orders로 변경)

```
iSQL> h 		<- 현재 iSQL buffer에 있는 히스토리 목록
1  : SELECT * FROM customers;
2  : SELECT * FROM employees;
 : SELECT * FROM orders;
	<- 2 ed 명령어에 의해 편집된 질의문이 히스토리 목록에 가장 마지막 명령어로 저장된다.

iSQL> /		<- 가장 최근에 수행한 명령어가 실행된다.
ORDERS.ONO            ORDERS.ORDER_DATE    ORDERS.ENO  ORDERS.CNO      
-----------------------------------------------
ORDERS.GNO  ORDERS.QTY  ORDERS.ARRIVAL_DATE  ORDERS.PROCESSING  
-----------------------------------------------
0011290007            2000/11/29 00:00:00  12          7111111431202  
A111100002  70          2000/12/02 00:00:00  C  
0011290011            2000/11/29 00:00:00  12          7610011000001  
E111100001  1000        2000/12/05 00:00:00  D
…
0012310012            2000/12/31 00:00:00  19          7308281201145  
C111100001  250         2001/01/03 00:00:00  O  
30 rows selected.
```



#### 주의사항

파일 이름에 특수 문자 또는 공백이 포함된 경우 큰따옴표를 사용해야 한다.

```
iSQL> SPOOL "file name.txt";
iSQL> START "file name.sql";
iSQL> EDIT "file name.sql";
```



### SELECT 결과 포맷팅

SELECT 문에 대한 결과들을 사용자가 보기 좋게 포맷팅하는 기능이다.

#### SET LINESIZE

SELECT 문 결과 출력시 디스플레이되는 한 라인의 사이즈를 설정한다. 10 에서 200
사이의 값이어야 한다.

```
iSQL> SET LINESIZE 100; --> 한 라인의 디스플레이 크기를 100으로 설정한다.
```



#### SET LOBSIZE

CLOB 칼럼을 SELECT 문으로 조회 시 디스플레이 되는 데이터의 길이를 설정한다.

CLOB 칼럼의 데이터를 SELECT 문으로 조회하기 위해서 우선 트랜잭션 모드를
AUTOCOMMIT OFF로 설정해야 한다.

```
CREATE TABLE C1(I1 INTEGER, I2 CLOB);
INSERT INTO C1 VALUES(1, 'A123456789');
INSERT INTO C1 VALUES(2, 'A1234');
INSERT INTO C1 VALUES(3, 'A12345');
INSERT INTO C1 VALUES(4, 'A1234567890123');

iSQL> autocommit off; 	-> CLOB 칼럼 조회를 위해 트랜잭션 모드를 OFF로 설정한다.
Set autocommit off success.
iSQL> select * from c1;
C1.I1        C1.I2
---------------------------
1	A123456789
2 	A1234
3	A12345
4	A1234567890123
4 rows selected.

iSQL> set lobsize 10; 	-> CLOB 칼럼의 데이터를 select 문으로 조회할 때 화면에 나타나는 데이터 길이를 설정한다.
iSQL> select * from c1;
C1.I1       C1.I2
--------------------------
1           A123456789
2           A1234
3           A12345
4           A123456789
4 rows selected.
```



#### SET LOBOFFSET

CLOB 칼럼을 SELECT 문으로 조회할 때 디스플레이 되는 Clob 데이터의 시작 위치를
설정한다.

CLOB 칼럼의 데이터를 SELECT 문으로 조회하기 위해서 우선 트랜잭션 모드를
AUTOCOMMIT OFF로 설정해야 한다.

```
CREATE TABLE C1(I1 INTEGER, I2 CLOB);
INSERT INTO C1 VALUES(1, 'A123456789');
INSERT INTO C1 VALUES(2, 'A1234');
INSERT INTO C1 VALUES(3, 'A12345');
INSERT INTO C1 VALUES(4, 'A1234567890123');

iSQL> autocommit off;
Set autocommit off success.
iSQL> set loboffset 4; 	-> CLOB 칼럼의 데이터를 select 문으로 조회할 때 화면에 나타나는 데이터의 시작 위치를 설정한다.
iSQL> select * from c1;
C1.I1       C1.I2
--------------------------
1           456789
2           4
3           45
4           4567890123
4 rows selected.
```



#### SET FEEDBACK

SELECT 문 결과 출력시 선택된 결과 건수를 출력한다.

```
SET FEEDBACK ON\|OFF\|n
```

- ON: SELECT문 수행 후 결과 데이터 건수를 출력한다.

- OFF: SELECT문 수행 후 결과 데이터 건수를 출력하지 않는다.

- n: 결과 건수가 n이상일 경우에만 출력한다.


```
iSQL> SET FEEDBACK ON;
iSQL> SELECT * FROM employees WHERE ENO < 3;
ENO         E_LASTNAME            E_FIRSTNAME           EMP_JOB          
------------------------------------------------------------------------------
EMP_TEL          DNO         SALARY      SEX  BIRTH   JOIN_DATE    STATUS  
-----------------------------------------------------------------------------------
1           Moon                  Chan-seung            CEO              
01195662365      3002                    M                       R  
2           Davenport             Susan                 designer         
0113654540                   1500        F  721219  18-NOV-2009  H  
2 rows selected.
```



#### SET PAGESIZE

결과 row들을 몇 개 단위로 보여줄 것인지 결정한다.

```
iSQL> SET PAGESIZE 2;	-> 결과 row를 2개 단위로 보여준다.
iSQL> SELECT * FROM employees;
ENO         E_LASTNAME            E_FIRSTNAME           EMP_JOB          
------------------------------------------------------------------------------
EMP_TEL          DNO         SALARY      SEX  BIRTH   JOIN_DATE    STATUS  
-----------------------------------------------------------------------------------
1           Moon                  Chan-seung            CEO              
01195662365      3002                    M                       R  
2           Davenport             Susan                 designer         
0113654540                   1500        F  721219  18-NOV-2009  H  
ENO         E_LASTNAME            E_FIRSTNAME           EMP_JOB          
------------------------------------------------------------------------------
EMP_TEL          DNO         SALARY      SEX  BIRTH   JOIN_DATE    STATUS  
-----------------------------------------------------------------------------------
3           Kobain                Ken                   engineer         
0162581369       1001        2000        M  650226  11-JAN-2010  H  
4           Foster                Aaron                 PL               
0182563984       3001        1800        M  820730               H  
ENO         E_LASTNAME            E_FIRSTNAME           EMP_JOB          
------------------------------------------------------------------------------
EMP_TEL          DNO         SALARY      SEX  BIRTH   JOIN_DATE    STATUS  
-----------------------------------------------------------------------------------
5           Ghorbani              Farhad                PL               
01145582310      3002        2500        M          20-DEC-2009  H  
6           Momoi                 Ryu                   programmer       
0197853222       1002        1700        M  790822  09-SEP-2010  H
.
.
.
20 rows selected.

iSQL> SET PAGESIZE 0;		-> 결과 전체를 한 단위로 보여준다.
iSQL> SELECT * FROM employees;
ENO         E_LASTNAME            E_FIRSTNAME           EMP_JOB          
------------------------------------------------------------------------------
EMP_TEL          DNO         SALARY      SEX  BIRTH   JOIN_DATE    STATUS  
-----------------------------------------------------------------------------------
1           Moon                  Chan-seung            CEO              
01195662365      3002                    M                       R  
2           Davenport             Susan                 designer         
0113654540                   1500        F  721219  18-NOV-2009  H  
3           Kobain                Ken                   engineer         
0162581369       1001        2000        M  650226  11-JAN-2010  H
.
.
.
20 rows selected.
```



#### SET HEADING

결과에 헤더를 출력할지 결정한다.

```
iSQL> SET HEADING OFF;	  -> 결과에 헤더를 출력하지 않는다.
iSQL> SELECT * FROM employees;


1           Moon                  Chan-seung            CEO              
01195662365      3002                    M                       R  
2           Davenport             Susan                 designer         
0113654540                   1500        F  721219  18-NOV-2009  H  
3           Kobain                Ken                   engineer         
0162581369       1001        2000        M  650226  11-JAN-2010  H
.
.
.
20 rows selected.

iSQL> SET HEADING ON;	-> 결과에 헤더를 출력한다.
iSQL> SELECT * FROM employee;
ENO         E_LASTNAME            E_FIRSTNAME           EMP_JOB          
------------------------------------------------------------------------------
EMP_TEL          DNO         SALARY      SEX  BIRTH   JOIN_DATE    STATUS  
-----------------------------------------------------------------------------------
1           Moon                  Chan-seung            CEO              
01195662365      3002                    M                       R  
2           Davenport             Susan                 designer         
0113654540                   1500        F  721219  18-NOV-2009  H  
3           Kobain                Ken                   engineer         
0162581369       1001        2000        M  650226  11-JAN-2010  H
.
.
.
20 rows selected.
```



#### SET COLSIZE

SELECT 문 결과 출력시 디스플레이되는 CHAR, VARCHAR 타입 칼럼의 사이즈를
설정하여, 길이가 긴 문자열을 포함하는 칼럼이 존재할 경우 인식을 용이하게 한다.

```
iSQL> CREATE TABLE LOCATION(
ID      INTEGER,
NAME    CHAR(20),
ADDRESS VARCHAR(500),
PHONE   CHAR(20));
Create success.
iSQL> INSERT INTO LOCATION VALUES(1, 'ALTIBASE', 'Inyoung Bldg, 5fl 44-11 Youido-dong Youngdungpo-qu seoul, 150-890. Korea', '82-2-769-7500');
1 row inserted.
```

아래는 CHAR 또는 VARCHAR 타입 칼럼의 디스플레이 사이즈를 7로 설정하여 조회하는
예제이다.

```
iSQL> SET COLSIZE 7;
iSQL> SELECT ID,NAME,ADDRESS,PHONE FROM LOCATION;
ID          NAME     ADDRESS  PHONE    
--------------------------------------------
1           ALTIBAS  10Fl.,   82-2-20  
            E        Daerung  82-1000  
                     post-to           
                     wer II,           
                      Guro-d           
                     ong, Gu           
                     ro-qu,            
                     Seoul 1           
                     52-790.           
                      Korea            
1 row selected.
```



#### SET NUM[WIDTH]

NUMERIC, DECIMAL, NUMBER, FLOAT 타입의 SELECT 결과를 표시할 자리수를 설정한다.
유효숫자의 개수가 많은 데이터는 이 값을 크게 설정하면 읽기 쉽다.

아래는 NUMWIDTH를 30으로 설정한 후 NUMERIC, DECIMAL, NUMBER, FLOAT 칼럼을
조회하는 예제이다.

```
iSQL> CREATE TABLE t1
(
c_numeric NUMERIC(38, 0),
c_decimal DECIMAL(38, 0),
c_number NUMBER(38, 0),
c_float FLOAT(38)
);
Create success.
iSQL> INSERT INTO t1 VALUES(12345678901234567890, 12345678901234567890, 12345678901234567890, 12345678901234567890);
1 row inserted.
iSQL> SET NUMWIDTH 30
iSQL> SELECT c_numeric, c_decimal, c_number, c_float FROM t1;
C_NUMERIC C_DECIMAL
-----------------------------------------------------------
C_NUMBER C_FLOAT
-----------------------------------------------------------
12345678901234567890 12345678901234567890
12345678901234567890 12345678901234567890
1 row selected.
```



#### SET NUMF[ORMAT]

##### 구문

```
SET NUMF[ORMAT] format;
```

NUMERIC, DECIMAL, NUMBER, FLOAT 타입의 SELECT 결과를 표시할 수 있는 형식을
설정한다. 이 설정은 SET NUMWIDTH 설정보다 우선한다.

*format*에 설정할 수 있는 형식은 *"General Reference\> 자료형 \> 숫자형 데이터
타입 \> 숫자형 데이타 형식"*을 참고한다.

아래는 지수 형식으로 조회하는 예제이다.

```
iSQL> create table t1(i1 float(30));
Create success.
iSQL> insert into t1 values (123456789012);
1 row inserted.
iSQL> SET NUMFORMAT 9.99EEEE
iSQL> select * from t1;
T1.I1
-------------
  1.23E+11
1 rows selected.
```



#### CL[EAR] COL[UMNMS]

COLUMN 명령어로 설정된 모든 칼럼의 표시 형식을 해제한다.

##### 구문

```
CL[EAR] COL[UMNS]
```



#### COLUMN

SELECT 대상(target)이 되는 칼럼의 표시 형식을 설정하거나 확인할 수 있다. 아래의
데이터 타입일 경우에만 설정이 적용된다.

-   문자형 데이터 타입의 길이

-   숫자형 데이터 타입의 표시 형식

##### 구문

```
COL[UMN] [{column | expr} [option]]
```

*column* 또는 *expr*은 SELECT 대상이 되는 칼럼 또는 식을 가리키며, select 문에
사용한 것과 동일하게 기술해야 한다. COL[UMN] [{*column* \| *expr*}] 명령어만
사용하면 설정한 모든 칼럼 또는 지정한 칼럼에 설정된 형식을 확인할 수 있다.

*option*에서 설정할 수 있는 기능은 아래와 같다.

| 옵션            | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| CLE[AR]         | 지정된 칼럼의 설정을 해제                                    |
| FOR[MAT] format | 칼럼의 표시 형식을 설정한다. <br/>문자형 칼럼: CHAR, VARCHAR 타입의 표시 길이 설정. <br />format은 A10과 같은 텍스트 상수로 지정할 수 있다.<br />SET COLSIZE 설정보다 우선한다. <br />숫자형 칼럼 : NUMBER, DECIMAL, FLOAT, NUMERIC 타입의 표시 형식 설정<br />format에 설정할 수 있는 형식은 "General Reference> 자료형 > 숫자형 데이터 타입 > 숫자형 데이타 형식"을 참고한다. <br />SET NUMFORMAT 설정보다 우선한다. |
| ON\|OFF         | 설정한 표시 형식의 적용 여부<br/>OFF: 칼럼에 대한 설정은 그대로 둔 채, 출력에는 적용하지 않는다. <br />ON : 설정을 적용한다. |

##### 설명

SELECT 구문의 대상 칼럼에 대한 표시 형식을 설정할 수 있다. 동일한 칼럼을 여러
개의 표시 형식으로 설정하면 마지막 형식이 적용된다.

설정한 표시 형식을 적용하지 않으려면 CLEAR 또는 OFF 옵션을 사용할 수 있다. CLEAR
옵션은 설정을 완전히 해제하는 것이며, OFF는 출력만 적용되지 않는 차이가 있다.

##### 예제

아래는 VARCHAR(60)의 address 칼럼의 길이를 20으로 표시하려는 예를 보여준다.

```
iSQL> @schema.sql
iSQL> COLUMN address FORMAT A20
iSQL> select cno, address from customers;
CNO                  ADDRESS
----------------------------------------------
1                    2100 Exposition Boul
                     evard Los Angeles US
                     A
...
```

설정을 삭제하려면 아래와 같이 실행한다.

```
iSQL> COLUMN address CLE
```



### 출력 옵션

#### 수행시간 출력

SQL 문을 실행하는데 걸린 시간을 알려주는 기능이다.

```
iSQL> SET TIMING ON;	  -> 명령 실행 후 마지막 라인에 실행시간을 출력한다.
iSQL> SELECT * FROM employees;
ENO         E_LASTNAME            E_FIRSTNAME           EMP_JOB          
------------------------------------------------------------------------------
EMP_TEL          DNO         SALARY      SEX  BIRTH   JOIN_DATE    STATUS  
-----------------------------------------------------------------------------------
1           Moon                  Chan-seung            CEO              
01195662365      3002                    M                       R  
2           Davenport             Susan                 designer         
0113654540                   1500        F  721219  18-NOV-2009  H
.
.
.
20 rows selected.
elapsed time : 0.01
iSQL> SET TIMING OFF;	-> 실행시간을 출력하지 않는다.
```



#### 수행시간 단위 설정

SQL문의 쿼리 수행 시간 단위를 설정하는 기능이다. 설정할 수 있는 단위는 다음과
같다.

-   초

-   밀리초

-   마이크로초

-   나노초

```
iSQL> SET TIMING ON
iSQL> SET TIMESCALE SEC;
iSQL> SELECT * FROM employees;
ENO         E_LASTNAME            E_FIRSTNAME           EMP_JOB          
------------------------------------------------------------------------------
EMP_TEL          DNO         SALARY      SEX  BIRTH   JOIN_DATE    STATUS  
-----------------------------------------------------------------------------------
1           Moon                  Chan-seung            CEO              
01195662365      3002                    M                       R
...
20 rows selected.
elapsed time : 0.00

iSQL> SET TIMESCALE MILSEC;
iSQL> SELECT * FROM employee;
ENO         E_LASTNAME            E_FIRSTNAME           EMP_JOB          
------------------------------------------------------------------------------
EMP_TEL          DNO         SALARY      SEX  BIRTH   JOIN_DATE    STATUS  
-----------------------------------------------------------------------------------
1           Moon                  Chan-seung            CEO              
01195662365      3002                    M                       R
...
...
20 rows selected.
elapsed time : 0.72

iSQL> SET TIMESCALE MICSEC;
iSQL> SELECT * FROM employee;
ENO         E_LASTNAME            E_FIRSTNAME           EMP_JOB          
------------------------------------------------------------------------------
EMP_TEL          DNO         SALARY      SEX  BIRTH   JOIN_DATE    STATUS  
-----------------------------------------------------------------------------------
1           Moon                  Chan-seung            CEO              
01195662365      3002                    M                       R
...
20 rows selected.
elapsed time : 966.00

iSQL> SET TIMESCALE NANSEC;
iSQL> SELECT * FROM employee;
NO         E_LASTNAME            E_FIRSTNAME           EMP_JOB          
------------------------------------------------------------------------------
EMP_TEL          DNO         SALARY      SEX  BIRTH   JOIN_DATE    STATUS  
-----------------------------------------------------------------------------------
1           Moon                  Chan-seung            CEO              
01195662365      3002                    M                       R
...
20 rows selected.
elapsed time : 681000.00
```



#### 외래키 출력

DESC 명령어를 사용하여 테이블 구조를 볼 때 외래 키에 대한 정보를 보여주는
기능이다.

```
iSQL> SET FOREIGNKEYS ON; 	-> 외래 키에 대한 정보를 출력한다.
iSQL> DESC employees;
[ TABLESPACE : SYS_TBS_MEM_DATA ]
[ ATTRIBUTE ]                                                         
------------------------------------------------------------------------------
NAME                                     TYPE                        IS NULL
------------------------------------------------------------------------------
ENO                                      INTEGER         FIXED       NOT NULL
E_LASTNAME                               CHAR(20)        FIXED       NOT NULL
E_FIRSTNAME                              CHAR(20)        FIXED       NOT NULL
EMP_JOB                                  VARCHAR(15)     FIXED       
EMP_TEL                                  CHAR(15)        FIXED       
DNO                                      SMALLINT        FIXED       
SALARY                                   NUMERIC(10, 2)  FIXED       
SEX                                      CHAR(1)         FIXED       
BIRTH                                    CHAR(6)         FIXED       
JOIN_DATE                                DATE            FIXED       
STATUS                                   CHAR(1)         FIXED       
[ INDEX ]                                                       
------------------------------------------------------------------------------
NAME                                     TYPE     IS UNIQUE     COLUMN
------------------------------------------------------------------------------
__SYS_IDX_ID_238                         BTREE    UNIQUE        ENO ASC
EMP_IDX1                                 BTREE                  DNO ASC
[ PRIMARY KEY ]                                                 
------------------------------------------------------------------------------
ENO

[ FOREIGN KEYS ]                                         
----------------------------------------------------------------------

iSQL> SET FOREIGNKEYS OFF; 	-> 외래 키에 대한 정보를 출력하지 않는다.
iSQL> DESC employees;
[ ATTRIBUTE ]                                                         
------------------------------------------------------------------------------
NAME                                     TYPE                        IS NULL
------------------------------------------------------------------------------
ENO                                      INTEGER         FIXED       NOT NULL
E_LASTNAME                               CHAR(20)        FIXED       NOT NULL
E_FIRSTNAME                              CHAR(20)        FIXED       NOT NULL
EMP_JOB                                  VARCHAR(15)     FIXED       
EMP_TEL                                  CHAR(15)        FIXED       
DNO                                      SMALLINT        FIXED       
SALARY                                   NUMERIC(10, 2)  FIXED       
SEX                                      CHAR(1)         FIXED       
BIRTH                                    CHAR(6)         FIXED       
JOIN_DATE                                DATE            FIXED       
STATUS                                   CHAR(1)         FIXED       
[ INDEX ]                                                       
------------------------------------------------------------------------------
NAME                                     TYPE     IS UNIQUE     COLUMN
------------------------------------------------------------------------------
__SYS_IDX_ID_238                         BTREE    UNIQUE        ENO ASC
EMP_IDX1                                 BTREE                  DNO ASC
[ PRIMARY KEY ]                                                 
----------------------------------------------------------------------
ENO
```



#### Check 제약조건 출력

DESC 명령어를 사용하여 테이블 구조를 볼 때 Check 제약조건에 대한 정보를 보여주는
기능이다.

```
iSQL> SET CHKCONSTRAINTS ON;        -> Check Constraint에 대한 정보를 출력한다.
iSQL> DESC employees;
[ TABLESPACE : SYS_TBS_MEM_DATA ]
[ ATTRIBUTE ]
------------------------------------------------------------------------------
NAME                                     TYPE                        IS NULL
------------------------------------------------------------------------------
ENO                                      INTEGER         FIXED       NOT NULL
E_LASTNAME                               CHAR(20)        FIXED       NOT NULL
E_FIRSTNAME                              CHAR(20)        FIXED       NOT NULL
EMP_JOB                                  VARCHAR(15)     FIXED       
EMP_TEL                                  CHAR(15)        FIXED       
DNO                                      SMALLINT        FIXED       
SALARY                                   NUMERIC(10, 2)  FIXED       
SEX                                      CHAR(1)         FIXED       
BIRTH                                    CHAR(6)         FIXED       
JOIN_DATE                                DATE            FIXED       
STATUS                                   CHAR(1)         FIXED       
[ INDEX ]                                                       
------------------------------------------------------------------------------
NAME                                     TYPE     IS UNIQUE     COLUMN
------------------------------------------------------------------------------
__SYS_IDX_ID_238                         BTREE    UNIQUE        ENO ASC
EMP_IDX1                                 BTREE                  DNO ASC
[ PRIMARY KEY ]                                                 
------------------------------------------------------------------------------
ENO

[ CHECK CONSTRAINTS ]
------------------------------------------------------------------------------
NAME      : EMP_CHECK_SEX1
CONDITION : SEX in ('M', 'F')

iSQL> SET CHKCONSTRAINTS OFF;       -> Check Constraint에 대한 정보를 출력하지 않는다.
iSQL> DESC employees;
[ TABLESPACE : SYS_TBS_MEM_DATA ]
[ ATTRIBUTE ]
------------------------------------------------------------------------------
NAME                                     TYPE                        IS NULL
------------------------------------------------------------------------------
ENO                                      INTEGER         FIXED       NOT NULL
E_LASTNAME                               CHAR(20)        FIXED       NOT NULL
E_FIRSTNAME                              CHAR(20)        FIXED       NOT NULL
EMP_JOB                                  VARCHAR(15)     FIXED       
EMP_TEL                                  CHAR(15)        FIXED       
DNO                                      SMALLINT        FIXED       
SALARY                                   NUMERIC(10, 2)  FIXED       
SEX                                      CHAR(1)         FIXED       
BIRTH                                    CHAR(6)         FIXED       
JOIN_DATE                                DATE            FIXED       
STATUS                                   CHAR(1)         FIXED       
[ INDEX ]                                                       
------------------------------------------------------------------------------
NAME                                     TYPE     IS UNIQUE     COLUMN
------------------------------------------------------------------------------
__SYS_IDX_ID_238                         BTREE    UNIQUE        ENO ASC
EMP_IDX1                                 BTREE                  DNO ASC
[ PRIMARY KEY ]                                                 
------------------------------------------------------------------------------
ENO
```



#### 파티션 출력

DESC 명령어를 사용하여 테이블 구조를 볼 때 파티션에 대한 정보도 함께 보여주는
기능이다.

```
iSQL> create table t1_range(
c1 integer,
c2 integer,
c3 varchar(4))
PARTITION BY RANGE(c3)
(
PARTITION P_2000 VALUES LESS THAN ('2001') TABLESPACE sys_tbs_disk_data,
PARTITION P_2001 VALUES LESS THAN ('2002') TABLESPACE sys_tbs_mem_data,
PARTITION P_DEFAULT VALUES DEFAULT
) tablespace SYS_TBS_DISK_DATA;

iSQL> SET PARTITIONS ON; -> 파티션에 대한 정보를 출력한다.
iSQL> DESC t1_range
[ TABLESPACE : SYS_TBS_DISK_DATA ]
[ ATTRIBUTE ]
----------------------------------------------------
NAME               TYPE              IS NULL               ----------------------------------------------------
C1                 INTEGER                                  
C2                 INTEGER                                  
C3                 VARCHAR(4)                               
T1_RANGE has no index                                     
T1_RANGE has no primary key                              
[ PARTITIONS ]
----------------------------------------------------
Method: Range                                               
Key column(s)                                                
----------------------------------------
NAME                                            
----------------------------------------
C3
Values
----------------------------------------------------
PARTITION NAME        MIN VALUE          MAX VALUE      
----------------------------------------------------
P_2000                                        '2001'
P_2001                  '2001'               '2002'
P_DEFAULT              '2002'                         
Tablespace
---------------------------------------------------
PARTITION NAME                    TABLESPACE NAME
---------------------------------------------------
P_2000                              SYS_TBS_DISK_DATA
P_2001                              SYS_TBS_MEM_DATA
P_DEFAULT                          SYS_TBS_DISK_DATA
iSQL> SET PARTITIONS OFF;       -> 파티션에 대한 정보를 출력하지 않는다.
iSQL> DESC t1_range
[ TABLESPACE : SYS_TBS_DISK_DATA ]
[ ATTRIBUTE ]
----------------------------------------------------
NAME                      TYPE               IS NULL      
----------------------------------------------------
C1                       INTEGER
C2                       INTEGER
C3                       VARCHAR(4)
T1_RANGE has no index
T1_RANGE has no primary key
```



#### 스크립트 파일 실행결과 및 명령어 출력

SET TERM과 SET ECHO 명령어는 스크립트 파일 실행의 결과 및 명령어를 화면상에
보여줄지를 결정한다. 그러나 iSQL 프롬프트 상에서 질의를 직접 입력하는 경우
(예: iSQL> select * from t1;)에는 TERM과 ECHO 설정이 출력에 영향을 미치지 않는다.

스크립트 파일의 실행 결과는 출력(TERM ON)을 기본으로 한다. SET TERM 명령어를
사용해서 TERM 값을 변경하면 ECHO 값도 자동으로 TERM 값과 동일하게 변경된다.
예를 들어, TERM 값을 OFF로 설정하면 ECHO 값도 OFF로 자동 설정되어 iSQL 상에서
스크립트 파일이 실행될 때 스크립트 파일 내의 명령어와 실행 결과가 화면에 출력되지
않는다.

TERM ON 상태에서 ECHO를 OFF로 설정하면 명령어는 출력되지 않고 실행 결과만 화면에
출력된다. 그리고 TERM을 OFF로 설정했더라도 ECHO를 ON으로 설정하면 스크립트 내의 
실행된 명령어를 출력할 수 있다.

다음은 스크립트 파일 실행 결과를 출력하는 예제이다.

```
iSQL> SET TERM ON;       -> 스크립트 실행 결과를 출력한다.
iSQL> @schema.sql
iSQL> ALTER SESSION SET AUTOCOMMIT = TRUE;	  ->결과 시작
Alter success.
iSQL> DROP TABLE ORDERS;
Drop success.
elapsed time : 0.00
iSQL> DROP TABLE EMPLOYEES;
Drop success.
elapsed time : 0.00
.
.
.
iSQL> CREATE INDEX ODR_IDX3 ON ORDERS (GNO ASC);
Create success.
elapsed time : 0.00	  -> 결과 끝
```

아래는 TERM OFF로 설정했더라도, ECHO를 ON 상태로 변경하면 @으로 실행된 스크립트
내의 명령어를 출력하는 예제이다.

```
iSQL> SET TERM OFF;          -> 스크립트 실행 결과를 출력하지 않는다.
iSQL> @schema.sql
iSQL> SELECT eno, e_firstname, e_lastname FROM employees;
	-> 질의를 직접 입력하는 경우 결과는 출력된다.
ENO         E_FIRSTNAME           E_LASTNAME
------------------------------------------------------------
1           Chan-seung            Moon
2           Susan                 Davenport
3           Ken                   Kobain
4           Aaron                 Foster
5           Farhad                Ghorbani
.
.
.
iSQL> SET ECHO ON;	-> @으로 실행된 스크립트 내의 명령어만 출력한다.
iSQL> @schema.sql
ALTER SESSION SET AUTOCOMMIT = TRUE;
DROP TABLE ORDERS;
DROP TABLE EMPLOYEES;
.
.
.
iSQL> CREATE INDEX ODR_IDX3 ON ORDERS (GNO ASC);
Create success.
elapsed time : 0.00	  -> 결과 끝
```



#### 실행 계획 출력

SQL 튜닝을 위하여 iSQL상에서 실행 계획 (Explain Plan)을 출력하는 기능이다. SQL
문의 실행 계획은 SELECT, INSERT, UPDATE, DELETE 등의 DML 문에 대해서 확인이
가능하다.

이를 위해서 SELECT 등의 구문을 수행하기 전에 다음 명령을 수행하여야 한다.

```
ALTER SESSION SET EXPLAIN PLAN = option;
```

여기서 option은 ON, OFF, ONLY의 세 가지 설정이 있으며, 기본 설정값은 OFF이다.

-   ON: SELECT문 실행 후 결과 레코드와 함께 Execution Plan 을 보여준다.

-   ONLY: SELECT문에 대해 Prepare 과정만 수행한 후 Execution 과정을 수행하지
    않고 실행 계획만 보여준다. 주 언어 변수 바인딩이 존재하는 SELECT 문 또는
    실행 수행 시간이 오래 걸리는 질의에 대해 단순히 실행 계획만 확인할 경우 이
    기능을 사용한다.

-   OFF: SELECT문 실행 후 결과 레코드만 보여준다.

사용자가 기술한 WHERE절에 존재하는 조건들의 처리 방법 등의 보다 자세한 정보가
필요한 경우는 다음 명령을 사용한다.

```
ALTER SYSTEM SET TRCLOG_DETAIL_PREDICATE = 1;
```

위의 구문처럼 해당 프로퍼티를 1로 설정하여 ON시키면, 실행 계획 정보에 WHERE절의
조건들이 FIXED KEY RANGE, VARIABLE KEY RANGE, FILTER 등으로 자세하게 분류되어
표시된다. 따라서 WHERE절을 복잡하게 사용한 경우 어떤 술어들이 인덱스 스캔을 통해
수행되는지 확인할 수 있다. 단, 특정 최적화 기법에 의해 질의가 변경된 경우는
이러한 정보가 출력되지 않을 수 있다.

다음은 해당 SQL문을 사용한 출력 예이다.

-   TRCLOG_DETAIL_PREDICATE을 설정하고 EXPLAIN PLAN = ON으로 한 경우

```
iSQL> alter system set trclog_detail_predicate = 1;
Alter success.
iSQL> alter session set explain plan = on;
Alter success.
iSQL> SELECT eno, e_lastname, e_firstname FROM employees WHERE eno = 1;
ENO         E_LASTNAME            E_FIRSTNAME
------------------------------------------------------------
1           Moon                  Chan-seung
1 row selected.
------------------------------------------------------------
PROJECT ( COLUMN_COUNT: 3, TUPLE_SIZE: 48 )
 SCAN ( TABLE: EMPLOYEES, INDEX: __SYS_IDX_ID_238, ACCESS: 1, SELF_ID: 2 )
  [ FIXED KEY ]
  AND
   OR
    ENO = 1
------------------------------------------------------------
```



-   TRCLOG_DETAIL_PREDICATE을 설정하지 않고, EXPLAIN PLAN = ON으로 한 경우

```
iSQL> ALTER SYSTEM SET TRCLOG_DETAIL_PREDICATE = 0;
Alter success.
iSQL> ALTER SESSION SET EXPLAIN PLAN = ON;
Alter success.
iSQL> SELECT eno, e_lastname, e_firstname FROM employees WHERE eno = 1;
ENO         E_LASTNAME            E_FIRSTNAME
------------------------------------------------------------
1           Moon                  Chan-seung
1 row selected.
------------------------------------------------------------
PROJECT ( COLUMN_COUNT: 3, TUPLE_SIZE: 48 )
 SCAN ( TABLE: EMPLOYEES, INDEX: __SYS_IDX_ID_238, ACCESS: 1, SELF_ID: 2 )
------------------------------------------------------------
```



-   TRCLOG_DETAIL_PREDICATE을 설정하지 않고, EXPLAIN PLAN = ONLY로 한 경우

```
iSQL> ALTER SYSTEM SET TRCLOG_DETAIL_PREDICATE = 0;
Alter success.
iSQL> ALTER SESSION SET EXPLAIN PLAN = ONLY;
Alter success.
iSQL> SELECT eno, e_lastname, e_firstname FROM employees WHERE eno = 1;
ENO         E_LASTNAME            E_FIRSTNAME
------------------------------------------------------------
No rows selected.
------------------------------------------------------------
PROJECT ( COLUMN_COUNT: 3, TUPLE_SIZE: 48 )
 SCAN ( TABLE: EMPLOYEES, INDEX: __SYS_IDX_ID_238, ACCESS: ??, SELF_ID: 2 )
------------------------------------------------------------
```

EXPLAIN PLAN = ONLY인 경우 질의 실행 없이 실행 계획만 생성하므로 ACCESS 항목과
같이 실제 실행 후 그 값이 결정되는 항목들은 물음표 (“??”)로 표시된다.

#### 결과 출력 방향 설정

iSQL에서 SELECT 구문으로 조회할 경우, 결과를 세로로 보여줄 것인가 가로로 보여줄
것인가를 선택할 수 있다.

조회 결과가 행이 적고 열이 많을 경우 가로로 출력되면 해당하는 열에 맞는 값을
보기 어렵다. 하지만 조회 결과의 방향을 세로로 설정하면 보기 편리하다.

```
iSQL>SET VERTICAL ON;         -> 출력 결과 모드를 세로로 설정한다.
iSQL> SELECT * FROM employees WHERE eno = 2;
ENO         : 2
E_LASTNAME  : Davenport
E_FIRSTNAME : Susan
EMP_JOB     : designer
EMP_TEL     : 0113654540
DNO         :
SALARY      : 1500
SEX         : F
BIRTH       : 721219
JOIN_DATE   : 18-NOV-2009
STATUS      : H

1 row selected.
```



### iSQL 화면 설정 보기

다음은 현재 세션에서 iSQL 화면 설정 값을 보는 예를 보여준다.

```
iSQL> SHOW USER	 -> 현재 세션에 접속한 사용자
User : SYS
iSQL> SHOW COLSIZE
ColSize  : 0
iSQL> SHOW LOBOFFSET
LobOffset: 0
iSQL> SHOW LINESIZE
Linesize : 100
iSQL> SHOW LOBSIZE
LobSize  : 80
iSQL> SHOW NUMWIDTH
NumWidth : 11
iSQL> SHOW PAGESIZE
Pagesize : 0
iSQL> SHOW TIMESCALE
TimeScale : Second
iSQL> SHOW HEADING
Heading : On
iSQL> SHOW TIMING
Timing : Off
iSQL> SHOW VERTICAL
Vertical  : Off
iSQL> SHOW CHKCONSTRAINTS
ChkConstraints : Off
iSQL> SHOW FOREIGNKEYS
ForeignKeys : Off
iSQL> SHOW PLANCOMMIT
PlanCommit : Off
iSQL> SHOW QUERYLOGGING
QueryLogging : Off
iSQL> SHOW TERM
Term : On
iSQL> SHOW ECHO
Echo : OFF
iSQL> SHOW FEEDBACK
Feedback : 1
iSQL> SHOW ALL
User      : SYS
ColSize   : 0
LobOffset : 0
LineSize  : 80
LobSize   : 80
NumWidth : 11
PageSize  : 0
TimeScale : Second
Heading   : On
Timing    : Off
Vertical  : Off
ChkConstraints : Off
ForeignKeys : Off
Partitions : Off
PlanCommit : Off
QueryLogging : Off
Term : On
Echo : Off
Feedback : 1
Fullname : Off
Sqlprompt : "iSQL> "
Define : Off
```



### 호스트 변수

호스트 변수를 선언하여 사용할 수 있다. 호스트 변수는 프로시저나 함수 실행 시
유용하다.

#### 호스트 변수 선언하기

##### 구문

```
VAR[IABLE] var_name[INPUT|OUTPUT|INOUTPUT] var_type
```

INPUT 또는 OUTPUT 또는 INOUTPUT을 명시하지 않으면 기본값은 자동으로 부여된다.

##### 타입

변수 선언 시 사용할 수 있는 타입은 다음과 같다.

```
INTEGER, BYTE(n), NIBBLE(n),
NUMBER, NUMBER(n), NUMBER(n,m),
NUMERIC, NUMERIC(n), NUMERIC(n,m),
CHAR(n), VARCHAR(n), NCHAR(n), NVARCHAR(n), DATE
DECIMAL, DECIMAL(n), DECIMAL(n,m),
FLOAT, FLOAT(n), DOUBLE, REAL
BIGINT, SMALLINT
```



##### 예제

아래는 변수를 선언하는 예를 보여준다.

```
iSQL> VAR p1 INTEGER
iSQL> VAR p2 CHAR(10)
iSQL> VAR v_double DOUBLE
iSQL> VAR v_real REAL
```



#### 호스트 변수에 값 할당하기

##### 구문

```
EXEC[UTE] :var_name := value;
```



##### 예제

아래는 변수에 값을 할당하는 예를 보여준다.

```
iSQL> EXECUTE :p1 := 100;
Execute success
iSQL> EXEC :p2 := ‘abc’;
Execute success
```



#### 호스트 변수 보기

##### 구문

```
PRINT VAR[IABLE]
```

선언된 모든 변수를 보여준다.

```
PRINT var_name
```

var_name의 타입과 값을 보여준다.

##### 예제

다음은 선언된 모든 변수값을 보여준다.

```
iSQL> PRINT VAR
[ HOST VARIABLE ]
-------------------------------------------------------
NAME                 TYPE                 VALUE
-------------------------------------------------------
P1                   INTEGER              100
P2                   CHAR(10)             abc
V_REAL               REAL                
V_DOUBLE             DOUBLE
iSQL> PRINT p2 	-> 변수 p2에 관한 정보만 출력한다.
NAME                TYPE                   VALUE
-------------------------------------------
P2                  CHAR ( 10 )            abc
```



### PREPARE SQL문 수행

#### Prepared SQL문 수행과 Direct SQL문 수행의 차이

iSQL상에서 SQL문을 수행하면 기본적으로 Direct Execution 방법으로 수행된다.
Direct Execution 이란 질의에 대한 구문 분석, 정당성 검사, 최적화 및 수행을
한번에 수행하는 것을 의미한다.

Prepared Execution 방법은 prepare를 할 때 질의에 대한 구문 분석, 정당성 검사,
최적화까지만 수행하여 질의의 실행 계획을 미리 수립한다. 그 후 클라이언트로부터
실행을 요청받으면 수행한다. ODBC를 사용한 응용프로그램 작성의 경우
Prepared Execution 방법이 일반적으로 사용되며, 호스트 변수 바인딩이 된 SQL문에
대한 반복적인 수행이 필요한 경우에 속도의 이점을 볼 수 있다.

두 가지 수행 방법 사이에는 iSQL 상에서 변수 사용 여부의 차이가 존재하지만,
속도의 차이는 없다. 단, Prepared Execution 방법으로 수행하는 경우, 출력되는
그래프 정보와 실행 계획 정보가 다를 수 있다. 그래프 정보는 최적화까지의 중간
계획을 나타내고, 실행 계획은 변수에 실제 값이 적용된 이후의 계획을 나타내기
때문이다.

#### Prepared SQL문

##### 구문

```
PREPARE SQL_statement;
```



##### 예제

다음은 PREPARE 명령어를 사용한 SQL문 수행 예제이다.

```
iSQL> VAR t1 INTEGER;
iSQL> EXEC :t1 := 1;
Execute success.
iSQL> PREPARE SELECT eno, e_firstname, e_lastname, sex
FROM employees WHERE eno=:t1;
ENO         E_FIRSTNAME           E_LASTNAME            SEX
------------------------------------------------------------------
1           Chan-seung            Moon                  M
1 row selected.
```



### 프로시저 생성과 실행 및 삭제

#### 프로시저 생성

프로시저를 생성하는 기능을 제공한다. 프로시저 생성시 반드시 아래의 구문으로 끝나야 한다.

```
END;
/
```

생성된 프로시저는 sys_procedures\_ 메타 테이블을 참조하여 확인할 수 있다.

#### 프로시저 실행

프로시저를 실행하는 기능을 제공한다. 프로시저를 실행함으로써 다양한 쿼리를
한꺼번에 수행할 수 있다. 실행할 프로시저에 파라미터가 있는 경우 반드시 프로시저
실행전에 파라미터 개수만큼 변수가 선언되어 있어야 한다.

##### 예제1

다음은 INSERT 문을 수행하는 프로시저 emp_proc를 생성하는 예를 보여준다. (IN 파라미터 이용)

```
iSQL> CREATE OR REPLACE PROCEDURE emp_proc(p1 IN INTEGER, p2 IN CHAR(20), p3 IN CHAR(20), p4 IN CHAR(1))
 AS
 BEGIN
 INSERT INTO employees(eno, e_firstname, e_lastname, sex)
 VALUES(p1, p2, p3, p4);
 END;
 /
Create success.
iSQL> SELECT * FROM system_.sys_procedures_ order by created desc limit 1;
USER_ID     PROC_OID
------------------------------------
PROC_NAME                                 OBJECT_TYPE STATUS
----------------------------------------------------------------------
PARA_NUM    RETURN_DATA_TYPE RETURN_LANG_ID RETURN_SIZE
-------------------------------------------------------------
RETURN_PRECISION RETURN_SCALE PARSE_NO    PARSE_LEN   CREATED
-------------------------------------------------------------------------
LAST_DDL_TIME
----------------
2           3208680
EMP_PROC                                  0           0
4
                        2           192         29-FEB-2012
29-FEB-2012
1 row selected.
```

아래는 emp_proc를 실행하는 예를 보여준다.

```
iSQL> VAR eno INTEGER
iSQL> VAR first_name CHAR(20)
iSQL> VAR last_name CHAR(20)
iSQL> VAR sex CHAR(1)
iSQL> EXECUTE :eno := 21;
Execute success.
iSQL> EXECUTE :first_name := 'Joel';
Execute success.
iSQL> EXECUTE :last_name := 'Johnson';
Execute success.
iSQL> EXECUTE :sex := 'M';
Execute success.
iSQL> EXECUTE emp_proc(:eno, :first_name, :last_name, :sex);
Execute success.
iSQL> SELECT eno, e_firstname, e_lastname, sex FROM employees WHERE eno = 21;
ENO         E_FIRSTNAME           E_LASTNAME            SEX  
-----------------------------------------------------------------
21          Joel                  Johnson               M
1 row selected.
```



##### 예제2

다음은 SELECT 문을 수행하는 프로시저 outProc를 생성하는 예를 보여준다.

```
iSQL> CREATE TABLE outTbl(i1 INTEGER, i2 INTEGER);
Create success.
iSQL> INSERT INTO outTbl VALUES(1,1);
1 row inserted.
iSQL> /
1 row inserted.
iSQL> /
1 row inserted.
iSQL> /
1 row inserted.
iSQL> /
1 row inserted.
iSQL> SELECT * FROM outTbl;
OUTTBL.I1   OUTTBL.I2   
---------------------------
1           1           
1           1           
1           1           
1           1           
1           1           
5 rows selected.
iSQL> CREATE OR REPLACE PROCEDURE outProc(a1 OUT INTEGER, a2 IN OUT INTEGER)
AS
BEGIN
  SELECT COUNT(*) INTO a1 FROM outTbl WHERE i2 = a2;
END;
/
Create success.
```

아래는 outProc를 실행하는 예를 보여준다.

```
iSQL> VAR t3 INTEGER
iSQL> VAR t4 INTEGER
iSQL> EXEC :t4 := 1;
Execute success.
iSQL> EXEC outProc (:t3, :t4);
Execute success.
iSQL> PRINT t3;
NAME                 TYPE                 VALUE
-----------------------------------------------
T3                   INTEGER              5                  
```



##### 예제3

다음은 프로시저 outProc1을 생성하는 예를 보여준다.

```
iSQL> CREATE OR REPLACE PROCEDURE outProc1( p1 INTEGER, p2 IN OUT INTEGER, p3 OUT INTEGER)
AS
BEGIN
  p2 := p1;
  p3 := p1 + 100;
END;
/
Create success.
iSQL> VAR v1 INTEGER
iSQL> VAR v2 INTEGER
iSQL> VAR v3 INTEGER
iSQL> EXEC :v1 := 3;
Execute success.
iSQL> EXEC outProc1(:v1, :v2, :v3);
Execute success.
iSQL> PRINT VAR;
[ HOST VARIABLE ]
-----------------------------------------------
NAME                 TYPE                 VALUE
-----------------------------------------------
..
V1                   INTEGER              3
V2                   INTEGER              3
V3                   INTEGER              103
..
```



##### 예제4

다음은 SELECT 문을 수행하는 프로시저 inoutProc를 생성하는 예를 보여준다.

```
iSQL> CREATE TABLE inoutTbl(i1 INTEGER);
Create success.
iSQL> INSERT INTO inoutTbl VALUES(1);
1 row inserted.
iSQL> /
1 row inserted.
iSQL> /
1 row inserted.
iSQL> SELECT * FROM inoutTbl;
INOUTTBL.I1
--------------
1           
1           
1           
3 rows selected.
iSQL> CREATE OR REPLACE PROCEDURE inoutProc (a1 IN OUT INTEGER)
AS
BEGIN
  SELECT COUNT(*) INTO a1 FROM inoutTbl WHERE i1 = a1;
END;
/
Create success.
iSQL> VAR t3 INTEGER
iSQL> EXEC :t3 := 1;
Execute success.
iSQL> EXEC inoutProc(:t3);
Execute success.
iSQL> PRINT t3;
NAME                 TYPE                 VALUE
-----------------------------------------------
T3                   INTEGER              3
```



##### 예제5

다음은 프로시저 inoutProc1을 생성하는 예를 보여준다.

```
iSQL> CREATE OR REPLACE PROCEDURE inoutProc1( p1 INTEGER, p2 IN OUT INTEGER, p3 OUT INTEGER)
AS
BEGIN
  p2 := p1 + p2;
  p3 := p1 + 100;
END;
/
Create success.
```

아래는 inoutProc1을 실행하는 예를 보여준다.

```
iSQL> VAR v1 INTEGER
iSQL> VAR v2 INTEGER
iSQL> VAR v3 INTEGER
iSQL> EXEC :v1 := 3;
Execute success.
iSQL> EXEC :v2 := 5;
Execute success.
iSQL> EXEC inoutProc1(:v1, :v2, :v3);
Execute success.
iSQL> PRINT VAR;
[ HOST VARIABLE ]
-----------------------------------------------
NAME                 TYPE                 VALUE
-----------------------------------------------
..
V1                   INTEGER              3
V2                   INTEGER              8
V3                   INTEGER              103
..
```



#### 프로시저 삭제

프로시저를 삭제하는 기능을 제공한다.

다음은 emp_proc를 삭제하는 예를 보여준다.

```
iSQL> DROP PROCEDURE emp_proc;
Drop success
```



### 함수 생성과 실행 및 삭제

#### 함수 생성

함수를 생성하는 기능을 제공한다. 함수 생성시 반드시 아래 구문으로 끝나야 하며 리턴 타입이 정의되어 있어야 한다.

```
END;
/
```

생성된 함수는 sys_procedures\_ 메타 테이블을 참조하여 확인할 수 있다.

다음은 UPDATE 문과 SELECT 문을 수행하는 함수 emp_func를 생성하는 예를 보여준다.

```
iSQL> CREATE OR REPLACE FUNCTION emp_func(f1 IN INTEGER)
RETURN NUMBER
AS
 f2 NUMBER;
BEGIN
 UPDATE employees SET salary = 1000000 WHERE eno = f1;
 SELECT salary INTO f2 FROM employees WHERE eno = f1;
 RETURN f2;
END;
/
Create success.

iSQL> SELECT * FROM system_.sys_procedures_;
USER_ID     PROC_OID             PROC_NAME                                 
-------------------------------------------------------------------------------
OBJECT_TYPE STATUS      PARA_NUM    RETURN_DATA_TYPE RETURN_LANG_ID
--------------------------------------------------------------------------
RETURN_SIZE RETURN_PRECISION RETURN_SCALE PARSE_NO    PARSE_LEN   
------------------------------------------------------------------------
CREATED      LAST_DDL_TIME
------------------------------
.
.
.
2           3300024              INOUTPROC1                                
0           0           3                                   
                                    2           132         
15-SEP-2010  15-SEP-2010  
2           3302344              EMP_FUNC                                  
1           0           1           6           30000       
23          38          0           3           209         
15-SEP-2010  15-SEP-2010  
36 rows selected.
```



#### 함수 실행

함수를 실행하는 기능을 제공한다. 함수를 실행함으로써 다양한 쿼리를 한꺼번에
수행할 수 있다. 실행할 함수에 파라미터가 있는 경우 반드시 함수 실행전에 파라미터
개수만큼 변수가 선언되어 있어야 한다. 또한, 함수의 실행 결과를 저장할 변수도
정의되어 있어야 한다.

다음은 emp_func를 실행하는 예를 보여준다.

```
iSQL> VAR eno INTEGER
iSQL> VAR ret NUMBER
iSQL> EXEC :eno := 11;
Execute success.
iSQL> EXEC :ret := emp_func(:eno);
Execute success.
iSQL> SELECT eno, salary FROM employees WHERE eno = 11;
ENO         SALARY      
---------------------------
11          1000000     
1 row selected.
```



#### 함수 삭제

함수를 삭제하는 기능을 제공한다.

다음은 emp_func를 삭제하는 예를 보여준다.

```
iSQL> DROP FUNCTION emp_func;
Drop success
```



### 사용자 편의 기능

#### 히스토리

이전에 수행했던 명령들의 리스트를 보여 준다.

해당 번호를 사용하여 이전에 수행했던 명령을 간단하게 실행할 수 있다.

```
iSQL> HISTORY;	-> history 목록보기
```

또는

```
iSQL> H;		
1 : SELECT * FROM tab;
2 : SELECT * FROM book;
3 : HISTORY;

iSQL> / -> 가장 마지막 명령(HISTORY;)을 재수행
iSQL> 2/		->  history 목록의  2번에 해당하는 명령(SELECT * FROM book;)실행
```

#### 히스토리 저장

iSQL에서 실행한 명령어들을 iSQL 종료 시 파일로 자동 저장하는 기능이다. 이 기능을 활성화시키면 iSQL 재실행 시 파일에 저장된 이전 명령어들이 자동으로 로딩되기 때문에, 사용자가 화살표 키를 눌러서 이전 명령어에 접근 및 실행할 수 있다.

히스토리 저장 기능을 사용하려면 ISQL_HIST_FILE 환경변수를 설정하고 iSQL을 실행해야 한다. 

```
$ export ISQL_HIST_FILE=~/.isql_history
```

히스토리 저장 기능을 끄기 위해서는 ISQL_HIST_FILE 환경변수를 삭제한다.

```
$ unset ISQL_HIST_FILE
```

##### 기본값

사용 안 함

##### 제약 사항

- 명령 프롬프트나 쉘 프롬프트에서 키보드 방향키를 이용해 이전 명령어를 확인할 수 있는 경우에 사용 가능
- 최대 100개 저장 가능

사용자가 iSQL 프롬프트에서 입력한 모든 명령어가 파일에 저장되기 때문에 데이터베이스 사용자 암호 같은 민감한 정보도 유출될 수 있으므로 파일 접근 관리에 유의해야 한다.

#### 쉘 명령

iSQL에서 !다음에 바로 쉘 명령을 수행할 수 있는 편리한 기능이다.

```
iSQL> !ls -al
total 3417
-rw-r-----   1 wlgml337 section      1198 Nov  1 13:30 .aliases
-rw-------   1 wlgml337 section      5353 Oct 18 21:17 .bash_history
-rw-r-----   1 wlgml337 section      1436 Nov  2 15:42 .bashrc
-rw-r-----   1 wlgml337 section      1549 Dec 13 17:36 .profile
drwxr-x---   2 wlgml337 section       512 Nov  2 02:00 TEMP
drwxr-xr-x   2 root     root          512 Oct 16 11:29 TT_DB
-rw-------   	 1 wlgml337 section   	 3446548 Dec 18 13:19 core
drwxr-x---   2 wlgml337 section       512 Nov 11 16:33 cron
drwxr-x---   2 wlgml337 section       512 Nov 15 10:52 test
drwxr-xr-x   6 wlgml337 section       512 Nov 11 11:45 work
```



#### 명령 프롬프트

기본 명령 프롬프트인 'iSQL\>' 대신 다른 값을 설정하여 프롬프트를 변경할 수 있다.
현재 접속한 사용자, 현재 시간 등의 런타임 변수가 포함된 경우 SET SQLPROMPT는
동적으로 변수를 치환한다.

```
SET SQLP[ROMPT] {text}
```

사용 가능한 치환 변수는 아래와 같다.

| 변수                 | 설명                                                                   |
|----------------------|------------------------------------------------------------------------|
| \_CONNECT_IDENTIFIER | 접속한 서버. "host:port_no"로 표현된다.                                |
| \_DATE               | 현재 시간. DATE_FORMAT에 설정된 형식으로 표현된다.                     |
| \_PRIVILEGE          | iSQL 접속 권한을 보여준다. sysdba로 접속한 경우 '(sysdba)'로 치환된다. |
| \_USER               | 현재 접속한 사용자 이름.                                               |

##### 예제

```
iSQL>SET SQLPROMPT "_CONNECT_IDENTIFIER> "

iSQL>SET SQLP "_USER> "

iSQL>SET SQLPROMPT "_USER'@'_CONNECT_IDENTIFIER > "

iSQL>SET SQLPROMPT "_USER on _DATE from _CONNECT_IDENTIFIER> "
```



#### 도움말

iSQL이 제공하는 명령에 대한 도움말을 제공한다. HELP 명령은 도움말 사용법을 보여
주며 특정 명령에 대한 도움말은 HELP 명령 다음에 정보를 알고자 하는 명령을
입력하면 된다.

```
iSQL> HELP;
Use 'help [command]'
Enter 'help index' for a list of command
iSQL> HELP INDEX;
/               EXIT            PARTITIONS
@               EXPLAINPLAN     QUERYLOGGING
ALTER           FEEDBACK        QUIT
AUTOCOMMIT      FOREIGNKEYS     ROLLBACK
CHKCONSTRAINTS  FULLNAME        SAVE
CL[EAR]         H[ISTORY]       SELECT
COL[UMN]        HEADING         SPOOL
COLSIZE         INSERT          SQLP[ROMPT]
COMMIT          LINESIZE        START
CREATE          LOAD            TERM
DEFINE          LOBOFFSET       TIMESCALE
DELETE          LOBSIZE         TIMING
DESC            MERGE           UPDATE
DROP            MOVE            USER
ECHO            NUM[WIDTH]      VAR[IABLE]
EDIT            NUMF[ORMAT]     VERTICAL
EXECUTE         PAGESIZE

iSQL> HELP EXIT;
exit;
or
quit; - exit iSQL
```



### 내셔널 캐릭터 사용법

NCHAR 및 NVARCHAR 타입의 내셔널 캐릭터 상수 문자를 사용하기 위해서 아래와 같은
방법으로 환경변수 등을 설정해야 데이터의 손실 염려가 없다.

- 환경변수 ALTIBASE_NLS_NCHAR_LITERAL_REPLACE의 값을 1로 설정한다.

  ```
  $ export ALTIBASE_NLS_NCHAR_LITERAL_REPLACE =1
  ```

     

- SQL 구문에서 NCHAR 타입 상수 문자열을 사용하기 위해 해당 문자열 바로 앞에
  “N”을 붙여 사용한다.

  ```
  iSQL> create table t1 (c1 nvarchar(10));
  Create success.
  iSQL> insert into t1 values (N'AB가나');
  1 row inserted.
  iSQL> select * from t1;
  C1
  ------------------------
  AB가나
  1 row selected.
  ```
